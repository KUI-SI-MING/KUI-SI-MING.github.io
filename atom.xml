<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>葵的博客</title>
  
  <subtitle>Let life be beautiful like summer fiowers and death like autumn leaves</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-10T15:59:07.867Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>KUI</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构面试题C++版(二)</title>
    <link href="http://yoursite.com/2019/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98C-++%E7%89%88(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2019/03/28/数据结构面试题C-++版(二)/</id>
    <published>2019-03-28T14:32:13.000Z</published>
    <updated>2019-04-10T15:59:07.867Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">使用C++语言解决常见的数据结构面试题<br><a id="more"></a></font></p><h3 id="一、二叉树"><a href="#一、二叉树" class="headerlink" title="一、二叉树"></a><font color="black" size="4" face="微软雅黑">一、二叉树</font></h3><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">1.创建二叉树<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BTDataType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* <span class="title">left</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;BTNode, *pBTNode;</span><br><span class="line"><span class="function">pBTNode <span class="title">BuyBTNode</span><span class="params">(BTDataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pBTNode newnode = (pBTNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">newnode-&gt;data = x;</span><br><span class="line">newnode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">newnode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pBTNode <span class="title">BinaryTreeCreate</span><span class="params">(BTDataType* a, <span class="keyword">int</span> n, <span class="keyword">int</span>* pi)</span><span class="comment">//对当前数组进行取址操作，若为取值则在每次递归返回后 i 的值并没有改变</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[*pi] != <span class="string">'#'</span>)</span><br><span class="line">&#123;</span><br><span class="line">pBTNode root = BuyBTNode(a[*pi]);</span><br><span class="line">++(*pi);</span><br><span class="line">root-&gt;left = BinaryTreeCreate(a, n, pi);</span><br><span class="line">++(*pi);</span><br><span class="line">root-&gt;right = BinaryTreeCreate(a, n, pi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">2.前/中/后遍历二叉树(递归&amp;非递归)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BinTree *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        preOrder1(root-&gt;lchild);</span><br><span class="line">        preOrder1(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前序非递归</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder_R</span><span class="params">(BinTree *root)</span>     <span class="comment">//非递归前序遍历 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(BinTree *root)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        inOrder1(root-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        inOrder1(root-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归中序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder_R</span><span class="params">(BinTree *root)</span>      </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinTree*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.push(p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            p=s.top();</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归后序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder1</span><span class="params">(BinTree *root)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span><span class="params">(root!=<span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        postOrder1(root-&gt;lchild);</span><br><span class="line">        postOrder1(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归后序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder2</span><span class="params">(BinTree *root)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BTNode*&gt; s;</span><br><span class="line">    BinTree *p=root;</span><br><span class="line">    BTNode *temp;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>||!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)              <span class="comment">//沿左子树一直往下搜索，直至出现没有左子树的结点 </span></span><br><span class="line">        &#123;</span><br><span class="line">            BTNode *btn=(BTNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));</span><br><span class="line">            btn-&gt;btnode=p;</span><br><span class="line">            btn-&gt;isFirst=<span class="literal">true</span>;</span><br><span class="line">            s.push(btn);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            temp=s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;isFirst==<span class="literal">true</span>)     <span class="comment">//表示是第一次出现在栈顶 </span></span><br><span class="line">             &#123;</span><br><span class="line">                temp-&gt;isFirst=<span class="literal">false</span>;</span><br><span class="line">                s.push(temp);</span><br><span class="line">                p=temp-&gt;btnode-&gt;rchild;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                        <span class="comment">//第二次出现在栈顶 </span></span><br><span class="line">             &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;temp-&gt;btnode-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                p=<span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">3.层序遍历二叉树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">    TreeNode *front;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    q.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        front = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (front-&gt;left)</span><br><span class="line">            q.push(front-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (front-&gt;right)</span><br><span class="line">            q.push(front-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c "</span>, front-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">4.求二叉树的高度<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursion</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==null)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> leftheight=getHeight(root.left);</span><br><span class="line"><span class="keyword">int</span> rightheight=getHeight(root.right);</span><br><span class="line"><span class="keyword">return</span> Math.max(leftheight, rightheight)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==null)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> height=<span class="number">0</span>;</span><br><span class="line">Stack&lt;TreeNode&gt; nodes=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">Stack&lt;Integer&gt; tag=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(root!=null||!nodes.isEmpty())&#123;</span><br><span class="line"><span class="keyword">while</span>(root!=null)&#123;</span><br><span class="line">nodes.push(root);</span><br><span class="line">tag.push(<span class="number">0</span>);</span><br><span class="line">root=root.left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tag.peek()==<span class="number">1</span>)&#123;</span><br><span class="line">height=Math.max(height, nodes.size());</span><br><span class="line">nodes.pop();</span><br><span class="line">                tag.pop();</span><br><span class="line">root=null;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">root=nodes.peek();</span><br><span class="line">root=root.right;</span><br><span class="line">tag.pop();</span><br><span class="line">tag.push(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequence</span> &#123;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==null)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Queue&lt;TreeNode&gt; <span class="built_in">queue</span>=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="built_in">queue</span>.add(root);</span><br><span class="line"><span class="keyword">int</span> height=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">queue</span>.isEmpty())&#123;</span><br><span class="line">TreeNode node=<span class="built_in">queue</span>.peek();</span><br><span class="line"><span class="keyword">if</span>(node.left==null&amp;&amp;node.right==null)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node.left!=null)&#123;</span><br><span class="line"><span class="built_in">queue</span>.add(node.left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node.right!=null)&#123;</span><br><span class="line"><span class="built_in">queue</span>.add(node.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>.poll();</span><br><span class="line">height++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(height);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">TreeNode root=<span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">root.left=<span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">root.right=<span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">System.out.println(getHeight(root));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">5.求二叉树中结点的个数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一 : 结点个数= 树的左子树结点，加右子树结点+根结点（1）</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">size_t</span> TreeSize(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//统计左子树的节点个数</span></span><br><span class="line">     <span class="keyword">size_t</span> lsize=TreeSize(root-&gt;lchild);</span><br><span class="line">     <span class="comment">//统计右子树的节点个数</span></span><br><span class="line">     <span class="keyword">size_t</span> rsize=TreeSize(root-&gt;rchild</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>+lsize+rsize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二、先序遍历加计数器</span></span><br><span class="line"><span class="keyword">void</span> _TreeSize1(TreeNode* root, <span class="keyword">size_t</span>* count)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//空树</span></span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(count==<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//非法输入</span></span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     (*count)++;</span><br><span class="line">     _TreeSize1(root-&gt;lchild,count);</span><br><span class="line">     _TreeSize2(root-&gt;rchild,count);</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">size_t</span> TreeSize1(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//空树</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">size_t</span> count=<span class="number">0</span>;</span><br><span class="line">     _TreeSize1(root,&amp;count);</span><br><span class="line">     <span class="keyword">return</span> count ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;使用C++语言解决常见的数据结构面试题&lt;br&gt;
    
    </summary>
    
    
      <category term="二叉树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
      <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
      <category term="哈希" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>数据结构面试题C++版（一）</title>
    <link href="http://yoursite.com/2019/03/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%9D%A2%E8%AF%95%E9%A2%98C++%E7%89%88(%E4%B8%80)/"/>
    <id>http://yoursite.com/2019/03/25/数据结构面试题C++版(一)/</id>
    <published>2019-03-25T08:21:35.000Z</published>
    <updated>2019-03-28T14:30:03.842Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">使用C++语言解决常见的数据结构面试题<br><a id="more"></a></font></p><h3 id="一、链表和顺序表"><a href="#一、链表和顺序表" class="headerlink" title="一、链表和顺序表"></a><font color="black" size="4" face="微软雅黑">一、链表和顺序表</font></h3><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">1.从尾到头打印单链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//①.利用指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ArrayList;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(tail != head)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = head;</span><br><span class="line">            <span class="keyword">while</span>(cur-&gt;next != tail)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = cur;</span><br><span class="line">            ArrayList.push_back(tail-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ArrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//②.利用栈的特性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ArrayList;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stacknode;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            stacknode.push(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出栈，将逆序后的链表元素放入 ArrayList</span></span><br><span class="line">        <span class="keyword">while</span>(!stacknode.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ArrayList.push_back(stacknode.top());</span><br><span class="line">            stacknode.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ArrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">//③.递归，若链太长则容易栈溢出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ArrayList;</span><br><span class="line">        PrintListFromTailToHead(head,ArrayList);</span><br><span class="line">        <span class="keyword">return</span>  ArrayList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">PrintListFromTailToHead</span><span class="params">(ListNode* head,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ArrayList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                PrintListFromTailToHead(head-&gt;next,ArrayList);</span><br><span class="line">            &#125;</span><br><span class="line">            ArrayList.push_back(head-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">2.删除一个无头单链表的非尾节点（不能遍历链表）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">3.在无头单链表的一个节点前插入一个节点（不能遍历链表）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(ListNode* node, datatype d)</span> </span>&#123;</span><br><span class="line">        ListNode* newnode = <span class="keyword">new</span> ListNode(node-&gt;val);</span><br><span class="line"></span><br><span class="line">        newnode-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next = newnode;</span><br><span class="line">        node-&gt;val = d;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">4.单链表实现约瑟夫环(JosephCircle)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无论是用链表实现还是用数组实现都有一个共同点：要模拟整个游戏过程，不仅程序写起来比较烦，而且时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果的。我们注意到原问题仅仅是要求出最后的胜利者的序号，而不是要读者模拟整个过程。因此如果要追求效率，就要打破常规，实施一点数学策略。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了讨论方便，先把问题稍微改变一下，并不影响原意：</span></span><br><span class="line"><span class="comment">//问题描述：n个人（编号0~(n - 1))，从0开始报数，报到(m - 1)的退出，剩下的人继续从0开始报数。求胜利者的编号。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//我们知道第一个人(编号一定是m%n - 1) 出列之后，剩下的n - 1个人组成了一个新的约瑟夫环（以编号为k = m%n的人开始）:</span></span><br><span class="line"><span class="comment">//k  k + 1  k + 2  ... n - 2, n - 1, 0, 1, 2, ... k - 2并且从k开始报0。</span></span><br><span class="line"><span class="comment">//现在我们把他们的编号做一下转换：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//k--&gt; 0</span></span><br><span class="line"><span class="comment">//k + 1   --&gt; 1</span></span><br><span class="line"><span class="comment">//k + 2   --&gt; 2</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//k - 2   --&gt; n - 2</span></span><br><span class="line"><span class="comment">//k - 1   --&gt; n - 1</span></span><br><span class="line"><span class="comment">//变换后就完完全全成为了(n - 1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x'=(x+k)%n </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//如何知道(n - 1)个人报数的问题的解？对，只要知道(n - 2)个人的解就行了。(n - 2)个人的解呢？当然是先求(n - 3)的情况----这显然就是一个倒推问题！好了，思路出来了，下面写递推公式：</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//递推公式</span></span><br><span class="line"><span class="comment">//f[1] = 0;</span></span><br><span class="line"><span class="comment">//f[i] = (f[i - 1] + m) % i;  (i&gt;1)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//有了这个公式，我们要做的就是从1 - n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n] + 1. 由于是逐级递推，不需要保存每个f[i]</span></span><br><span class="line"><span class="comment">//数学方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Joseph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span> || m &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            last = (last+m)%i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (last+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表解决</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Joseph</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;* JoCyList = <span class="keyword">new</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            JoCyList-&gt;push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> it = JoCyList-&gt;begin();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(JoCyList-&gt;size() != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(count++ == m)</span><br><span class="line">            &#123;</span><br><span class="line">                it = JoCyList-&gt;erase(it);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(it == JoCyList-&gt;end())</span><br><span class="line">            &#123;</span><br><span class="line">                it = JoCyList-&gt;begin();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> JoCyList-&gt;front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用链表或数组的思想</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JosephusCycxle</span><span class="params">(pList* pplist, DataType number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pplist != <span class="literal">NULL</span>);</span><br><span class="line">assert(*pplist != <span class="literal">NULL</span>);</span><br><span class="line">pNode tail = <span class="literal">NULL</span>;</span><br><span class="line">pList cur = <span class="literal">NULL</span>;</span><br><span class="line">pList kill = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//单节点链表，直接释放</span></span><br><span class="line"><span class="keyword">if</span> ((*pplist)-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"不能构成约瑟夫环\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cur = *pplist;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;<span class="comment">//找到尾节点</span></span><br><span class="line">&#125;</span><br><span class="line">tail = cur;</span><br><span class="line">tail-&gt;next = *pplist;<span class="comment">//构成环</span></span><br><span class="line">cur = *pplist;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"清除顺序是："</span>);</span><br><span class="line"><span class="keyword">while</span> (cur != cur-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line">count = number;</span><br><span class="line"><span class="keyword">while</span> (--count)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d--&gt;"</span>, cur-&gt;data);</span><br><span class="line">kill = cur-&gt;next;</span><br><span class="line">cur-&gt;data = cur-&gt;next-&gt;data;</span><br><span class="line">cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(kill);</span><br><span class="line">kill = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n\n"</span>, cur-&gt;data);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"最后一个元素是: %d \n\n"</span>, cur-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">5.逆置/反转单链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* rh = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> rh;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//三指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//取节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode* newhead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* next = head-&gt;next;</span><br><span class="line">            head-&gt;next = newhead;</span><br><span class="line">            newhead = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//翻转节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dum = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);<span class="comment">//创建一个哑节点</span></span><br><span class="line">        dum -&gt; next = head;</span><br><span class="line">        ListNode* newhead = dum;</span><br><span class="line">        </span><br><span class="line">        ListNode* q = dum,*t = head,*p = head-&gt;next;<span class="comment">//开始逐个节点反转</span></span><br><span class="line">        <span class="keyword">while</span>(t-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            t -&gt; next = p -&gt; next;</span><br><span class="line">            p -&gt; next = q -&gt; next;</span><br><span class="line">            q -&gt; next = p;</span><br><span class="line">            </span><br><span class="line">            p = t -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">6.单链表排序（冒泡排序&amp;快速排序）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* cur = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* tail = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head != tail)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = head;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(next != tail)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((cur-&gt;val == next-&gt;val) || (cur-&gt;val &lt; next-&gt;val))</span><br><span class="line">                &#123;</span><br><span class="line">                    cur = next;</span><br><span class="line">                    next = cur-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    swap(cur-&gt;val, next-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeSort</span><span class="params">(ListNode*head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* pHead,*qHead,*pre;</span><br><span class="line">        pHead=head;</span><br><span class="line">        qHead=head;</span><br><span class="line">        pre=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(qHead!=<span class="literal">NULL</span>&amp;&amp;qHead-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           qHead=qHead-&gt;next-&gt;next;</span><br><span class="line">           pre=pHead;</span><br><span class="line">           pHead=pHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode *l,*r;</span><br><span class="line">        l=mergeSort(head);</span><br><span class="line">        r=mergeSort(pHead);</span><br><span class="line">        <span class="keyword">return</span> merge(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode *l,ListNode*r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *pRes=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode *temp=pRes;</span><br><span class="line">        <span class="keyword">while</span>(l!=<span class="literal">NULL</span>&amp;&amp;r!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l-&gt;val&lt;=r-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;next=l;</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">                l=l-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;next=r;</span><br><span class="line">                temp=temp-&gt;next;</span><br><span class="line">                r=r-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l!=<span class="literal">NULL</span>)</span><br><span class="line">            temp-&gt;next=l;</span><br><span class="line">        <span class="keyword">if</span>(r!=<span class="literal">NULL</span>)</span><br><span class="line">            temp-&gt;next=r;</span><br><span class="line">        temp=pRes-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> pRes;</span><br><span class="line">        <span class="keyword">return</span> temp;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t=*a;</span><br><span class="line">        *a=*b;</span><br><span class="line">        *b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode *<span class="title">partion</span><span class="params">(ListNode *pBegin,ListNode *pEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pBegin==pEnd||pBegin-&gt;next==pEnd)    <span class="keyword">return</span> pBegin;</span><br><span class="line">        <span class="keyword">int</span> key=pBegin-&gt;val;    <span class="comment">//选择pBegin作为基准元素</span></span><br><span class="line">        ListNode *p=pBegin,*q=pBegin;</span><br><span class="line">        <span class="keyword">while</span>(q!=pEnd)&#123;   <span class="comment">//从pBegin开始向后进行一次遍历</span></span><br><span class="line">            <span class="keyword">if</span>(q-&gt;val&lt;key)&#123;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">                swap(&amp;p-&gt;val,&amp;q-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;p-&gt;val,&amp;pBegin-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(ListNode *pBegin,ListNode *pEnd)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pBegin==pEnd||pBegin-&gt;next==pEnd)    <span class="keyword">return</span>;</span><br><span class="line">        ListNode *mid=partion(pBegin,pEnd);</span><br><span class="line">        quick_sort(pBegin,mid);</span><br><span class="line">        quick_sort(mid-&gt;next,pEnd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)    <span class="keyword">return</span> head;</span><br><span class="line">        quick_sort(head,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">7.合并两个有序链表,合并后依然有序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* newlist;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1 == l2 || l2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                newlist = l1;</span><br><span class="line">                newlist-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                newlist = l2;</span><br><span class="line">                newlist-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newlist;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* newlist = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* tail = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1 == l2 || l2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                newlist = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                newlist = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//寻找较小值插入</span></span><br><span class="line">            tail = newlist;</span><br><span class="line">            <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    tail-&gt;next = l1;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    tail-&gt;next = l2;</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//补上剩余</span></span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tail-&gt;next = l1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> newlist;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">8.查找单链表的中间节点，要求只能遍历一次链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//快慢指针法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">9.查找单链表的倒数第k个节点，要求只能遍历一次链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = pListHead;</span><br><span class="line">        ListNode* slow = pListHead; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pListHead == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> steps = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;fast != <span class="literal">nullptr</span>;steps++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(steps &gt;k)</span><br><span class="line">                slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> steps &gt; k? slow:<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">10.删除链表的倒数第K个结点<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!head-&gt;next) </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode *pre = head, *cur = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!cur) </span><br><span class="line">            <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (cur-&gt;next) &#123;</span><br><span class="line">           cur = cur-&gt;next;            </span><br><span class="line">           pre = pre-&gt;next;</span><br><span class="line">         &#125;  </span><br><span class="line">        </span><br><span class="line">        pre-&gt;next = pre-&gt;next-&gt;next;        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">11.判断单链表是否带环？若带环，求环的长度？求环的入口点？并计算每个算法的时间复杂度&amp;空间复杂度<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//利用set的特性求入口点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;ListNode*&gt; s;</span><br><span class="line">        ListNode* node = pHead;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.insert(node).second)</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//求入口点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否带环</span></span><br><span class="line">        ListNode *fast=pHead,*slow=pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="comment">//带环，返回交点</span></span><br><span class="line">            <span class="keyword">if</span>(fast==slow)</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast=pHead;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//获取入口点，求得环的长度</span></span><br><span class="line"><span class="comment">//①判断是否带环</span></span><br><span class="line"><span class="function">ListNode *<span class="title">IsCirle</span><span class="params">(ListNode *pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pHead || <span class="literal">NULL</span> == pHead-&gt;_next)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *fast = pHead;</span><br><span class="line">    ListNode *slow = pHead;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;_next)</span><br><span class="line">    &#123;</span><br><span class="line">        fast = fast-&gt;_next-&gt;_next;</span><br><span class="line">        slow = slow-&gt;_next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> fast;<span class="comment">//返回相遇点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取环的入口点</span></span><br><span class="line"><span class="function">ListNode *<span class="title">GetEnterNode</span><span class="params">(ListNode *pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *pMeet = IsCirle(pHead);</span><br><span class="line">    <span class="keyword">if</span> (pMeet)<span class="comment">//带环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (pMeet == pHead)</span><br><span class="line">       &#123;</span><br><span class="line">            pHead = pHead-&gt;_next;</span><br><span class="line">           pMeet = pMeet-&gt;_next;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pMeet;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//环的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCirLen</span><span class="params">(ListNode *pHead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *pMeet = IsCirle(pHead);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pMeet)<span class="comment">//带环</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode *pNext = pMeet;</span><br><span class="line">        <span class="keyword">while</span> (pNext-&gt;_next != pNext)</span><br><span class="line">        &#123;</span><br><span class="line">            count++;</span><br><span class="line">            pNext = pNext-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;<span class="comment">//算上最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">12.判断两个链表是否相交，若相交，求交点。（假设链表不带环）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!headA || !headB) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">    ListNode *longNode = headA, *shortNode = headB;</span><br><span class="line">    <span class="keyword">while</span> (longNode) &#123;</span><br><span class="line">      ++lenA;</span><br><span class="line">      longNode = longNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (shortNode) &#123;</span><br><span class="line">      ++lenB;</span><br><span class="line">      shortNode = shortNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> diff = lenA - lenB;</span><br><span class="line">    longNode = headA;</span><br><span class="line">    shortNode = headB;</span><br><span class="line">    <span class="keyword">if</span> (lenA &lt; lenB) &#123;</span><br><span class="line">      diff = -diff;</span><br><span class="line">      longNode = headB;</span><br><span class="line">      shortNode = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; ++i) &#123;</span><br><span class="line">      longNode = longNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (longNode &amp;&amp; shortNode &amp;&amp; longNode != shortNode) &#123;</span><br><span class="line">      longNode = longNode-&gt;next;</span><br><span class="line">      shortNode = shortNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> longNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *p = headA, *q = headB;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; q) &#123;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">      p = p-&gt;next;</span><br><span class="line">      headA = headA-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q) &#123;</span><br><span class="line">      q = q-&gt;next;</span><br><span class="line">      headB = headB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headA &amp;&amp; headB &amp;&amp; headA != headB) &#123;</span><br><span class="line">      headA = headA-&gt;next;</span><br><span class="line">      headB = headB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> headA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">13.判断两个链表是否相交，若相交，求交点。（假设链表可能带环）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断一个链表是否带环</span></span><br><span class="line"><span class="comment">//思路：快慢指针,返回相遇点</span></span><br><span class="line"><span class="function">Node* <span class="title">IsCircle</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* pSlow = head;</span><br><span class="line">    Node* pFast = head;</span><br><span class="line">    <span class="comment">//快指针一次走两步，慢指针一次走一步</span></span><br><span class="line">    <span class="keyword">while</span> (pFast &amp;&amp; pFast-&gt;_next)</span><br><span class="line">    &#123;</span><br><span class="line">        pFast = pFast-&gt;_next-&gt;_next;</span><br><span class="line">        pSlow = pSlow-&gt;_next;</span><br><span class="line">        <span class="keyword">if</span> (pFast == pSlow)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pFast &amp;&amp; pFast-&gt;_next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> pFast;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">GetEntryNode</span><span class="params">(Node* head, Node* meetNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(head &amp;&amp; meetNode);</span><br><span class="line">    Node* p1 = head;</span><br><span class="line">    Node* p2 = meetNode;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2)</span><br><span class="line">    &#123;</span><br><span class="line">        p1 = p1-&gt;_next;</span><br><span class="line">        p2 = p2-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否相交，判断尾节点</span></span><br><span class="line"><span class="comment">//若相交，则返回交点</span></span><br><span class="line"><span class="function">Node* <span class="title">IsMeet</span><span class="params">(Node* head1,Node* head2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        assert(head1 &amp;&amp; head2);</span><br><span class="line">        Node* cur1 = head1;</span><br><span class="line">        <span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">        Node* cur2 = head2;</span><br><span class="line">        <span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur1-&gt;_next)</span><br><span class="line">        &#123;</span><br><span class="line">            ++count1;</span><br><span class="line">            cur1 = cur1-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cur2-&gt;_next)</span><br><span class="line">        &#123;</span><br><span class="line">            count2++;</span><br><span class="line">            cur2 = cur2-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur1 != cur2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//说明没有交点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> D_val = count2 - count1;</span><br><span class="line">        <span class="keyword">if</span> (D_val &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            D_val = -D_val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        cur1 = head1;</span><br><span class="line">        cur2 = head2;</span><br><span class="line">        <span class="keyword">if</span> (count1 &lt; count2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让head2链表先走D_val长度</span></span><br><span class="line">            <span class="keyword">while</span> (cur2 &amp;&amp; D_val--)</span><br><span class="line">            &#123;</span><br><span class="line">                cur2 = cur2-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cur2 &amp;&amp; cur1 != cur2)</span><br><span class="line">            &#123;</span><br><span class="line">                cur1 = cur1-&gt;_next;</span><br><span class="line">                cur2 = cur2-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == cur2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//让head1链表先走D_val长度</span></span><br><span class="line">            <span class="keyword">while</span> (cur1 &amp;&amp; D_val--)</span><br><span class="line">            &#123;</span><br><span class="line">                cur1 = cur1-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cur1 &amp;&amp; cur1 != cur2)</span><br><span class="line">            &#123;</span><br><span class="line">                cur1 = cur1-&gt;_next;</span><br><span class="line">                cur2 = cur2-&gt;_next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur1 == cur2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">IsHaveCrossNode</span><span class="params">(Node* head1,Node* head2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        assert(head1);</span><br><span class="line">        assert(head2);</span><br><span class="line">        Node* meetNode1 = IsCircle(head1);</span><br><span class="line">        Node* meetNode2 = IsCircle(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (meetNode1 == <span class="literal">NULL</span> || meetNode2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明两个链表都带环</span></span><br><span class="line">        Node* cur1 = meetNode1-&gt;_next;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != meetNode1 &amp;&amp; cur1 != meetNode2)</span><br><span class="line">        &#123;</span><br><span class="line">            cur1 = cur1-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur1 != meetNode2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node* entry1 = GetEntryNode(head1, meetNode1);</span><br><span class="line">        Node* entry2 = GetEntryNode(head2, meetNode2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (entry1 == entry2)</span><br><span class="line">        &#123;</span><br><span class="line">            entry1-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">            entry2-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">            Node* meet = IsMeet(head1, head2);</span><br><span class="line">            <span class="keyword">return</span> meet;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> entry1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">14.复杂链表的复制。一个链表的每个节点，有一个指向next指针指向下一个节点，还有一个random指针指向这个链表中的一个随机节点或者NULL，现在要求实现复制这个链表，返回复制后的新链表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pHead) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        RandomListNode* currNode ;</span><br><span class="line">        currNode  = pHead;</span><br><span class="line">        <span class="comment">//插入新节点</span></span><br><span class="line">        <span class="keyword">while</span>(currNode )&#123;</span><br><span class="line">            RandomListNode *node = <span class="keyword">new</span> RandomListNode(currNode-&gt;label);</span><br><span class="line">            node-&gt;next = currNode-&gt;next;</span><br><span class="line">            currNode-&gt;next = node;</span><br><span class="line">            currNode = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//确定新插入节点的random</span></span><br><span class="line">        currNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currNode)&#123;</span><br><span class="line">          RandomListNode *node = currNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(currNode-&gt;random)&#123;</span><br><span class="line">                 node-&gt;random = currNode-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">          currNode = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//分拆</span></span><br><span class="line">        RandomListNode *pCloneHead = pHead-&gt;next;</span><br><span class="line">        RandomListNode *tmp;</span><br><span class="line">        currNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(currNode-&gt;next)&#123;<span class="comment">//一个一个的接********</span></span><br><span class="line">            tmp = currNode-&gt;next;</span><br><span class="line">            currNode-&gt;next =tmp-&gt;next;</span><br><span class="line">            currNode = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">15.求两个已排序单链表中相同的数据。void UnionSet(Node<em> l1,<br>Node</em> l2);<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnionSet</span><span class="params">(Node* l1, Node* l2)</span></span>&#123;</span><br><span class="line">    assert(l1 &amp;&amp; l2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;_data &lt; l2-&gt;_data)&#123;</span><br><span class="line">            l1 = l1-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l1-&gt;_data &gt; l2-&gt;_data)&#123;</span><br><span class="line">            l2 = l2-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,l1-&gt;_data);</span><br><span class="line">            l1 = l1-&gt;_next;</span><br><span class="line">            l2 = l2-&gt;_next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">16.比较顺序表和链表的优缺点，他们分别在什么场景下使用它？</font></p><ul><li>顺序表支持随机访问，单链表不支持随机访问</li><li>顺序表插入/删除数据效率很低，时间复杂度为O(N)（除尾插尾删），单链表插入/删除效率更高，时间复杂度为O(1)</li><li>顺序表CPU缓存效率更高，单链表CPU高速缓存效率低</li><li>所以顺序表一般用于查找遍历操作比较频繁的情况下使用，链表则针对于数据删除修改操作比较多的情况下使用<h3 id="二、栈和队列"><a href="#二、栈和队列" class="headerlink" title="二、栈和队列"></a><font color="black" size="4" face="微软雅黑">二、栈和队列</font></h3>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">1.实现一个栈，要求实现Push(入栈)、Pop(出栈)、、栈顶元素、Min(返回最小值)的时间复杂度为O(1)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        ordin_stack.push(value);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(min_stack.empty() || value &lt;= min_stack.top())</span><br><span class="line">        &#123;</span><br><span class="line">            min_stack.push(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ordin_stack.top() == min_stack.top())</span><br><span class="line">        &#123;</span><br><span class="line">            ordin_stack.pop();</span><br><span class="line">            min_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ordin_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ordin_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ordin_stack;</span><br><span class="line">    <span class="comment">//辅助栈</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; min_stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></li></ul><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">2.使用两个栈实现一个队列<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.push(stack1.top());</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stack2.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack2.empty() &amp;&amp; stack1.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">3.使用两个队列实现一个栈<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyStack() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        que1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(que1.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            que2.push(que1.front());</span><br><span class="line">            que1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> front = que1.front();</span><br><span class="line">        que1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!que2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            que1.push(que2.front());</span><br><span class="line">            que2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que1.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> que1.empty();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">4.元素出栈、入栈顺序的合法性。如入栈的序列(1,2,3,4,5)，出栈序列为(4,5,3,2,1)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> outdex = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index &lt; pushV.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.empty() || st.top() != popV[outdex])</span><br><span class="line">            &#123;</span><br><span class="line">                st.push(pushV[index]);</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st.pop();</span><br><span class="line">                ++outdex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st.top() != popV[outdex++])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">5.一个数组实现两个栈（共享栈）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ShareStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Datatype a[N];</span><br><span class="line"><span class="keyword">int</span> top1;</span><br><span class="line"><span class="keyword">int</span> top2;</span><br><span class="line">&#125;SharkStack, *pShareStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShareStackInit</span><span class="params">(pShareStack pss)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pss);</span><br><span class="line">pss-&gt;top1 = <span class="number">-2</span>;<span class="comment">//top1从0开始入数据</span></span><br><span class="line">pss-&gt;top2 = <span class="number">-1</span>;<span class="comment">//top2从1开始入数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShareStackPush</span><span class="params">(pShareStack pss, Datatype x, <span class="keyword">int</span> which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (which == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pss-&gt;top1 &gt;= N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stack Overflow\n\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pss-&gt;top1 += <span class="number">2</span>;</span><br><span class="line">pss-&gt;a[pss-&gt;top1] = x;<span class="comment">//a[0] a[2] ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (which == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pss-&gt;top2 &gt;= N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stack Overflow\n\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pss-&gt;top2 += <span class="number">2</span>;</span><br><span class="line">pss-&gt;a[pss-&gt;top2] = x; <span class="comment">//a[1] a[3]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">assert(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShareStackPop</span><span class="params">(pShareStack pss, <span class="keyword">int</span> which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (which == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pss-&gt;top1 &lt; <span class="number">-2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stack NULL\n\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pss-&gt;top1 -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pss-&gt;top2 &lt; <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stack NULL\n\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">pss-&gt;top2 -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Datatype <span class="title">ShareStackTop</span><span class="params">(pShareStack pss, <span class="keyword">int</span> which)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(pss);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (which == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pss-&gt;a[pss-&gt;top1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pss-&gt;a[pss-&gt;top2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SharkStack pss;</span><br><span class="line">ShareStackInit(&amp;pss);</span><br><span class="line">ShareStackPush(&amp;pss, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">ShareStackPush(&amp;pss, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">ShareStackPush(&amp;pss, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">ShareStackPush(&amp;pss, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">ShareStackPush(&amp;pss, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">ShareStackPush(&amp;pss, <span class="number">6</span>, <span class="number">2</span>);</span><br><span class="line">ShareStackPush(&amp;pss, <span class="number">7</span>, <span class="number">1</span>);</span><br><span class="line">ShareStackPush(&amp;pss, <span class="number">8</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈一："</span>);</span><br><span class="line"><span class="keyword">while</span> (pss.top1 &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d "</span>, ShareStackTop(&amp;pss, <span class="number">1</span>));</span><br><span class="line">ShareStackPop(&amp;pss, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"栈二："</span>);</span><br><span class="line"><span class="keyword">while</span> (pss.top2 &gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d "</span>, ShareStackTop(&amp;pss, <span class="number">2</span>));</span><br><span class="line">ShareStackPop(&amp;pss, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;使用C++语言解决常见的数据结构面试题&lt;br&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="链表和顺序表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8%E5%92%8C%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
    
      <category term="栈和队列" scheme="http://yoursite.com/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Linux 进程相关（二）</title>
    <link href="http://yoursite.com/2018/11/10/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/10/Linux进程相关（二）/</id>
    <published>2018-11-10T04:10:21.000Z</published>
    <updated>2019-03-26T13:07:30.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、模拟实现僵尸进程-孤儿进程"><a href="#一、模拟实现僵尸进程-孤儿进程" class="headerlink" title="一、模拟实现僵尸进程, 孤儿进程"></a><font color="black" size="4" face="微软雅黑">一、模拟实现僵尸进程, 孤儿进程</font></h3><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">1.僵尸进程：僵尸进程是一个比较特殊的状态，当进程退出并且父进程没有读取到子进程退出的返回代码时就会产生僵尸进程，而且僵尸进程会以终止状态保持在进程表中，并且会一直等待父进程读取退出户状态代码，那么当子进程退出，父进程在运行，但父进程没有读取到子进程状态，那么子进程就进入到僵尸状态。<br><a id="more"></a><br>&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(1).实现一个僵尸进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                                                                   </span></span></span><br><span class="line">  <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                                                                  </span></span></span><br><span class="line">  <span class="number">3</span>                                                                                      </span><br><span class="line">  <span class="number">4</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                                                           </span></span><br><span class="line"><span class="function">  5 </span>&#123;                                                                                    </span><br><span class="line">  <span class="number">6</span>   <span class="keyword">pid_t</span> id = fork();                                                                 </span><br><span class="line">  <span class="number">7</span>   <span class="keyword">if</span>(id &lt; <span class="number">0</span>)                                                                         </span><br><span class="line">  <span class="number">8</span>   &#123;                                                                                  </span><br><span class="line">  <span class="number">9</span>     perror(<span class="string">"fork"</span>);                                                                  </span><br><span class="line"> <span class="number">10</span>     <span class="keyword">return</span> <span class="number">1</span>;                                                                        </span><br><span class="line"> <span class="number">11</span>   &#125;                                                                                  </span><br><span class="line"> <span class="number">12</span>   <span class="keyword">else</span> <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;                                                                   </span><br><span class="line"> <span class="number">13</span>     <span class="built_in">printf</span>(<span class="string">"parent [%d] is sleeping...\n"</span>, getpid());                                </span><br><span class="line"> <span class="number">14</span>     sleep(<span class="number">30</span>);                                                                       </span><br><span class="line"> <span class="number">15</span>   &#125;                                                                                  </span><br><span class="line"> <span class="number">16</span>   <span class="keyword">else</span>&#123;                                                                              </span><br><span class="line"> <span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">"child [%d] is begin...\n"</span>, getpid());                                    </span><br><span class="line"> <span class="number">18</span>     sleep(<span class="number">5</span>);                                                                        </span><br><span class="line"> <span class="number">19</span>     <span class="built_in">exit</span>(EXIT_SUCCESS);                                                              </span><br><span class="line"> <span class="number">20</span>   &#125;                                                                                  </span><br><span class="line"> <span class="number">21</span>   <span class="keyword">return</span> <span class="number">0</span>;                                                                          </span><br><span class="line"> <span class="number">22</span> &#125;                                                                                    </span><br><span class="line">~</span><br></pre></td></tr></table></figure></font></font></p><blockquote><p>首先在另一个终端下执行<code>while :; do ps aux | grep static | grep -v grep; sleep 1; echo &quot;#############&quot;; done</code>启动监控<br><img src="/img/TIM截图20181110121318.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>然后执行<code>./static</code><br><img src="/img/TIM截图20181110121411.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>之后就可以看到子进程变成了僵尸进程<br><img src="/img/TIM截图20181110121447.png" alt="在这里插入图片描述"></p></blockquote><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">2.孤儿进程:相比于僵尸进程，如果父进程提前退出，那么子进程后退出， 这时子进程就称为“孤儿进程”，当然了OS不可能放任孤儿进程不管，孤儿进程被1号init进程领养，也由init进程回收。<br>&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(1).实现孤儿进程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                                                                     </span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;                                                                    </span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;                                                                    </span></span></span><br><span class="line"> <span class="number">4</span>                                                                                        </span><br><span class="line"> <span class="number">5</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>                                                                             </span></span><br><span class="line"><span class="function"> 6 </span>&#123;                                                                                      </span><br><span class="line"> <span class="number">7</span>   <span class="keyword">pid_t</span> id = fork();                                                                   </span><br><span class="line"> <span class="number">8</span>   <span class="keyword">if</span>(id &lt; <span class="number">0</span>)                                                                           </span><br><span class="line"> <span class="number">9</span>   &#123;                                                                                    </span><br><span class="line"><span class="number">10</span>     perror(<span class="string">"fork"</span>);                                                                    </span><br><span class="line"><span class="number">11</span>     <span class="keyword">return</span> <span class="number">1</span>;                                                                          </span><br><span class="line"><span class="number">12</span>   &#125;                                                                                    </span><br><span class="line"><span class="number">13</span>   <span class="keyword">else</span> <span class="keyword">if</span>(id == <span class="number">0</span>)&#123;<span class="comment">//child                                                             </span></span><br><span class="line"><span class="number">14</span>     <span class="built_in">printf</span>(<span class="string">"I am child, pid is [%d]\n"</span>, getpid());                                     </span><br><span class="line"><span class="number">15</span>     sleep(<span class="number">10</span>);                                                                         </span><br><span class="line"><span class="number">16</span>   &#125;<span class="keyword">else</span>&#123;                                                                               </span><br><span class="line"><span class="number">17</span>     <span class="built_in">printf</span>(<span class="string">"I am parent, pid is [%d]\n"</span>, getpid());                                    </span><br><span class="line"><span class="number">18</span>     sleep(<span class="number">3</span>);                                                                          </span><br><span class="line"><span class="number">19</span>     <span class="built_in">exit</span>(<span class="number">0</span>);                                                                           </span><br><span class="line"><span class="number">20</span>   &#125;                                                                                    </span><br><span class="line"><span class="number">21</span>   <span class="keyword">return</span> <span class="number">0</span>;                                                                            </span><br><span class="line"><span class="number">22</span> &#125;</span><br></pre></td></tr></table></figure></font></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> orphan_process:Orphan_process.c                                                                                                                                                            </span><br><span class="line"><span class="number">2</span>   gcc -o $@ $^                                                                                                                                                                             </span><br><span class="line"><span class="number">3</span>                                                                                                                                                                                            </span><br><span class="line"><span class="number">4</span> .PHONY:clean                                                                                                                                                                               </span><br><span class="line"><span class="number">5</span> clean:                                                                                                                                                                                     </span><br><span class="line"><span class="number">6</span>   rm -rf orphan_process</span><br></pre></td></tr></table></figure><blockquote><p>首先在另一个终端下执行<code>while :; do ps aux | grep orphan_process | grep -v grep; sleep 1; echo &quot;#############&quot;; done</code>启动监控<br><img src="/img/TIM截图20181110121512.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>执行<code>./orphan_process</code><br><img src="/img/TIM截图20181110121538.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>之后就可以看到子进程被回收<br><img src="/img/TIM截图20181110121620.png" alt="在这里插入图片描述"></p></blockquote><h3 id="二、setenv-export等环境变量相关的函数和命令"><a href="#二、setenv-export等环境变量相关的函数和命令" class="headerlink" title="二、setenv, export等环境变量相关的函数和命令"></a><font color="black" size="4" face="微软雅黑">二、setenv, export等环境变量相关的函数和命令</font></h3><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">环境变量里包含了程序运行时的完整路径，以便于我们在其他地方运行某个程序时，OS会在环境变量里搜索该程序的路径，然后运行。</font></p><p>&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">1.Linux中的环境变量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PATH     <span class="comment">//这个变量包含了一系列由冒号分隔开的目录，系统就从这些目录里寻找可执行文件。如果你输入的可执行文件（例如ls、rc-update或者emerge） 不在这些目录中，系统就无法执行它（除非你输入这个命令的完整路径，如/bin/ls）。   </span></span><br><span class="line">ROOTPATH <span class="comment">//这个变量的功能和PATH相同，但它只罗列出超级用户（root）键入命令时所需检查的目录。   </span></span><br><span class="line">LDPATH   <span class="comment">//这个变量包含了一系列用冒号隔开的目录，动态链接器将在这些目录里查找库文件。  </span></span><br><span class="line">MANPATH  <span class="comment">//这个变量包含了一系列用冒号隔开的目录，命令man会在这些目录里搜索man页面。   </span></span><br><span class="line">INFODIR  <span class="comment">//这个变量包含了一系列用冒号隔开的目录，命令info将在这些目录里搜索info页面。   </span></span><br><span class="line">PAGER    <span class="comment">//这个变量包含了浏览文件内容的程序的路径（例如less或者more）。   </span></span><br><span class="line">EDITOR   <span class="comment">//这个变量包含了修改文件内容的程序（文件编辑器）的路径（比如nano或者vi）。   </span></span><br><span class="line">KDEDIRS  <span class="comment">//这个变量包含了一系列用冒号隔开的目录，里面放的是KDE相关的资料。  </span></span><br><span class="line">CONFIG_PROTECT      <span class="comment">//这个变量包含了一系列用空格隔开的目录，它们在更新的时候会被Portage保护起来。  </span></span><br><span class="line">CONFIG_PROTECT_MASK <span class="comment">//这个变量包含了一系列用空格隔开的目录，它们在更新的时候不会被Portage保护起来。</span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">2.环境变量命令<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>echo   <span class="comment">//显示某个环境变量值 echo $PATH  </span></span><br><span class="line"><span class="number">2.</span><span class="keyword">export</span> <span class="comment">//设置一个新的环境变量 export HELLO="hello" (可以无引号)  </span></span><br><span class="line"><span class="number">3.</span>env    <span class="comment">//显示所有环境变量  </span></span><br><span class="line"><span class="number">4.</span><span class="built_in">set</span>    <span class="comment">//显示本地定义的shell变量  </span></span><br><span class="line"><span class="number">5.u</span>nset  <span class="comment">//清除环境变量 unset HELLO  </span></span><br><span class="line"><span class="number">6.</span>readonly <span class="comment">//设置只读环境变量 readonly HELLO</span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">3.C语言中的<code>getenv(); setenv(); unsetenv();</code>函数可以设置或访问某一个环境变量。</font></p><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(1).getenv()函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">       <span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">char</span> *<span class="title">secure_getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span><br><span class="line">      secure_getenv(): _GNU_SOURCE</span><br></pre></td></tr></table></figure></font></p><blockquote><p><font color="blue" size="4" face="微软雅黑">根据getenv()函数的定义可以看出，一共有两个getenv()函数,其中<code>char *getenv(const char *name);</code>是如果所查找的环境变量不存在就返回一个NULL指针，存在就返回其地址，由于其返回值存放在一个数组里，所以不用担心再次查询会覆盖之前的值，而<code>char *secure_getenv(const char *name);</code>也是同样的返回值，但其应用于线程安全。</font></p></blockquote><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(2).setenv()函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line">  Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span><br><span class="line">      setenv(), unsetenv():</span><br><span class="line">          _BSD_SOURCE || _POSIX_C_SOURCE &gt;= <span class="number">200112L</span> || _XOPEN_SOURCE &gt;= <span class="number">600</span></span><br><span class="line">  DESCRIPTION</span><br><span class="line">           The  setenv()  function  adds the variable name to the environment with</span><br><span class="line">           the value value, <span class="keyword">if</span> name does <span class="keyword">not</span> already exist.  If name does exist in</span><br><span class="line">           the  environment,  then  its  value is changed to value <span class="keyword">if</span> overwrite is</span><br><span class="line">           nonzero; <span class="keyword">if</span> overwrite is zero, then the value of name is  <span class="keyword">not</span>  changed.</span><br><span class="line">           This  function makes copies of the strings pointed to by name <span class="keyword">and</span> value</span><br><span class="line">           (by contrast with putenv(<span class="number">3</span>)).</span><br></pre></td></tr></table></figure></font></p><blockquote><p><font color="blue" size="4" face="微软雅黑">setenv()函数，顾名思义可以设置环境变量，当环境变量中没有要添加的<code>name</code>时就添加该变量名，若存在就看<code>overwrite</code>是否非零，若为零就不覆盖，若非零就覆盖。成功时返回0，错误时返回-1，并指出原因。</font></p></blockquote><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(3).unsetenv()函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">      <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">  Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</span><br><span class="line">      setenv(), unsetenv():</span><br><span class="line">          _BSD_SOURCE || _POSIX_C_SOURCE &gt;= <span class="number">200112L</span> || _XOPEN_SOURCE &gt;= <span class="number">600</span></span><br><span class="line"></span><br><span class="line">   The unsetenv() function deletes the variable name from the environment.</span><br><span class="line">   If  name does <span class="keyword">not</span> exist in the environment, then the function succeeds,</span><br><span class="line">   <span class="keyword">and</span> the environment is unchanged.</span><br></pre></td></tr></table></figure></font></p><blockquote><p>&emsp;&emsp;&emsp;<font color="blue" size="4" face="微软雅黑">unsetenv()函数就是删除某个环境变量，若某个环境变量不存就返回成功，环境变量不作改变，返回值和setenv()函数一致。</font></p></blockquote><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(4).指针变量<code>environ</code>指向的是一个包含所有环境变量的列表.使用以下代码可以打印出所有环境变量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>**environ;                                                     </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span>                                                               </span></span><br><span class="line"><span class="function"></span>&#123;                                                                         </span><br><span class="line">  <span class="keyword">char</span>**path;                                                             </span><br><span class="line">  <span class="keyword">for</span> (path =environ;*path !=<span class="literal">NULL</span>;++path)                               </span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"%s \n "</span>,*path);                                          </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">可以看到以下结果</span><br><span class="line">SSH_AUTH_SOCK=/run/user/<span class="number">1000</span>/keyring/ssh</span><br><span class="line">SESSION_MANAGER=local/unix:@/tmp/.ICE-unix/<span class="number">1837</span>,unix/unix:/tmp/.ICE-unix/<span class="number">1837</span></span><br><span class="line">USERNAME=kui</span><br><span class="line">GNOME_SHELL_SESSION_MODE=classic</span><br><span class="line">PATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/kui/.local/bin:/home/kui/bin</span><br><span class="line">MAIL=/var/spool/mail/kui</span><br><span class="line">DESKTOP_SESSION=gnome-classi</span><br><span class="line">QT_IM_MODULE=xim</span><br><span class="line">QT_QPA_PLATFORMTHEME=qgnomeplatform</span><br><span class="line">XDG_SESSION_TYPE=x11</span><br><span class="line">PWD=/home/kui</span><br><span class="line">XMODIFIERS=@im=ibus</span><br><span class="line">LANG=zh_CN.UTF<span class="number">-8</span></span><br><span class="line">GDM_LANG=zh_CN.UTF<span class="number">-8</span></span><br><span class="line">GDMSESSION=gnome-classic</span><br><span class="line">HISTCONTROL=ignoredups</span><br><span class="line">XDG_SEAT=seat0</span><br><span class="line">HOME=/home/kui</span><br><span class="line">SHLVL=<span class="number">2</span></span><br><span class="line">GNOME_DESKTOP_SESSION_ID=<span class="keyword">this</span>-is-deprecated</span><br><span class="line">XDG_SESSION_DESKTOP=gnome-classic</span><br><span class="line">LOGNAME=kui</span><br><span class="line">XDG_DATA_DIRS=/home/kui/.local/share/flatpak/exports/share/:/var/lib/flatpak/exports/share/:/usr/local/share/:/usr/share/</span><br><span class="line">DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus<span class="number">-8</span>PBK3gNeEw,guid=e9d3af1ed81eabd51e3431735bef8722</span><br><span class="line">LESSOPEN=||/usr/bin/lesspipe.sh %s</span><br><span class="line">WINDOWPATH=<span class="number">1</span></span><br><span class="line">XDG_RUNTIME_DIR=/run/user/<span class="number">1000</span></span><br><span class="line">DISPLAY=:<span class="number">0</span></span><br><span class="line">XDG_CURRENT_DESKTOP=GNOME-Classic:GNOME</span><br><span class="line">COLORTERM=truecolor</span><br><span class="line">XAUTHORITY=/run/gdm/auth-<span class="keyword">for</span>-kui-KUriSB/database_=./test</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、模拟实现僵尸进程-孤儿进程&quot;&gt;&lt;a href=&quot;#一、模拟实现僵尸进程-孤儿进程&quot; class=&quot;headerlink&quot; title=&quot;一、模拟实现僵尸进程, 孤儿进程&quot;&gt;&lt;/a&gt;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;一、模拟实现僵尸进程, 孤儿进程&lt;/font&gt;&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;1.僵尸进程：僵尸进程是一个比较特殊的状态，当进程退出并且父进程没有读取到子进程退出的返回代码时就会产生僵尸进程，而且僵尸进程会以终止状态保持在进程表中，并且会一直等待父进程读取退出户状态代码，那么当子进程退出，父进程在运行，但父进程没有读取到子进程状态，那么子进程就进入到僵尸状态。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="僵尸进程" scheme="http://yoursite.com/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="孤儿进程" scheme="http://yoursite.com/tags/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>centos7下提交GitHub代码</title>
    <link href="http://yoursite.com/2018/11/08/centos7%E4%B8%8B%E6%8F%90%E4%BA%A4GitHub%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2018/11/08/centos7下提交GitHub代码/</id>
    <published>2018-11-08T08:39:52.000Z</published>
    <updated>2018-11-23T09:50:32.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、建立GitHub远程仓库"><a href="#一、建立GitHub远程仓库" class="headerlink" title="一、建立GitHub远程仓库"></a>一、建立GitHub远程仓库</h3><blockquote><p>在Github官网上建立一个仓库</p></blockquote><a id="more"></a><h3 id="二、安装Git"><a href="#二、安装Git" class="headerlink" title="二、安装Git"></a>二、安装Git</h3><p>在终端运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure></p><p>之后可以查看其版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></p><h3 id="三、克隆远程仓库到本地"><a href="#三、克隆远程仓库到本地" class="headerlink" title="三、克隆远程仓库到本地"></a>三、克隆远程仓库到本地</h3><blockquote><p>新建仓库之后点开可以看见http网址，直接复制即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone  https://github.com/KUI-SI-MING/Linux.git/</span><br></pre></td></tr></table></figure><p>克隆成功后可以看到<br><img src="/img/TIM截图20181108164210.png" alt="在这里插入图片描述"></p><h3 id="四、添加到索引库"><a href="#四、添加到索引库" class="headerlink" title="四、添加到索引库"></a>四、添加到索引库</h3><blockquote><p>将需要上传的文件拷贝到仓库目录下后</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add path  //path可以是文件也可以是目录</span><br></pre></td></tr></table></figure><h3 id="五、将索引库提交到本地版本库"><a href="#五、将索引库提交到本地版本库" class="headerlink" title="五、将索引库提交到本地版本库"></a>五、将索引库提交到本地版本库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;描述信息&quot;</span><br></pre></td></tr></table></figure><p>提交成功后可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">[kui@localhost Kui]$ git commit -m &quot;First&quot;</span><br><span class="line">[master（根提交） 4c9ee01] First</span><br><span class="line"> Committer: kui_nian &lt;kui@localhost.localdomain&gt;</span><br><span class="line">您的姓名和邮件地址基于登录名和主机名进行了自动设置。请检查它们正确</span><br><span class="line">与否。您可以通过下面的命令对其进行明确地设置以免再出现本提示信息：</span><br><span class="line"></span><br><span class="line">    git config --global user.name &quot;Your Name&quot;</span><br><span class="line">    git config --global user.email you@example.com</span><br><span class="line"></span><br><span class="line">设置完毕后，您可以用下面的命令来修正本次提交所使用的用户身份：</span><br><span class="line"></span><br><span class="line">    git commit --amend --reset-author</span><br><span class="line"></span><br><span class="line"> 3 files changed, 59 insertions(+)</span><br><span class="line"> create mode 100755 myshell/Makefile</span><br><span class="line"> create mode 100755 myshell/myshell</span><br><span class="line"> create mode 100755 myshell/myshell.c</span><br><span class="line">[kui@localhost Kui]$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">[kui@localhost Kui]$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">[kui@localhost Kui]$ git config --global user.name &quot;kui-si-ming&quot;</span><br><span class="line">[kui@localhost Kui]$ git config --global user.email kuisi5495@163.com</span><br><span class="line">[kui@localhost Kui]$ git commit --amend --reset-author</span><br><span class="line">Error detected while processing /home/kui/.vimrc:</span><br><span class="line">line    5:</span><br><span class="line">E492: Not an editor command: Plug &apos;Valloric/YouCompleteMe&apos;</span><br><span class="line">line    6:</span><br><span class="line">E492: Not an editor command: Plug &apos;bling/vim-airline&apos;</span><br><span class="line">line    7:</span><br><span class="line">E492: Not an editor command: Plug &apos;vim-airline/vim-airline-themes&apos;</span><br><span class="line">line    8:</span><br><span class="line">E492: Not an editor command: Plug &apos;morhetz/gruvbox&apos;</span><br><span class="line">line    9:</span><br><span class="line">E492: Not an editor command: Plug &apos;octol/vim-cpp-enhanced-highlight&apos;</span><br><span class="line">line   10:</span><br><span class="line">E492: Not an editor command: Plug &apos;SirVer/ultisnips&apos;</span><br><span class="line">line   11:</span><br><span class="line">E492: Not an editor command: Plug &apos;tpope/vim-surround&apos;</span><br><span class="line">line   12:</span><br><span class="line">E492: Not an editor command: Plug &apos;flazz/vim-colorschemes&apos;</span><br><span class="line">line   13:</span><br><span class="line">E492: Not an editor command: Plug &apos;scrooloose/nerdtree&apos;</span><br><span class="line">line   14:</span><br><span class="line">E492: Not an editor command: Plug &apos;python-mode/python-mode&apos;</span><br><span class="line">line   15:</span><br><span class="line">E492: Not an editor command: Plug &apos;scrooloose/nerdcommenter&apos;</span><br><span class="line">line   16:</span><br><span class="line">E492: Not an editor command: Plug &apos;Yggdroot/LeaderF&apos;</span><br><span class="line">line   17:</span><br><span class="line">E492: Not an editor command: Plug &apos;cpiger/NeoDebug&apos;</span><br><span class="line">line   18:</span><br><span class="line">E492: Not an editor command: Plug &apos;ryanoasis/vim-devicons&apos;</span><br><span class="line">line   22:</span><br><span class="line">E492: Not an editor command: Plug &apos;autozimu/LanguageClient-neovim&apos;, &#123; &apos;branch&apos;: &apos;next&apos;, &apos;do&apos;: &apos;bash install.sh&apos;, &#125;</span><br><span class="line">line   29:</span><br><span class="line">E185: Cannot find color scheme &apos;luna-term&apos;</span><br><span class="line">line   58:</span><br><span class="line">E518: Unknown option: foldmethod=marker</span><br><span class="line">line  141:</span><br><span class="line">E518: Unknown option: foldenable</span><br><span class="line">line  149:</span><br><span class="line">E518: Unknown option: foldmethod=indent</span><br><span class="line">line  150:</span><br><span class="line">E518: Unknown option: foldlevel=99</span><br><span class="line">line  294:</span><br><span class="line">E31: No such mapping</span><br><span class="line">line  295:</span><br><span class="line">E31: No such mapping</span><br><span class="line">line  296:</span><br><span class="line">E31: No such mapping</span><br><span class="line">line  297:</span><br><span class="line">E31: No such mapping</span><br><span class="line">line  298:</span><br><span class="line">E31: No such mapping</span><br><span class="line">line  299:</span><br><span class="line">E31: No such mapping</span><br><span class="line">line  300:</span><br><span class="line">E31: No such mapping</span><br><span class="line">line  301:</span><br><span class="line">E31: No such mapping</span><br><span class="line">Press ENTER or type command to continue</span><br><span class="line">[master 0ec225e] First</span><br><span class="line"> 3 files changed, 59 insertions(+)</span><br><span class="line"> create mode 100755 myshell/Makefile</span><br><span class="line"> create mode 100755 myshell/myshell</span><br><span class="line"> create mode 100755 myshell/myshell.c</span><br></pre></td></tr></table></figure></p><blockquote><p>按照提示信息修改用户名和邮箱</p></blockquote><h3 id="五、部署到远程仓库"><a href="#五、部署到远程仓库" class="headerlink" title="五、部署到远程仓库"></a>五、部署到远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push  origin master</span><br></pre></td></tr></table></figure><p>部署成功之后可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[kui@localhost Kui]$ git push origin master</span><br><span class="line">Username for &apos;https://github.com&apos;: kui-si-ming</span><br><span class="line">Password for &apos;https://kui-si-ming@github.com&apos;:</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 2 threads.</span><br><span class="line">Compressing objects: 100% (5/5), done.</span><br><span class="line">Writing objects: 100% (6/6), 3.74 KiB | 0 bytes/s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request for &apos;master&apos; on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/KUI-SI-MING/Kui/pull/new/master</span><br><span class="line">remote:</span><br><span class="line">To https://github.com/KUI-SI-MING/Kui.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure></p><p>这样就大功告成啦。在官网就可以看到<br><img src="/img/TIM截图20181108164405.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、建立GitHub远程仓库&quot;&gt;&lt;a href=&quot;#一、建立GitHub远程仓库&quot; class=&quot;headerlink&quot; title=&quot;一、建立GitHub远程仓库&quot;&gt;&lt;/a&gt;一、建立GitHub远程仓库&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在Github官网上建立一个仓库&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="提交Github代码" scheme="http://yoursite.com/tags/%E6%8F%90%E4%BA%A4Github%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C++ templates</title>
    <link href="http://yoursite.com/2018/11/08/C-templates/"/>
    <id>http://yoursite.com/2018/11/08/C-templates/</id>
    <published>2018-11-08T06:13:39.000Z</published>
    <updated>2019-04-03T15:27:05.951Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<font color="black" size="4" face="微软雅黑">C++ templates的最初发展是为了建立“类型安全”的容器如：vector，list和map。但是随着templates的发展，有人意识到C++ templates机制本身就是一步完整的图灵机：它可以被用来计算任何可以计算的值，于是导出了模板元编程，创造出了“在C++编译器内执行并于编译完成时停止执行”的程序。<br><a id="more"></a></font></p><h3 id="一、C-模板"><a href="#一、C-模板" class="headerlink" title="一、C++模板"></a>一、C++模板</h3><ul><li><font color="black" size="4" face="微软雅黑">泛型编程<br>&emsp;<font color="black" size="4" face="微软雅黑">关于泛型编程就是编写与类型无关的通用代码，是代码复用的一种手段。而模板是泛型编程的基础。模板又可以分为函数模板和类模板。函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。</font></font></li><li><font color="black" size="4" face="微软雅黑">函数模板<br>&emsp;<font color="black" size="4" face="微软雅黑">模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来应该我们做的重复的事情交给了编译器在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型代码，对于字符类型也是如此。在实现函数模板的实例化时可以分为隐式实例化和显式实例化。<blockquote><p>1.隐式实例化：让编译器根据实参推演模板参数的实际类型<br>2.显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型<br>&emsp;<font color="black" size="4" face="微软雅黑">对于函数模板参数的匹配则又可以分为以下几点：<br>&emsp;&emsp;1.一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数<br>&emsp;&emsp;2.对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板<br>&emsp;&emsp;3.显式指定一个空的模板实参列表，该语法告诉编译器只有模板才能来匹配这个调用， 而且所有的模板参数都应该根据实参演绎出来<br>&emsp;&emsp;4.模板函数不允许自动类型转换，但普通函数可以进行自动类型转换</font></p></blockquote></font></font></li><li><font color="black" size="4" face="微软雅黑">类模板<br>&emsp;<font color="black" size="4" face="微软雅黑">类模板中函数放在类外进行定义时，需要加模板参数列表，类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。</font></font></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;C++ templates的最初发展是为了建立“类型安全”的容器如：vector，list和map。但是随着templates的发展，有人意识到C++ templates机制本身就是一步完整的图灵机：它可以被用来计算任何可以计算的值，于是导出了模板元编程，创造出了“在C++编译器内执行并于编译完成时停止执行”的程序。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="泛型编程" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
      <category term="C++模板" scheme="http://yoursite.com/tags/C-%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>C++初识</title>
    <link href="http://yoursite.com/2018/11/06/C-%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2018/11/06/C-初识/</id>
    <published>2018-11-06T04:33:50.000Z</published>
    <updated>2019-04-03T15:29:23.838Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<font color="black" size="4" face="微软雅黑">计算机革命起源于一台机器。因此，程序设计语言的起源看上去也起源于那台机器。<br><a id="more"></a></font></p><h3 id="一、关于的C-发展史"><a href="#一、关于的C-发展史" class="headerlink" title="一、关于的C++发展史"></a>一、关于的C++发展史</h3><p>&emsp;<font color="black" size="4" face="微软雅黑">程序作为算法和数据的集合，在计算机的发展中一直未变，发展演化的是他们之间的关系，就是所谓的程序设计方法。<br>&emsp;<font color="black" size="4" face="微软雅黑">C语言是结构化和模块化的语言，适合处理较小规模的程序。对于复杂的问题，规模较大的程序，需要高度的抽象和建模时，C语言则不合适。为了解决软件危机， 在 20 世纪 70 年代,程序设计的焦点从过程化程序设计方法转移到了抽象数据类型(abstract data type )简写为 ADT 的程序设计上,现在通常称之为基于对象(object based)的程序设计 。<br>&emsp;<font color="black" size="4" face="微软雅黑">1982年，Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与C语言的渊源关系，命名为C++。因此：C++是基于C语言而产生的，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。<br>&emsp;<font color="black" size="4" face="微软雅黑">如今的C++大厦是一钉一卯创建起来的，来看下C++历史版本。<br><img src="/img/TIM截图20181106110422.png" alt="在这里插入图片描述"></font></font></font></font></p><h3 id="二、C-入门基础"><a href="#二、C-入门基础" class="headerlink" title="二、C++ 入门基础"></a>二、C++ 入门基础</h3><ul><li>&emsp;<font color="black" size="4" face="微软雅黑">命名空间：在C/C++中，变量、函数和许多类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。<br>&emsp;<font color="black" size="4" face="微软雅黑">名字空间是很有用的工具，但名字空间的出现意味着在写程序之前必须知道他们。所有的C++标准库都封装在“std”(standard)。名字空间和包含头文件的方法之间相互关系若给出<code>#include &lt;iostream.h&gt;</code>它相当于<code>#include &lt;iostream&gt;       using namespace std</code></font></font></li><li>&emsp;<font color="black" size="4" face="微软雅黑">缺省参数：是一种虽然并不普遍，但在多数情况下仍然适用的实参值。 函数可以用参数表中的初始化语法为一个或多个参数指定缺省实参 ，调用包含缺省实参的函数时，我们可以，也可以不为该参数提供实参，如果提供了实参，则它将覆盖缺省的实参值 。函数调用的实参按位置解析，缺省实参只能用来替换函数调用缺少的尾部 （tailing） 实参 。函数声明可以为全部或部分参数指定缺省实参，在左边参数的任何缺省实参被提供之前，最右边未初始化参数必须被提供缺省实参，这是由于函数调用的实参是按照位置来解析的。一个参数只能在一个文件中被指定一次缺省实参 。</font></li><li>&emsp;<font color="black" size="4" face="微软雅黑">函数重载：在 C++中，可以为两个或多个函数提供相同的名字，只要它们的每个参数表惟一就行或者是参数的个数不同，或者是参数类型不同 。<ul><li><font color="black" size="4" face="微软雅黑">名字修饰：为了让重载函数正确的工作，编译器要用不同的参数类型来修饰不同的函数名，而这种名字修饰没有统一的标准，所以不同的编译器可能会产生不同的内部名（可在汇编代码看到），名字修饰的另一个好处是<font color="red" size="4" face="微软雅黑">类型安全连接。<font color="black" size="4" face="微软雅黑">即使当函数的调用与声明不符时，C++在链接时会报告错误信息，而这在大项目中将会避免很多隐藏的错误。<blockquote><p>C语言中对于同名函数，在汇编语言中链接时符号表中的命名为函数名 + 地址，这样对于同名的函数而言，编译器找不到需要跳转的地址，所以不支持函数重载。而C++有自己的函数命名规则，即在符号表中用函数名修饰规则表示函数名，不同参数的函数名不一样，编译器能根据函数名找到跳转的地址。</p></blockquote></font></font></font></li><li><font color="black" size="4" face="微软雅黑">用返回值重载：虽然内部函数修饰了返回值，当编译器能从上下文中唯一确定函数的意思时，没有问题，但在C中总是可以调用一个函数但忽略它的返回值，即调用了函数的副作用，那么此时编译器调用哪个函数，而且程序员自己也不知道那个函数被调用，所以C++中禁止这样做。</font></li></ul></font></li><li><font color="black" size="4" face="微软雅黑">指针和引用：引用就像是能自动地被编译器间接引用的常量型指针。常用雨于函数参数表中和函数的返回值，也可独立使用。C++支持相近类型（类型的意义近似相同）的隐式转换 <code>int e = 10; const double&amp; f = e;//f并不是e的别名而是编译器隐式转换所创建的临时变量的别名</code>。</font></li></ul><blockquote><font color="black" size="4" face="微软雅黑">引用和指针的区别:<br>引用和指针在语法上不一样但在底层实现上是一样的。<br>引用只能在定义时初始化一次，之后不能改变指向其它变量（从一而终）；指针变量的值可变。<br>引用必须指向有效的变量，指针可以为空。<br>sizeof指针对象和引用对象的意义不一样。sizeof引用得到的是所指向的变量的大小，而sizeof指针是对象地址的大小。<br>指针和引用自增<code>++</code>自减<code>--</code>意义不一样。<br>相对而言，引用比指针更安全。<br></font></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;计算机革命起源于一台机器。因此，程序设计语言的起源看上去也起源于那台机器。&lt;br&gt;
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="C++发展史" scheme="http://yoursite.com/tags/C-%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    
      <category term="函数重载" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    
      <category term="命名空间" scheme="http://yoursite.com/tags/%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    
      <category term="指针和引用" scheme="http://yoursite.com/tags/%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程相关（一）</title>
    <link href="http://yoursite.com/2018/11/05/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/11/05/Linux进程相关（一）/</id>
    <published>2018-11-05T15:20:30.000Z</published>
    <updated>2019-04-03T15:31:05.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、进程的调度算法"><a href="#一、进程的调度算法" class="headerlink" title="一、进程的调度算法"></a><font color="black" size="4" face="微软雅黑">一、进程的调度算法</font></h3><p>&emsp;<font color="black" size="4" face="微软雅黑">1.进程调度：多进程环境，望文生义，有多个进程同时进行,但具体到单个CPU级别，则在任何时刻只能有一个进程执行，因此操作系统需要决定哪个进程可以执行，哪个进程需要等待，而这就是进程调度。<br><a id="more"></a><br>&emsp;<font color="black" size="4" face="微软雅黑">2.进程状态: a.等待态：等待某个事件的完成；<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b.就绪态：等待系统分配处理器以便运行<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;c.运行态：占有处理器正在运<br>&emsp;<font color="black" size="4" face="微软雅黑">3.三种进程状态的转换：运行态-&gt;等待态：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的；<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;等待态-&gt;就绪态：等待的条件已经满足，只需要分配到处理器后就能运行；<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;就绪态-&gt;运行态：系统按某种策略选中就绪队列中的一个进程占用处理器；<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;运行态-&gt;就绪态：由于外界原因让运行状态的进程让出处理器，例如有更高优先级的进程来抢占处理器，或时间片（时间片是系统分配给程序的运行时间）用完<br>&emsp;<font color="black" size="4" face="微软雅黑">4。调度目标:1.程序使用CPU的三种模式：IO密集型、计算密集型和平衡型。对于IO密集型程序来说，响应时间非常重要；对于CPU密集型来说，CPU的周转时间就比较重要；对于平衡型程序来说，响应和周转之间的平衡是最重要的。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2.CPU的调度就是要达到极小化平均响应时间、极大化系统吞吐率、保持系统各个功能部件均处于繁忙状态和提供某种公平的机制。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3.对于实时系统来说，调度的目标就是要达到截止时间前完成所应该完成的任务和提供性能的可预测性<br>&emsp;<font color="black" size="4" face="微软雅黑">5.调度方式： 剥夺方式——当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给他的处理机，将之分配给其他进程，剥夺原则有：优先权原则、短进程优先原则、时间片原则。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 非剥夺方式：分配程序一旦把处理机分配给某进程后便让他一直运行下去，直到进程完成或发生事件而阻塞时，才把处理机分配给另一个进程<br>&emsp;<font color="black" size="4" face="微软雅黑">6.调度算法：a.先来先服务调度算法,FCFS（First come first serve)，或者称为FIFO算法。先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。这个算法的优点是简单，实现容易，并且似乎公平；缺点在于短的任务有可能变的非常慢，因为其前面的任务占用很长时间，造成了平均响应时间非常慢。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b.短任务优先算法（STCF算法（Short time to complete first)），这种算法的核心就是所有的程序都有一个优先级，短任务的优先级比长任务的高，而OS总是安排优先级高的进程运行。STCF又分为两类：非抢占式和抢占式。非抢占式STCF就是让已经在CPU上运行的程序执行到结束或者阻塞，然后在所有的就绪进程中选择执行时间最短的来执行；而抢占式STCF就不是这样，在每进来一个新的进程时，就对所有进程（包括正在CPU上执行的进程）进行检查，谁的执行时间短，就运行谁。对预计执行时间短的进程有限分配处理机，通常后来的短进程不会抢先正在执行的进程；对长进程非常不利，可能长时间得不到执行。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;c.时间片轮询算法，这是对FIFO算法的改进，目的是改善短程序（运行时间短）的响应时间，其方法就是周期性地进行进程切换。这个算法的关键点在于时间片的选择，时间片过大，那么轮转就越接近FIFO，如果太小，进程切换的开销大于执行程序的开销，从而降低了系统效率。因此选择合适的时间片就非常重要。选择时间片的两个需要考虑的因素：一次进程切换所使用的系统消耗以及我们能接受的整个系统消耗、系统运行的进程数。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;d.优先级调度:优先级调度，STCF遇到的问题是长任务的程序可能饥饿，那么优先级调度算法可以通过给长任务的进程更高的优先级来解决这个问题；优先级调度遇到的问题可能是短任务的进程饥饿，这个可以通过动态调整优先级来解决。实际上动态调整优先级（称为权值）+时间片轮询的策略正是linux的进程调度策略之一的 SCHED_OTHER分时调度策略,它的调度过程如下：（1）创建任务指定采用分时调度策略，并指定优先级nice值(-20~19)。—-&gt;（2）将根据每个任务的nice值确定在cpu上的执行时间(counter)。—-&gt;（3）如果没有等待资源，则将该任务加入到就绪队列中。—-&gt;（4）调度程序遍历就绪队列中的任务，通过对每个任务动态优先级的计算(counter+20-nice)结果，选择计算结果最大的一个去运行，当这个时间片用完后(counter减至0)或者主动放弃cpu时，该任务将被放在就绪队列末尾(时间片用完)或等待队列(因等待资源而放弃cpu)中。—-&gt;（5）此时调度程序重复上面计算过程，转到第4步。—-&gt;（6）当调度程序发现所有就绪任务计算所得的权值都为不大于0时，重复第2步。<br>此外linux还有两个实时进程的调度策略：FIFO和RR,实时进程会立即抢占非实时进程。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;e其他调度算法，保证调度算法保证每个进程享用的CPU时间完全一样；彩票调度算法是一种概率调度算法，通过给进程“发彩票”的多少，来赋予不同进程不同的调用时间，彩票调度算法的优点是非常灵活，如果你给短任务发更多“彩票”，那么就类似STCF调度，如果给每个进程一样多的“彩票”，那么就类似保证调度；用户公平调度算法，是按照每个用户，而不是按照每个进程来进行公平分配CPU时间，这是为了防止贪婪用户启用了过多进程导致系统效率降低甚至停顿。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;f.实时系统的调度算法，实时系统需要考虑每个具体任务的响应时间必须符合要求，在截止时间前完成。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(1)EDF调度算法，就是最早截止任务优先（Earliest deadline first)算法，也就是让最早截止的任务先做。当新的任务过来时，如果它的截止时间更靠前，那么就让新任务抢占正在执行的任务。EDF算法其实是贪心算法的一种体现。如果一组任务可以被调度（也就是所有任务的截止时间在理论上都可以得到满足），那么EDF可以满足。如果一批任务不能全部满足（全部在各自的截止时间前完成），那EDF满足的任务数最多，这就是它最优的体现。EDF其实就是抢占式的STCF，只不过将程序的执行时间换成了截止时间。EDF的缺点在于需要对每个任务的截止时间做计算并动态调整优先级，并且抢占任务也需要消耗系统资源。因此它的实际效果比理论效果差一点。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(2)RMS调度算法，EDF是动态调度算法，而RMS（rate monotonic scheduling)算法是一种静态最优算法；该算法在进行调度前先计算出所有任务的优先级，然后按照计算出来的优先级进行调度，任务执行中间既不接收新任务，也不进行优先级调整或者CPU抢占。因此它的优点是系统消耗小，缺点就是不灵活了。对于RMS算法，关键点在于判断一个任务组是否能被调度，这里有一个定律，如果一个系统的所有任务的CPU利用率都低于ln2，那么这些任务的截止时间均可以得到满足，ln2约等于0.693147，也就是此时系统还剩下有30%的CPU时间。这个证明是Liu和Kayland在1973年给出的</font></font></font></font></font></font></p><h3 id="二、task-struct结构体中的各个字段的含义"><a href="#二、task-struct结构体中的各个字段的含义" class="headerlink" title="二、task_struct结构体中的各个字段的含义"></a><font color="black" size="4" face="微软雅黑">二、task_struct结构体中的各个字段的含义</font></h3><p>&emsp;<font color="black" size="4" face="微软雅黑">在linux中，每创建一个进程就会产生一个进程描述符，这个”进程描述符”就是task_struct，在task_struct里面保存了许多关于进程控制的信息。 task_struct是Linux内核的一种数据结构，每个进程都把它的信息放在task_struct这个数据结构里，包含</font></p><ul><li><font color="black" size="4" face="微软雅黑">标示符：描述本进程的唯一标示符，用来区别其他进程</font></li><li><font color="black" size="4" face="微软雅黑">状态：任务状态，退出代码，退出信号等</font></li><li><font color="black" size="4" face="微软雅黑">优先级：相对于其他进程的优先级</font></li><li><font color="black" size="4" face="微软雅黑">程序计数器：程序中即将被执行的下一条指令的地址</font></li><li><font color="black" size="4" face="微软雅黑">内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</font></li><li><font color="black" size="4" face="微软雅黑">上下文数据：进程执行时处理器的寄存器中的数据</font></li><li><font color="black" size="4" face="微软雅黑">I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和正在被进程使用的文件列表</font></li><li><font color="black" size="4" face="微软雅黑">记账信息：可能包括处理器时间总和，使用的时钟总数，时间限制，记账号。</font></li></ul><hr><p>&emsp;<font color="black" size="4" face="微软雅黑">成员分类如下<br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">1.进程标识符（PID）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">pid_t</span> tgid;</span><br></pre></td></tr></table></figure></font></font></p><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">在CONFIG_BASE_SMALL配置为0的情况下，PID的取值范围是0到32767，即系统中的进程数最大为32768个。<br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">2.进程的状态<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"><span class="keyword">int</span> exit_state;</span><br></pre></td></tr></table></figure></font></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">state成员的取值如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_RUNNING        0<span class="comment">//进程要么正在执行，要么准备执行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_INTERRUPTIBLE  1 <span class="comment">//可中断的睡眠，可以通过一个信号唤醒</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_UNINTERRUPTIBLE    2 <span class="comment">//不可中断睡眠，不可以通过信号进行唤醒</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TASK_STOPPED      4 <span class="comment">//进程停止执行</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TASK_TRACED       8 <span class="comment">//进程被追踪</span></span></span><br><span class="line"><span class="comment">/* in tsk-&gt;exit_state */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_ZOMBIE     16 <span class="comment">//僵尸状态的进程，表示进程被终止，但是父进程还没       有获取它的终止信息，比如进程有没有执行完等信息。                     </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXIT_DEAD       32 <span class="comment">//进程的最终状态，进程死亡。</span></span></span><br><span class="line"><span class="comment">/* in tsk-&gt;state again */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_DEAD       64 <span class="comment">//死亡</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_WAKEKILL       128 <span class="comment">//唤醒并杀死的进程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TASK_WAKING     256 <span class="comment">//唤醒进程</span></span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">3.进程的内核栈<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *<span class="built_in">stack</span>;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">进程通过alloc_thread_info函数分配它的内核栈，通过free_thread_info函数释放所分配的内核栈</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* linux-2.6.38.8/kernel/fork.c */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct thread_info *<span class="title">alloc_thread_info</span><span class="params">(struct task_struct *tsk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_STACK_USAGE</span></span><br><span class="line"><span class="keyword">gfp_t</span> mask = GFP_KERNEL | __GFP_ZERO;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">gfp_t</span> mask = GFP_KERNEL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">return</span> (struct thread_info *)__get_free_pages(mask, THREAD_SIZE_ORDER);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">free_thread_info</span><span class="params">(struct thread_info *ti)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">free_pages((<span class="keyword">unsigned</span> <span class="keyword">long</span>)ti, THREAD_SIZE_ORDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">Linux内核通过thread_union联合体来表示进程的内核栈，其中THREAD_SIZE宏的大小为8192。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> thread_union &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> <span class="title">thread_info</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[THREAD_SIZE/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">进程内核栈与进程描述符的关系如下图<br><img src="https://img-blog.csdnimg.cn/20190403231329666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1aXNpOTU=,size_16,color_FFFFFF,t_70" alt=""><br>&emsp;&emsp;4.标记<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> flags;<span class="comment">/* per process flags, defined below */</span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">flags成员的可能取值如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_KSOFTIRQD0x00000001<span class="comment">/* I am ksoftirqd */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_STARTING0x00000002<span class="comment">/* being created */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_EXITING0x00000004<span class="comment">/* getting shut down */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_EXITPIDONE0x00000008<span class="comment">/* pi exit done on shut down */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_VCPU0x00000010<span class="comment">/* I'm a virtual CPU */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_WQ_WORKER0x00000020<span class="comment">/* I'm a workqueue worker */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_FORKNOEXEC0x00000040<span class="comment">/* forked but didn't exec */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_MCE_PROCESS  0x00000080      <span class="comment">/* process policy on mce errors */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_SUPERPRIV0x00000100<span class="comment">/* used super-user privileges */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_DUMPCORE0x00000200<span class="comment">/* dumped core */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_SIGNALED0x00000400<span class="comment">/* killed by a signal */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_MEMALLOC0x00000800<span class="comment">/* Allocating memory */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_USED_MATH0x00002000<span class="comment">/* if unset the fpu must be initialized before use */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_FREEZING0x00004000<span class="comment">/* freeze in progress. do not account to load */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_NOFREEZE0x00008000<span class="comment">/* this thread should not be frozen */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_FROZEN0x00010000<span class="comment">/* frozen for system suspend */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_FSTRANS0x00020000<span class="comment">/* inside a filesystem transaction */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_KSWAPD0x00040000<span class="comment">/* I am kswapd */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_OOM_ORIGIN0x00080000<span class="comment">/* Allocating much memory to others */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_LESS_THROTTLE 0x00100000<span class="comment">/* Throttle me less: I clean memory */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_KTHREAD0x00200000<span class="comment">/* I am a kernel thread */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_RANDOMIZE0x00400000<span class="comment">/* randomize virtual address space */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_SWAPWRITE0x00800000<span class="comment">/* Allowed to write to swap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_SPREAD_PAGE0x01000000<span class="comment">/* Spread page cache over cpuset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_SPREAD_SLAB0x02000000<span class="comment">/* Spread some slab caches over cpuset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_THREAD_BOUND0x04000000<span class="comment">/* Thread bound to specific cpu */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_MCE_EARLY    0x08000000      <span class="comment">/* Early kill for mce process policy */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_MEMPOLICY0x10000000<span class="comment">/* Non-default NUMA mempolicy */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_MUTEX_TESTER0x20000000<span class="comment">/* Thread belongs to the rt mutex tester */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_FREEZER_SKIP0x40000000<span class="comment">/* Freezer should not count it as freezable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PF_FREEZER_NOSIG 0x80000000<span class="comment">/* Freezer won't send signals to it */</span></span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">5.进程之间的亲属关系：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span> <span class="comment">/* real parent process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span> <span class="comment">/* recipient of SIGCHLD, wait4() reports */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span><span class="comment">/* list of my children */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span><span class="comment">/* linkage in my parent's children list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span><span class="comment">/* threadgroup leader */</span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">在Linux系统中，所有进程之间都有着直接或间接地联系，每个进程都有其父进程，也可能有零个或多个子进程。拥有同一父进程的所有进程具有兄弟关系。<br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">real_parent指向其父进程，如果创建它的父进程不再存在，则指向PID为1的init进程。<br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">parent指向其父进程，当它终止时，必须向它的父进程发送信号。它的值通常与real_parent相同。<br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">children表示链表的头部，链表中的所有元素都是它的子进程。<br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">sibling用于把当前进程插入到兄弟链表中。<br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">group_leader指向其所在进程组的领头进程。</font></font></font></font></font></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">6.ptrace系统调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ptrace;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptraced</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">ptrace_entry</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ptrace_message;</span><br><span class="line"><span class="keyword">siginfo_t</span> *last_siginfo; <span class="comment">/* For ptrace use.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HAVE_HW_BREAKPOINT</span></span><br><span class="line"><span class="keyword">atomic_t</span> ptrace_bp_refcnt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑"><font color="black" size="4" face="微软雅黑">成员ptrace被设置为0时表示不需要被跟踪，它的可能取值如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* linux-2.6.38.8/include/linux/ptrace.h */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_PTRACED0x00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_DTRACE0x00000002<span class="comment">/* delayed trace (used on m68k, i386) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_TRACESYSGOOD0x00000004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_PTRACE_CAP0x00000008<span class="comment">/* ptracer can follow suid-exec */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_TRACE_FORK0x00000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_TRACE_VFORK0x00000020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_TRACE_CLONE0x00000040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_TRACE_EXEC0x00000080</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_TRACE_VFORK_DONE0x00000100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_TRACE_EXIT0x00000200</span></span><br></pre></td></tr></table></figure></font></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">7.进程调度<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prio, static_prio, normal_prio;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rt_priority;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> policy;</span><br><span class="line"><span class="keyword">cpumask_t</span> cpus_allowed;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">实时优先级范围是0到MAX_RT_PRIO-1（即99），而普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1（即100到139）。值越大静态优先级越低。<br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑"><br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">rt_priority用于保存实时优先级。<br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">normal_prio的值取决于静态优先级和调度策略。<br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">prio用于保存动态优先级。<br>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">policy表示进程的调度策略，目前主要有以下五种：</font></font></font></font></font></font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_NORMAL        0<span class="comment">//按照优先级进行调度（有些地方也说是CFS调度器）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_FIFO        1<span class="comment">//先进先出的调度算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_RR        2<span class="comment">//时间片轮转的调度算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_BATCH        3<span class="comment">//用于非交互的处理机消耗型的进程</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_IDLE        5<span class="comment">//系统负载很低时的调度算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SCHED_RESET_ON_FORK     0x40000000</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">8.时间数据成员<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cputime_t</span> utime, stime, utimescaled, stimescaled;</span><br><span class="line">    <span class="keyword">cputime_t</span> gtime;</span><br><span class="line">    <span class="keyword">cputime_t</span> prev_utime, prev_stime;<span class="comment">//记录当前的运行时间（用户态和内核态）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> nvcsw, nivcsw; <span class="comment">//自愿/非自愿上下文切换计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">start_time</span>;</span>  <span class="comment">//进程的开始执行时间    </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">real_start_time</span>;</span>  <span class="comment">//进程真正的开始执行时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_cputime</span> <span class="title">cputime_expires</span>;</span><span class="comment">//cpu执行的有效时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cpu_timers</span>[3];</span><span class="comment">//用来统计进程或进程组被处理器追踪的时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> timeout;<span class="comment">//当前已使用的时间（与开始时间的差值）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> time_slice;<span class="comment">//进程的时间片的大小</span></span><br><span class="line">    <span class="keyword">int</span> nr_cpus_allowed;</span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">9.信号处理信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span><span class="comment">//指向进程信号描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span><span class="comment">//指向进程信号处理程序描述符</span></span><br><span class="line">    <span class="keyword">sigset_t</span> blocked, real_blocked;<span class="comment">//阻塞信号的掩码</span></span><br><span class="line">    <span class="keyword">sigset_t</span> saved_sigmask;    <span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span><span class="comment">//进程上还需要处理的信号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;<span class="comment">//信号处理程序备用堆栈的地址</span></span><br><span class="line">    <span class="keyword">size_t</span> sas_ss_size;<span class="comment">//信号处理程序的堆栈的地址</span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">10.文件系统信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* filesystem information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span><span class="comment">//文件系统的信息的指针</span></span><br><span class="line"><span class="comment">/* open file information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span><span class="comment">//打开文件的信息指针</span></span><br></pre></td></tr></table></figure></font></p><p>&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">task_struct的定义及注释</font></p><pre><code class="c"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> {</span><span class="keyword">volatile</span> <span class="keyword">long</span> state;  <span class="comment">//说明了该进程是否可以执行,还是可中断等信息</span><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;  <span class="comment">//Flage 是进程号,在调用fork()时给出</span><span class="keyword">int</span> sigpending;    <span class="comment">//进程上是否有待处理的信号</span><span class="keyword">mm_segment_t</span> addr_limit; <span class="comment">//进程地址空间,区分内核进程与普通进程在内存存放的位置不同</span>                        <span class="comment">//0-0xBFFFFFFF for user-thead</span>                        <span class="comment">//0-0xFFFFFFFF for kernel-thread</span><span class="comment">//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度</span><span class="keyword">volatile</span> <span class="keyword">long</span> need_resched;<span class="keyword">int</span> lock_depth;  <span class="comment">//锁深度</span><span class="keyword">long</span> nice;       <span class="comment">//进程的基本时间片</span><span class="comment">//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER</span><span class="keyword">unsigned</span> <span class="keyword">long</span> policy;<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span> <span class="comment">//进程内存管理信息</span><span class="keyword">int</span> processor;<span class="comment">//若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新</span><span class="keyword">unsigned</span> <span class="keyword">long</span> cpus_runnable, cpus_allowed;<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">run_list</span>;</span> <span class="comment">//指向运行队列的指针</span><span class="keyword">unsigned</span> <span class="keyword">long</span> sleep_time;  <span class="comment">//进程的睡眠时间</span><span class="comment">//用于将系统中所有的进程连成一个双向循环链表, 其根是init_task</span><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">next_task</span>, *<span class="title">prev_task</span>;</span><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">local_pages</span>;</span>       <span class="comment">//指向本地页面      </span><span class="keyword">unsigned</span> <span class="keyword">int</span> allocation_order, nr_local_pages;<span class="class"><span class="keyword">struct</span> <span class="title">linux_binfmt</span> *<span class="title">binfmt</span>;</span>  <span class="comment">//进程所运行的可执行文件的格式</span><span class="keyword">int</span> exit_code, exit_signal;<span class="keyword">int</span> pdeath_signal;     <span class="comment">//父进程终止时向子进程发送的信号</span><span class="keyword">unsigned</span> <span class="keyword">long</span> personality;<span class="comment">//Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序</span><span class="keyword">int</span> did_exec:<span class="number">1</span>;<span class="keyword">pid_t</span> pid;    <span class="comment">//进程标识符,用来代表一个进程</span><span class="keyword">pid_t</span> pgrp;   <span class="comment">//进程组标识,表示进程所属的进程组</span><span class="keyword">pid_t</span> tty_old_pgrp;  <span class="comment">//进程控制终端所在的组标识</span><span class="keyword">pid_t</span> session;  <span class="comment">//进程的会话标识</span><span class="keyword">pid_t</span> tgid;<span class="keyword">int</span> leader;     <span class="comment">//表示进程是否为会话主管</span><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p_opptr</span>,*<span class="title">p_pptr</span>,*<span class="title">p_cptr</span>,*<span class="title">p_ysptr</span>,*<span class="title">p_osptr</span>;</span><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span>   <span class="comment">//线程链表</span><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">pidhash_next</span>;</span> <span class="comment">//用于将进程链入HASH表</span><span class="class"><span class="keyword">struct</span> <span class="title">task_structpidhash_pprev</span>;</span><span class="keyword">wait_queue_head_t</span> wait_chldexit;  <span class="comment">//供wait4()使用</span><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">vfork_done</span>;</span>  <span class="comment">//供vfork() 使用</span><span class="keyword">unsigned</span> <span class="keyword">long</span> rt_priority; <span class="comment">//实时优先级，用它计算实时进程调度时的weight值</span><span class="comment">//it_real_value，it_real_incr用于REAL定时器，单位为jiffies, 系统根据it_real_value</span><span class="comment">//设置定时器的第一个终止时间. 在定时器到期时，向进程发送SIGALRM信号，同时根据</span><span class="comment">//it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。</span><span class="comment">//当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送</span><span class="comment">//信号SIGPROF，并根据it_prof_incr重置时间.</span><span class="comment">//it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种</span><span class="comment">//状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据</span><span class="comment">//it_virt_incr重置初值。</span><span class="keyword">unsigned</span> <span class="keyword">long</span> it_real_value, it_prof_value, it_virt_value;<span class="keyword">unsigned</span> <span class="keyword">long</span> it_real_incr, it_prof_incr, it_virt_value;<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">real_timer</span>;</span>   <span class="comment">//指向实时定时器的指针</span><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">times</span>;</span>      <span class="comment">//记录进程消耗的时间</span><span class="keyword">unsigned</span> <span class="keyword">long</span> start_time;  <span class="comment">//进程创建的时间</span><span class="comment">//记录进程在每个CPU上所消耗的用户态时间和核心态时间</span><span class="keyword">long</span> per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];<span class="comment">//内存缺页和交换信息:</span><span class="comment">//min_flt, maj_flt累计进程的次缺页数（Copy on　Write页和匿名页）和主缺页数（从映射文件或交换</span><span class="comment">//设备读入的页面数）； nswap记录进程累计换出的页面数，即写到交换设备上的页面数。</span><span class="comment">//cmin_flt, cmaj_flt, cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。</span><span class="comment">//在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中</span><span class="keyword">unsigned</span> <span class="keyword">long</span> min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;<span class="keyword">int</span> swappable:<span class="number">1</span>; <span class="comment">//表示进程的虚拟地址空间是否允许换出</span><span class="comment">//进程认证信息</span><span class="comment">//uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid</span><span class="comment">//euid，egid为有效uid,gid</span><span class="comment">//fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件</span><span class="comment">//系统的访问权限时使用他们。</span><span class="comment">//suid，sgid为备份uid,gid</span><span class="keyword">uid_t</span> uid,euid,suid,fsuid;<span class="keyword">gid_t</span> gid,egid,sgid,fsgid;<span class="keyword">int</span> ngroups; <span class="comment">//记录进程在多少个用户组中</span><span class="keyword">gid_t</span> groups[NGROUPS]; <span class="comment">//记录进程所在的组</span><span class="comment">//进程的权能，分别是有效位集合，继承位集合，允许位集合</span><span class="keyword">kernel_cap_t</span> cap_effective, cap_inheritable, cap_permitted;<span class="keyword">int</span> keep_capabilities:<span class="number">1</span>;<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rlim</span>[<span class="title">RLIM_NLIMITS</span>];</span>  <span class="comment">//与进程相关的资源限制信息</span><span class="keyword">unsigned</span> <span class="keyword">short</span> used_math;   <span class="comment">//是否使用FPU</span><span class="keyword">char</span> comm[<span class="number">16</span>];   <span class="comment">//进程正在运行的可执行文件名</span> <span class="comment">//文件系统信息</span><span class="keyword">int</span> link_count, total_link_count;<span class="comment">//NULL if no tty 进程所在的控制终端，如果不需要控制终端，则该指针为空</span><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span><span class="keyword">unsigned</span> <span class="keyword">int</span> locks;<span class="comment">//进程间通信信息</span><span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *<span class="title">semundo</span>;</span>  <span class="comment">//进程在信号灯上的所有undo操作</span><span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *<span class="title">semsleeping</span>;</span> <span class="comment">//当进程因为信号灯操作而挂起时，他在该队列中记录等待的操作</span><span class="comment">//进程的CPU状态，切换时，要保存到停止进程的task_struct中</span><span class="class"><span class="keyword">struct</span> <span class="title">thread_struct</span> <span class="title">thread</span>;</span>  <span class="comment">//文件系统信息</span><span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span>  <span class="comment">//打开文件信息</span><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span>  <span class="comment">//信号处理函数</span><span class="keyword">spinlock_t</span> sigmask_lock;<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span> <span class="comment">//信号处理函数</span><span class="keyword">sigset_t</span> blocked;  <span class="comment">//进程当前要阻塞的信号，每个信号对应一位</span><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span>  <span class="comment">//进程上是否有待处理的信号</span><span class="keyword">unsigned</span> <span class="keyword">long</span> sas_ss_sp;<span class="keyword">size_t</span> sas_ss_size;<span class="keyword">int</span> (*notifier)(<span class="keyword">void</span> *priv);<span class="keyword">void</span> *notifier_data;<span class="keyword">sigset_t</span> *notifier_mask;u32 parent_exec_id;u32 self_exec_id;<span class="keyword">spinlock_t</span> alloc_lock;<span class="keyword">void</span> *journal_info;};</code></pre><p></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、进程的调度算法&quot;&gt;&lt;a href=&quot;#一、进程的调度算法&quot; class=&quot;headerlink&quot; title=&quot;一、进程的调度算法&quot;&gt;&lt;/a&gt;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;一、进程的调度算法&lt;/font&gt;&lt;/h3&gt;&lt;p&gt;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;1.进程调度：多进程环境，望文生义，有多个进程同时进行,但具体到单个CPU级别，则在任何时刻只能有一个进程执行，因此操作系统需要决定哪个进程可以执行，哪个进程需要等待，而这就是进程调度。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="进程调度算法" scheme="http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
      <category term="task_struct结构体" scheme="http://yoursite.com/tags/task-struct%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>指针、数组、函数的“复杂关系</title>
    <link href="http://yoursite.com/2018/11/04/%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E2%80%9C%E5%A4%8D%E6%9D%82%E5%85%B3%E7%B3%BB/"/>
    <id>http://yoursite.com/2018/11/04/指针、数组、函数的“复杂关系/</id>
    <published>2018-11-04T13:41:32.000Z</published>
    <updated>2019-04-05T00:46:19.661Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、指针数组"><a href="#一、指针数组" class="headerlink" title="一、指针数组"></a><font color="black" size="4" face="微软雅黑">一、指针数组</font></h3><p><font color="black" size="4" face="微软雅黑">&emsp;①定义:</font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;指针数组:首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。<br><a id="more"></a></font></p><blockquote><p><font color="black" size="4" face="微软雅黑">例如：int <em> </em>p1[10]; 这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。int <em> </em>修饰数组的元素。</font></p></blockquote><p><font color="black" size="4" face="微软雅黑">&emsp;②应用:</font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;指针数组常用在主函数传参，在写主函数时，参数有两个，一个确定参数个数，一个这是指针数组用来接收每个参数（字符串）的地址。</font></p><blockquote><p><font color="black" size="4" face="Fira Code"><code>int main(int argc, char *argv[])</code></font></p></blockquote><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;子函数传参的时候，传递数组的首地址，应该用二级指针接收。</font></p><blockquote><p><font color="black" size="4" face="微软雅黑"><code>void fun(char **pp);//子函数中的形参fun(char *p[]);//主函数中的实参</code></font></p></blockquote><h3 id="二、数组指针"><a href="#二、数组指针" class="headerlink" title="二、数组指针"></a><font color="black" size="4" face="微软雅黑">二、数组指针</font></h3><p><font color="black" size="4" face="微软雅黑">&emsp;①定义  </font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;数组指针:首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，不能直接得出它指向的数组占多少字节。它是“指向数组的指针”的简称。</font></p><blockquote><p><font color="black" size="4" face="微软雅黑">例如：int (*p2)[10]; p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。int  修饰数组的内容。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">5</span>] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> (*p3)[<span class="number">5</span>] = &amp;a;</span><br><span class="line"><span class="keyword">char</span> (*p4)[<span class="number">5</span>] = a;<span class="comment">//左边的类型是指向整个数组的指针，右边的数据类型是指向单个字符的指针，会进行隐式的类型转换，将a 指针转换为指向整个数组的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p \n"</span>,a);<span class="comment">//数组首元素的地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p3);<span class="comment">//&amp;a 是整个数组的首地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p4);<span class="comment">//a是数组首元素的首地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, a + <span class="number">1</span>);<span class="comment">//跳过一个char 类型的字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p3 + <span class="number">1</span>);<span class="comment">//跳过一个指针数组的字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p4 + <span class="number">1</span>);<span class="comment">//转换后 + 1 会跳过一个指针数组的字节</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p></blockquote><p><img src="/img/TIM截图20181104214557.png" alt="这里写图片描述"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">5</span>]=&#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> (*p3)[<span class="number">10</span>] = &amp;a;</span><br><span class="line">    <span class="keyword">char</span> (*p4)[<span class="number">10</span>] = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p \n"</span>,a);<span class="comment">//数组首元素的地址</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p3);<span class="comment">//&amp;a 是整个数组的首地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p4);<span class="comment">//a是数组首元素的首地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, a + <span class="number">1</span>);<span class="comment">//跳过一个char 类型的字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p3 + <span class="number">1</span>);<span class="comment">//跳过一个指针数组的字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p \n"</span>, p4 + <span class="number">1</span>);<span class="comment">//转换后 + 1 会跳过一个指针数组的字节</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/img/TIM截图20181104214650.png" alt="这里写图片描述"></p><p><font color="black" size="4" face="微软雅黑">&emsp;④总结</font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;应用:数组指针是一个指针，可以用来接收一个二维数组的地址。</font></p><blockquote><p><font color="black" size="4" face="微软雅黑"><code>void fun(int (*P)[4]);//子函数中的形参，数组指针a[3][4] = {0};//主函数中定义的二维数组fun(a);//主函数调用子函数的实参，是二维数组的首元素首地址</code></font></p></blockquote><h3 id="三、函数指针"><a href="#三、函数指针" class="headerlink" title="三、函数指针"></a><font color="black" size="4" face="微软雅黑">三、函数指针</font></h3><p><font color="black" size="4" face="微软雅黑">&emsp;①定义</font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;函数指针:函数指针就是函数的指针。它是一个指针，指向一个函数。</font></p><blockquote><p><font color="black" size="4" face="微软雅黑">例如：void (*pfun1)(); </font></p></blockquote><p><font color="black" size="4" face="微软雅黑">&emsp;②应用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line">include &lt;asssert.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fun</span><span class="params">(<span class="keyword">char</span> * p1,<span class="keyword">char</span> * p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(p1 != <span class="literal">NULL</span>);</span><br><span class="line">    assert(p2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="built_in">strcmp</span>(p1, p2);<span class="comment">//字符串比较，若两者相等返回p1；否则返回 p2</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">char</span> * (*pf)(<span class="keyword">char</span> * p1, <span class="keyword">char</span> * p2);<span class="comment">//pf是一个指针，指向一个参数为两个 char *，返回类型为 char *的函数</span></span><br><span class="line"> pf = &amp;fun;<span class="comment">//将函数fun的地址赋给pf</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, (*pf) (<span class="string">"aa"</span>, <span class="string">"bb"</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><img src="/img/TIM截图20181104214739.png" alt="这里写图片描述"></p><hr><h3 id="四、函数指针数组"><a href="#四、函数指针数组" class="headerlink" title="四、函数指针数组"></a><font color="black" size="4" face="微软雅黑">四、函数指针数组</font></h3><p><font color="black" size="4" face="微软雅黑">&emsp;①定义</font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;函数指针数组:把函数的地址存到一个数组中，那这个数组就叫函数指针数组。</font></p><blockquote><p>例如：char <em> </em>(<em>pf[3])(char </em> *p); 它是一个数组，数组名为pf，数组内存储了3 个指向函数的指针。这些指针指向一些返回值类型为指向字符的指针、参数为一个指向字符的指针的函数。</p></blockquote><p><font color="black" size="4" face="微软雅黑">&emsp;②应用</font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;1.转移表实现计算器<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> input = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>(*p[<span class="number">5</span>])(<span class="keyword">int</span> x, <span class="keyword">int</span> y) = &#123; <span class="number">0</span>, Add, Sub, Mul, Div &#125;; <span class="comment">//转移表数组存放了不同子函数的地址</span></span><br><span class="line"><span class="keyword">while</span> (input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*************************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 1:Add             2:Sub \n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" 3:Mul             4:Div \n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*************************\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请选择："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;input);</span><br><span class="line"><span class="keyword">if</span> ((input &lt;= <span class="number">4</span> &amp;&amp; input &gt;= <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入操作数："</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">ret = (*p[input])(x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ret = %d\n"</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"输入有误\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><img src="/img/TIM截图20181104214833.png" alt="这里写图片描述"></p><p><font color="black" size="4" face="微软雅黑">&emsp;③总结</font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;作用:函数指针数组在子函数较多时可以通过不同的调用方法调用函数就来减少代码，使其更加简便。</font></p><h3 id="五、指向函数指针数组的指针"><a href="#五、指向函数指针数组的指针" class="headerlink" title="五、指向函数指针数组的指针"></a><font color="black" size="4" face="微软雅黑">五、指向函数指针数组的指针</font></h3><p><font color="black" size="4" face="微软雅黑">&emsp;①定义</font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;指向函数指针数组的指针:指向函数指针数组的指针是.一个指针，指针指向.一个 数组 ，数组的元素都是函数指针 。</font></p><blockquote><p>例如：char <em> (</em>(<em>pf)[3])(char </em> p); pf 是指针。这个指针指向一个包含了3 个元素的数组；这个数组里面存的是指向函数的指针；这些指针指向一些返回值类型为指向字符的指针、参数为一个指向字符的指针的函数。</p></blockquote><p><font color="black" size="4" face="微软雅黑">&emsp;②应用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fun1</span><span class="params">(<span class="keyword">char</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fun2</span><span class="params">(<span class="keyword">char</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">fun3</span><span class="params">(<span class="keyword">char</span> * p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">intmain()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> * (*a[<span class="number">3</span>])(<span class="keyword">char</span> * p);<span class="comment">//函数指针数组a</span></span><br><span class="line"><span class="keyword">char</span> * (*(*pf)[<span class="number">3</span>])(<span class="keyword">char</span> * p);<span class="comment">//指向函数指针数组的指针pf</span></span><br><span class="line">pf = &amp;a;</span><br><span class="line">a[<span class="number">0</span>] = fun1;<span class="comment">//函数名即函数地址</span></span><br><span class="line">a[<span class="number">1</span>] = &amp;fun2;</span><br><span class="line">a[<span class="number">2</span>] = &amp;fun3;</span><br><span class="line">pf[<span class="number">0</span>][<span class="number">0</span>](<span class="string">"fun1"</span>);</span><br><span class="line">pf[<span class="number">0</span>][<span class="number">1</span>](<span class="string">"fun2"</span>);</span><br><span class="line">pf[<span class="number">0</span>][<span class="number">2</span>](<span class="string">"fun3"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p><img src="/img/TIM截图20181104214858.png" alt="这里写图片描述"></p><p><font color="black" size="4" face="微软雅黑">&emsp;③总结</font></p><p><font color="black" size="4" face="微软雅黑">&emsp;&emsp;无论是指向函数指针数组的指针，还是其它的内容，都应该注意 * 和 [ ] 的结合，从而来辨清其概念。</font></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、指针数组&quot;&gt;&lt;a href=&quot;#一、指针数组&quot; class=&quot;headerlink&quot; title=&quot;一、指针数组&quot;&gt;&lt;/a&gt;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;一、指针数组&lt;/font&gt;&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;&amp;emsp;①定义:&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;&amp;emsp;&amp;emsp;指针数组:首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="指针数组" scheme="http://yoursite.com/tags/%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/"/>
    
      <category term="数组指针" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/"/>
    
      <category term="函数指针" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>模拟实现memcpy和memmove函数</title>
    <link href="http://yoursite.com/2018/11/01/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0memcpy%E5%92%8Cmemmove%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/11/01/模拟实现memcpy和memmove函数/</id>
    <published>2018-11-01T15:02:11.000Z</published>
    <updated>2019-04-04T12:04:00.216Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">使用C语言模拟实现库函数memcpy和memmove函数<br><a id="more"></a></font></p><h3 id="一、模拟memcpy"><a href="#一、模拟memcpy" class="headerlink" title="一、模拟memcpy"></a><font color="black" size="4" face="微软雅黑">一、模拟memcpy</font></h3><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">memcpy函数: memcpy函数的原型为：<code>void *memcpy(void *dest, void *src, unsigned int count);</code>是在不相关空间中进行的可以将指定字节数的内容拷贝到目标空间的C库函数。返回值为一个指针。可以说memcpy函数是memmove函数的一个子函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">my_memcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *sou, <span class="keyword">size_t</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">assert(sou != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">void</span> *ret = dst;<span class="comment">//用空类型来接收参数和返回参数</span></span><br><span class="line"><span class="keyword">while</span> (num--)</span><br><span class="line">&#123;</span><br><span class="line">*(<span class="keyword">char</span> *)dst = *(<span class="keyword">char</span> *)sou;<span class="comment">//因为不确定其参数类型，故将其强转为（char *）型用一个字节进行来计算</span></span><br><span class="line">dst = (<span class="keyword">char</span> *)dst + <span class="number">1</span>;</span><br><span class="line">sou = (<span class="keyword">char</span> *)sou + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"sbcdefghi"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"aabbcc"</span>;</span><br><span class="line"><span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(str2) / <span class="keyword">sizeof</span>(str2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *ret = my_memcpy(str1, str2, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s \n"</span>, str1);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><p>如图：<br><img src="/img/TIM截图20181101230554.png" alt="这里写图片描述"></p><h3 id="二、memmove"><a href="#二、memmove" class="headerlink" title="二、memmove"></a><font color="black" size="4" face="微软雅黑">二、memmove</font></h3><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">memcpy函数:memmove函数的原型为:<code>void *memmove( void* dest, const void* src, size_t count );</code>它和memcpy函数的区别即在于该函数可以实现内存重叠区域的内容拷贝，若目标区域和源区域没有重叠，则功能和memcpy函数相同。<br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">模拟实现图解：</font></font></p><blockquote><p>当目标区域的首地址小于原区域的首地址时</p></blockquote><p>  <img src="/img/TIM截图20181101230705.png" alt="这里写图片描述">     </p><blockquote><p>当目标区域的首地址大于原区域的首地址小于源区域的末地址时</p></blockquote><p><img src="/img/TIM截图20181101230740.png" alt="这里写图片描述"></p><blockquote><p>当目标区域首地址大于源区域整个空间时，无论是从前向后传值还是从后向前传值都可以<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">my_memmove</span><span class="params">(<span class="keyword">void</span> * dst, <span class="keyword">const</span> <span class="keyword">void</span> *sou, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">void</span>  *ret = dst;<span class="comment">//ret为空类型</span></span><br><span class="line">assert(dst != <span class="literal">NULL</span>);</span><br><span class="line">assert(sou != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dst &lt;= sou || (<span class="keyword">char</span> *)dst &gt;= ((<span class="keyword">char</span> *)sou + count))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (count--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从前向后拷贝</span></span><br><span class="line">*(<span class="keyword">char</span> *)dst = *(<span class="keyword">char</span> *)sou;<span class="comment">//一字节进行处理</span></span><br><span class="line">dst = (<span class="keyword">char</span> *)dst + <span class="number">1</span>;</span><br><span class="line">sou = (<span class="keyword">char</span> *)sou + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (count--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//从后向前拷贝</span></span><br><span class="line">*((<span class="keyword">char</span> *)dst + count) = *((<span class="keyword">char</span> *)sou + count);<span class="comment">//count--已经完成减一，在这儿一定不要再减一</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    my_memmove(arr + <span class="number">3</span>, arr ,<span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span> ));<span class="comment">//把arr[0]到arr[3]拷贝到arr[3]之后的内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" \n"</span>);</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="/img/TIM截图20181101230825.png" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;使用C语言模拟实现库函数memcpy和memmove函数&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="模拟实现库函数" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>几个经典的关于动态内存的面试题</title>
    <link href="http://yoursite.com/2018/10/28/%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/28/几个经典的关于动态内存的面试题/</id>
    <published>2018-10-28T13:25:21.000Z</published>
    <updated>2019-04-04T11:46:44.349Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">经典是传承不朽的！<br><a id="more"></a><br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">学习了几个经典的关于动态内存的面试题，分享一下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//局部变量，函数参数 p 存放在内存的栈区，用完销毁，</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(str);<span class="comment">//问题一、str指针变量，在函数传参时是值传递，即p是str的一份临时拷贝，当给 p 开辟空间后，返回Test函数，而空间已经在函数GetMemory运行完时被销毁了，</span></span><br><span class="line">               <span class="comment">//而且返回后对于str来说，并未开辟相应的空间，仍然是空指针</span></span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);<span class="comment">//问题二、内存泄漏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></font></p><p><font color="black" size="4" face="微软雅黑">修改后<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> **p)</span><span class="comment">//用二级指针来接收str的地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//给str 开辟空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(&amp;str);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(str);</span><br><span class="line">str = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">GetMemory</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> p[] = <span class="string">"hello world"</span>;<span class="comment">//问题一、局部数组，创建之后在函数运行完之后会销毁，</span></span><br><span class="line"><span class="keyword">return</span> p;<span class="comment">//返回栈空间的地址出错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">str = GetMemory();<span class="comment">//str野指针</span></span><br><span class="line"><span class="built_in">printf</span>(str);<span class="comment">//输出随机值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="black" size="4" face="微软雅黑">修改后<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">GetMemory</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* p = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">return</span> p;<span class="comment">//函数返回时先传递给寄存器，然后再赋给str</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* str = <span class="literal">NULL</span>;</span><br><span class="line">str = GetMemory();</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);<span class="comment">//问题：内存泄漏</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><font color="black" size="4" face="微软雅黑">修改后<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line">GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(str);</span><br><span class="line">str = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">free</span>(str);</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">NULL</span>)<span class="comment">//访问内存出错，str已经释放</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="black" size="4" face="微软雅黑">修改后<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(str);</span><br><span class="line">str = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;经典是传承不朽的！&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="动态内存" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>让面试官满意的代码——模拟实现简单库函数</title>
    <link href="http://yoursite.com/2018/10/26/%E8%AE%A9%E9%9D%A2%E8%AF%95%E5%AE%98%E6%BB%A1%E6%84%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/10/26/让面试官满意的代码——模拟实现简单库函数/</id>
    <published>2018-10-26T15:09:59.000Z</published>
    <updated>2019-04-04T12:52:20.419Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<font color="black" size="4" face="微软雅黑">关于C语言的库函数是面试官面试的热点问题，另一方面是对函数的了解另一方面也是对C语言的应用有所考察。<br><a id="more"></a></font></p><h3 id="一、模拟实现strlen"><a href="#一、模拟实现strlen" class="headerlink" title="一、模拟实现strlen"></a><font color="black" size="4" face="微软雅黑">一、模拟实现strlen</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一：设置计数器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(str != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (*str)</span><br><span class="line">&#123;</span><br><span class="line">str++;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二、不能创建临时变量计数器——递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(str != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*str == <span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + my_strlen(str + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三、指针 — 指针 即元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strlen</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(s != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *p = s;</span><br><span class="line"><span class="keyword">while</span> (*p != <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p - s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdef"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d \n"</span>, my_strlen(str));<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二、模拟实现strcpy"><a href="#二、模拟实现strcpy" class="headerlink" title="二、模拟实现strcpy"></a><font color="black" size="4" face="微软雅黑">二、模拟实现strcpy</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *start = target;</span><br><span class="line">assert(target != <span class="literal">NULL</span>);</span><br><span class="line">assert(source != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (*target++ = *source++)</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">10</span>] = <span class="string">"0"</span>;<span class="comment">//防止越界产生</span></span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">15</span>] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"str1: %s \n"</span>, my_strcpy(str1, str2));</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、模拟实现strcat"><a href="#三、模拟实现strcat" class="headerlink" title="三、模拟实现strcat"></a><font color="black" size="4" face="微软雅黑">三、模拟实现strcat</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strcat</span><span class="params">(<span class="keyword">char</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *start = target;</span><br><span class="line">assert(target != <span class="literal">NULL</span>);</span><br><span class="line">assert(source != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (*target)</span><br><span class="line">&#123;</span><br><span class="line">target++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (*target++ = *source++)</span><br><span class="line">&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">15</span>] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"ghijk"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"str1: %s \n"</span>, my_strcat(str1, str2));</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、模拟实现strstr"><a href="#四、模拟实现strstr" class="headerlink" title="四、模拟实现strstr"></a><font color="black" size="4" face="微软雅黑">四、模拟实现strstr</font></h3><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(str1);</span><br><span class="line">assert(str2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *cp = (<span class="keyword">char</span> *)str1;</span><br><span class="line"><span class="keyword">char</span> *substr = (<span class="keyword">char</span> *)str2;</span><br><span class="line"><span class="keyword">char</span> *s1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*str2 == <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (*cp)</span><br><span class="line">&#123;</span><br><span class="line">s1 = cp;</span><br><span class="line">substr = str2;</span><br><span class="line"><span class="keyword">while</span> (*s1 &amp;&amp; *substr &amp;&amp; (*s1 == *substr))</span><br><span class="line">&#123;</span><br><span class="line">s1++;</span><br><span class="line">substr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*substr == <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cp;</span><br><span class="line">&#125;</span><br><span class="line">cp++;</span><br><span class="line"><span class="keyword">if</span> (*cp == <span class="string">'\0'</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str1[] = <span class="string">"abbbcccdefgh"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> str2[] = <span class="string">"ghi"</span>;</span><br><span class="line"><span class="keyword">char</span> *ret = my_strstr(str1, str2);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" str2 不是 str1 的子字符串\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" str2 是 atr1 的从 %d 位开始的子字符串\n"</span>,ret - str1+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、模拟实现strchr"><a href="#五、模拟实现strchr" class="headerlink" title="五、模拟实现strchr"></a><font color="black" size="4" face="微软雅黑">五、模拟实现strchr</font></h3><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(str != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (*str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*(str++) == c)<span class="comment">//对实际地址进行了后置++操作</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> str - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdefdgh"</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *p = my_strchr(str, c);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == *p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %s 字符串中没有 %c 字符\n"</span>,str, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c 首次出现在 %s 的位置是：%d \n"</span>,c, str, p - str  + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、模拟实现strcpy"><a href="#六、模拟实现strcpy" class="headerlink" title="六、模拟实现strcpy"></a><font color="black" size="4" face="微软雅黑">六、模拟实现strcpy</font></h3><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(s1 != <span class="literal">NULL</span>);</span><br><span class="line">assert(s2 != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!(ret = *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s2) &amp;&amp; *s2)<span class="comment">// 用！操作符控制循环，将比较换为减法得到数值正负，</span></span><br><span class="line">&#123;</span><br><span class="line">++s1;</span><br><span class="line">++s2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"cd"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"ab"</span>;</span><br><span class="line"><span class="keyword">int</span> i = my_strcmp(str1, str2);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"str1 :%s 和 str2 :%s 相等\n"</span>,str1, str2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"str1:%s 大于 str2:%s \n"</span>,str1, str2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"str1:%s 小于 str2:%s \n"</span>, str1, str2);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;关于C语言的库函数是面试官面试的热点问题，另一方面是对函数的了解另一方面也是对C语言的应用有所考察。&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="模拟C库函数" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%8B%9FC%E5%BA%93%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Linux学习基础</title>
    <link href="http://yoursite.com/2018/10/25/Linux%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/10/25/Linux学习基础/</id>
    <published>2018-10-25T09:01:12.000Z</published>
    <updated>2019-04-04T13:23:55.561Z</updated>
    
    <content type="html"><![CDATA[<p><font color="black" size="4" face="微软雅黑">了解关于Linux系统的发展渊源，体悟开源的精神所在！<br><a id="more"></a></font></p><h3 id="一-基本命令"><a href="#一-基本命令" class="headerlink" title="一. 基本命令"></a><font color="black" size="4" face="微软雅黑">一. 基本命令</font></h3><p> <font color="black" size="4" face="微软雅黑">1.  ls指令</font></p><blockquote><p>语法：ls [选项] [目录或文件<br>功能：目录：该命令列出该目录下所有子目录与文件。<br>文件：列出文件名即其他信息<br>常用选项：<br>　　　　-a 列出目录下所有文件，包括以 . 开头的隐含文件.<br>　　　　-i 输出文件的 i 节点的索引信息。<br>　　　　-l 列出文件的详细信息。        </p></blockquote><p><font color="black" size="4" face="微软雅黑">02. pwd命令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：pwd<br>功能：显示用户当前所在目录     </p></blockquote><p><font color="black" size="4" face="微软雅黑">03. cd指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：cd 目录名<br>功能：改变工作目录， 将当前工作目录改变到指定目录下<br>举例：<br>　　cd .. ：返回上级目录<br>　　cd /home/xiaomoing/lunix/ ：绝对路径<br>　　cd ../day02/ :相对路径<br>　　cd ~:进入用户目录<br>　　cd -:返回最近访问目录</p></blockquote><p><font color="black" size="4" face="微软雅黑">04. touch指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法:touch [选项]…文件…<br>功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的文件<br>常用选项：<br>　　　　-d 使用指定的日期或时间。<br>　　　　-r 把指定文档或目录的日期时间，设定成和参考文档或目录的日期时间相同</p></blockquote><p><font color="black" size="4" face="微软雅黑">05. mkdir指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：mkdir [选项] dirname…<br>功能：在当前目录创建一个名为”diname” 的目录<br>常用选项:<br>　　　　-p –parents 可以是一个路径名称， 此时若路径上的某些目录不存在，系统可以一次建立多个目录</p></blockquote><p><font color="black" size="4" face="微软雅黑">06. rmdir指令 和 rm 指令<font color="black" size="4" face="微软雅黑">            </font></font></p><blockquote><p>语法：rmdir [-p][driName]<br>功能：删除空目录<br>常用选项：<br>　　　　　-p 当前子目录被删除后如果父目录为空，就连带删除父目录<br>语法：rm [-f-i-r-v][dirName/dir]<br>功能：删除文件或目录<br>常用选项：<br>　　　　-f 文件为只读时也可以删除<br>　　　　-i 删除前逐一询问确认<br>　　　　-r 删除目录及其下所有文件</p></blockquote><p><font color="black" size="4" face="微软雅黑">07. man指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：[选项] 命令<br>功能：访问Lunix手册<br>常用选项：<br>　　　　-k 根据关键字搜索联机帮助<br>　　　　-a 将所有的章节都显示出来</p></blockquote><p><font color="black" size="4" face="微软雅黑">08. cp指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：cp [选项] 源文件或目录 目标文件或目录<br>功能：复制文件或目录<br>说明：cp指令用于复制文件或目录， 如同时指定两个以上的文件或目录， 且最后的目的地是一个已经存在的目录， 则它会把前面指定的所有文件或目录复制到此目录中，若不存在，则会显示错误信息。<br>常用选项：<br>　　　　-f 强制复目录或文件， 不论文件或目录是否存在<br>　　　　-i 覆盖文件之前询问用户<br>　　　　-r 递归处理，将指定目录下的文件与子目录一并处理<br>　　　　-R 递归处理</p></blockquote><p><font color="black" size="4" face="微软雅黑">09. mv指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：mv [选项] 源文件或目录 目标文件或目录<br>功能：视命令中第二个参数类型的不同（是目标文件还是目标目录），MV命令将文件重命名或将其移入一个新的目录中。<br>当第二个参数类型是文件时，完成文件重命名。<br>当第二个参数类型是已存在的目录时，源文件或目录参数可以有多个，mv命令将各参数指定的文件均移动到目标目录中。<br>常用选项：<br>　　　　-f 如果目标文件已经存在，直接覆盖不会询问<br>　　　　-i 若目标文件已经存在，会询问是否覆盖</p></blockquote><p><font color="black" size="4" face="微软雅黑">10. cat/tac指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：cat [选项][文件]<br>功能：查看目标文件的内容<br>常用选项：<br>　　　　-b 对非空输出行编号<br>　　　　-n 对输出的所有行进行编号<br>　　　　-s 不输出多行空行</p></blockquote><p><font color="black" size="4" face="微软雅黑">11. more指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：more [选项][文件]<br>功能：功能类似cat<br>常用选项：<br>　　　　-n 对输出所有行进行编号<br>　　　　ｑ　退出more</p></blockquote><p><font color="black" size="4" face="微软雅黑">12. less指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：less [参数] 文件<br>功能：使用less可以随意浏览文件，且在查看前不会加载整个文件<br>常用选项：<br>　　　　-i 忽略搜索时的大小写<br>　　　　-N 显示每行的行号<br>　　　　/字符串 向下搜索“字符串”的功能<br>　　　　?字符串 向上搜索“字符串”的功能<br>　　　　n: 重复前一个搜索</p></blockquote><p><font color="black" size="4" face="微软雅黑">13. head指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：head [参数]…[文件]…<br>功能：显示档案的开头至标准输出中，默认打印开头10行<br>选项：<br>　　　-n&lt;行数&gt; 显示的行数</p></blockquote><p><font color="black" size="4" face="微软雅黑">14. tail指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：tail [必要参数][选择参数][文件]<br>功能：显示指定文件末尾内容，不指定文件时作为输入信息进行处理，从指定点开始将文件写入标准输出，<br>选项：<br>　　-f 循环读数<br>　　-n&lt;行数&gt; 显示行数    </p></blockquote><p><font color="black" size="4" face="微软雅黑">15. Cal指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：cal [参数][月份][年份]<br>功能：用于查看日历<br>常用选项：<br>　　　　-3 显示系统的前一个月，当前月，下一个月的日历<br>　　　　-j 显示当年的第几天<br>　　　　-y 显示当前年份的日历</p></blockquote><p><font color="black" size="4" face="微软雅黑">16. find指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：find pathname ~options<br>功能：用于在文件树查找文件，并作出相应的处理<br>选项：-name 按照文件名查找文件</p></blockquote><p><font color="black" size="4" face="微软雅黑">17. grep指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：gre [选项]搜寻字符串 文件<br>功能：在文件中搜索字符串，将找到的行打印出来<br>常用选项：<br>　　　　-i 忽略大小写的不同<br>　　　　-n 输出行号<br>　　　　-v 反向选择， 显示出没有“搜寻字符串”内容的那一行</p></blockquote><p><font color="black" size="4" face="微软雅黑">18. zip/unzip指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：zip 压缩文件.zip 目录或文件<br>功能：将目录或文件压缩成zip格式<br>常用选项：<br>　　　　-r 递归处理,将指定目录下所有的文件与子目录一并处理</p></blockquote><p><font color="black" size="4" face="微软雅黑">19. tar指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：tar [选项]文件与目录…参数…<br>功能：打包/解包，不打开它，直接看内容<br>常用选项：<br>　　　　-c 建立一个压缩文件的参数指令<br>　　　　-x 解开一个压缩文件的参数指令<br>　　　　-z 是否同时具有gzip的属性？<br>　　　　-f 使用档名，请留意，在f之后要立即接档名，不要加参数</p></blockquote><p><font color="black" size="4" face="微软雅黑">20. uname指令<font color="black" size="4" face="微软雅黑"></font></font></p><blockquote><p>语法：uname [选项]<br>功能：获取电脑和操作系统的相关信息<br>常用选项：<br>　　　　-a 或-all 详细输出所有信息        </p></blockquote><h3 id="二-进入目录需要哪些权限-在目录中执行增删查-cd-touch-ls-rm-mv等-改文件动作-需要哪些权限"><a href="#二-进入目录需要哪些权限-在目录中执行增删查-cd-touch-ls-rm-mv等-改文件动作-需要哪些权限" class="headerlink" title="二. 进入目录需要哪些权限, 在目录中执行增删查(cd, touch, ls, rm, mv等)改文件动作, 需要哪些权限."></a><font color="black" size="4" face="微软雅黑">二. 进入目录需要哪些权限, 在目录中执行增删查(cd, touch, ls, rm, mv等)改文件动作, 需要哪些权限.</font></h3><ul><li><p><font color="black" size="4" face="微软雅黑">Linux中的基本权限（r、w、x）</font></p><pre><code>1、读（r/4）：read对于文件来说，具有读取文件内容的权限；对于目录来说，具有浏览该目录信息的权限。2、写（w/2）：write对于文件来说，具有修改文件内容的权限；对于目录来说，具有删除、移动目录内文件的权限。3、执行（x/1）；execute对于文件来说，具有执行文件的权限；对于目录来说，具有进入目录的权限。</code></pre></li><li><p><font color="black" size="4" face="微软雅黑">文件权限值的表示方法<br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">a)字符表示方法<br><img src="/img/20181025.png" alt=""><br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">b)8进制数值表示方法<br><img src="/img/20181028.png" alt=""></font></font></font></p></li><li><font color="black" size="4" face="微软雅黑">修改权限的方法<br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">chmod:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">chmod [参数] 权限 文件名</font></font></font></li><li><font color="black" size="4" face="微软雅黑">设置文件的访问权限<br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(1). 用户表示符 +/-=权限字符<br><img src="/img/20181026134101.png" alt=""><br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(2).3位8进制数字<br><img src="/img/20180812223457532.png" alt=""></font></font></font></li><li><p><font color="black" size="4" face="微软雅黑">进入目录需要哪些权限, 在目录中执行增删查(cd, touch, ls, rm, mv等)改文件动作, 需要哪些权限？</font></p><pre><code>cd：a.语法 cd 目录名（进入目录）            b.所需权限xtouch：a.语法 touch 文件名（创建文件）      b.所需权限wxls：a.语法 ls （显示当前目录下的所有文件）   b.所需权限rxrm：a.语法 rm 文件名（删除文件）            b.所需权限wxmv：a.语法 mv 文件名1  文件名2（把文件名1修改为文件名2）      b.所需权限wx</code></pre></li></ul><h3 id="三-Linux下的重要目录-proc-sys-SElinux-bin-usr-lib-usr-local-var-tmp"><a href="#三-Linux下的重要目录-proc-sys-SElinux-bin-usr-lib-usr-local-var-tmp" class="headerlink" title="三. Linux下的重要目录/proc, /sys, /SElinux, /bin, /usr/lib, /usr/local, /var, /tmp"></a><font color="black" size="4" face="微软雅黑">三. Linux下的重要目录/proc, /sys, /SElinux, /bin, /usr/lib, /usr/local, /var, /tmp</font></h3><ul><li><font color="black" size="4" face="微软雅黑">/proc:特殊文件目录。这个目录采用一种特殊的文件格式（proc格式，内核支持这种格式。其中包括了全部虚拟文件。它们并不是保存在磁盘中，也不占用磁盘空间，当查看它们时，实际上看到的是内存里的信息，这些文件有助于我们了解系统内部信息）。</font></li><li><font color="black" size="4" face="微软雅黑">/sys: 文件系统访问 Linux内核</font></li><li><font color="black" size="4" face="微软雅黑">/SElinux:SELinux是一种基于域-类型模型(domain-type)的强制访问控制(MAC)安全系统，它由NSA编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了SELinux的补丁，最后还有一个相应的安全策略</font></li><li><font color="black" size="4" face="微软雅黑">/usr/lib:/usr/local/lib： 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules</font></li><li><font color="black" size="4" face="微软雅黑">/usr/local:存放软件升级包</font></li><li><font color="black" size="4" face="微软雅黑">/var:内容经常变化的目录。此目录下文件的大小可能改变，如缓冲文件、日志文件、缓存文件等一般会放在这里</font></li><li><font color="black" size="4" face="微软雅黑">/tmp:一般用户或正在执行的程序临时存放文件的目录即临时文件,任何人都可以访问,重要数据不可放置在此目录下</font></li></ul><h3 id="四-重要命令-du-df-top-free-pstack-su-sudo-sudo-sudo-s-adduser-password"><a href="#四-重要命令-du-df-top-free-pstack-su-sudo-sudo-sudo-s-adduser-password" class="headerlink" title="四. 重要命令. du, df, top, free, pstack, su, sudo(sudo -, sudo -s), adduser, password"></a><font color="black" size="4" face="微软雅黑">四. 重要命令. du, df, top, free, pstack, su, sudo(sudo -, sudo -s), adduser, password</font></h3><ul><li><font color="black" size="4" face="微软雅黑">du 作用是磁盘空间使用情况，功能是逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块的情况，如果没有指定目录，则对当前的目录进行统计。<br>主要参数：<br>　　　　s：只显示各档案大小的总合<br>　　　　b：大小用bytes来表示<br>　　　　x：跳过在不同文件系统上的目录不予统计<br>　　　　a：递归地显示指定目录中各文件及子孙目录中各文件占用的数据块数</font></li><li><p><font color="black" size="4" face="微软雅黑">df 命令用来检查文件系统的磁盘空间占用情况，使用权限是所有用户。<br>主要参数：<br>　　　　　－s：对每个Names参数只给出占用的数据块总数。<br>　　　　　－a：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定－s，也不指定－a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。<br>　　　　　－k：以1024字节为单位列出磁盘空间使用情况。<br>　　　　　－x：跳过在不同文件系统上的目录不予统计。<br>　　　　　－l：计算所有的文件大小，对硬链接文件则计算多次。<br>　　　　　－i：显示inode信息而非块使用量。<br>　　　　　－h：以容易理解的格式印出文件系统大小，例如136KB、254MB、21GB。<br>　　　　　－P：使用POSIX输出格式。<br>　　　　　－T：显示文件系统类型</font></p></li><li><p><font color="black" size="4" face="微软雅黑">top 基本格式df [options]<br>作用:命令用来显示执行中的程序进程，使用权限是所有用户<br>主要参数：<br>　　　　d：指定更新的间隔，以秒计算。<br>　　　　q：没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行。<br>　　　　c：显示进程完整的路径与名称。<br>　　　　S：累积模式，会将己完成或消失的子行程的CPU时间累积起来。<br>　　　　s：安全模式。<br>　　　　i：不显示任何闲置(Idle)或无用(Zombie)的行程。<br>　　　　n：显示更新的次数，完成后将会退出top。</font></p></li><li><font color="black" size="4" face="微软雅黑">free 格式free [－b|－k|－m] [－o] [－s delay] [－t] [－V]<br>作用:free命令用来显示内存的使用情况，使用权限是所有用户。<br>主要参数：<br>　　　　－b －k －m：分别以字节（KB、MB）为单位显示内存使用情况。<br>　　　　－s delay：显示每隔多少秒数来显示一次内存使用情况。<br>　　　　－t：显示内存总和列。<br>　　　　－o：不显示缓冲区调节列。</font></li><li><font color="black" size="4" face="微软雅黑">pstack:显示每个进程的栈跟踪<br>pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。</font></li><li><font color="black" size="4" face="微软雅黑">su 格式 su [选项]… [-] [USER [ARG]…]<br>作用是变更为其它使用者的身份，超级用户除外，需要键入该使用者的密码。<br>主要参数：<br>　　　　-f ， –fast：不必读启动文件（如 csh.cshrc 等），仅用于csh或tcsh两种Shell。<br>　　　　-l ， –login：加了这个参数之后，就好像是重新登陆为该使用者一样，大部分环境变量（例如HOME、SHELL和USER等）都是以该使用者（USER）为主，并且工作目录也会改变。如果没有指定USER，缺省情况是root。<br>　　　　-m， -p ，–preserve-environment：执行su时不改变环境变数。<br>　　　　-c command：变更账号为USER的使用者，并执行指令（command）后再变回原来使用者。<br>　　　　USER：欲变更的使用者账号，ARG传入新的Shell参数。</font></li><li>sudo(sudo -, sudo -s)<br><font color="black" size="4" face="微软雅黑">命令的配置在/etc/sudoers文件中。当用户使用sudo时，需要输入口令以验证使用者身份。随后的一段时间内可以使用定义好的命令，当使用配置文件中没有的命令时，将会有报警的记录。sudo是系统管理员用来允许某些用户以root身份运行部分/全部系统命令的程序。一个明显的用途是增强了站点的安全性，如果需要每天以超级用户的身份做一些日常工作，经常执行一些固定的几个只有超级用户身份才能执行的命令，那么用sudo是非常适合的。  pstack 命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。</font></li><li><font color="black" size="4" face="微软雅黑">adduser<br><font color="black" size="4" face="微软雅黑">（1）创建用户命令两条：<br>　　　　　　　　　　　adduser<br>　　　　　　　　　　　useradd<br><font color="black" size="4" face="微软雅黑">（2）用户删除命令：<br>　　　　　　　　　userdel<br><font color="black" size="4" face="微软雅黑">两个用户创建命令之间的区别：<br>　　　　　　　　　　　　　<font color="black" size="4" face="微软雅黑">adduser： 会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。<br>　　　　　　　　　　　　　<font color="black" size="4" face="微软雅黑">useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。</font></font></font></font></font></font></li><li><font color="black" size="4" face="微软雅黑">password:登陆密码管理<br><font color="black" size="4" face="微软雅黑">passwd 作为普通用户和超级权限用户都可以运行，但作为普通用户只能更改自己的用户密码，但前提是没有被root用户锁定；如果root用户运行passwd ，可以设置或修改任何用户的密码；<br>主要参数：<br>　　　　-d：删除密码，仅有系统管理者才能使用；<br>　　　　-f：强制执行；<br>　　　　-k：设置只有在密码过期失效后，方能更新；<br>　　　　-l：锁住密码；<br>　　　　-s：列出密码的相关信息，仅有系统管理者才能使用；<br>　　　　-u：解开已上锁的帐号。</font></font></li></ul><h3 id="五-如何使用命令安装gcc-g-gdb-vim"><a href="#五-如何使用命令安装gcc-g-gdb-vim" class="headerlink" title="五. 如何使用命令安装gcc/g++, gdb, vim"></a><font color="black" size="4" face="微软雅黑">五. 如何使用命令安装gcc/g++, gdb, vim</font></h3><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">vim是Linux下的编辑器，linux中使用gcc来编译C程序，使用g++来编译C++程序，使用gdb来调试程序<br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(1).vim<br>安装完Centos 后，默认是安装了Vi编辑器的。但Vim编辑器是没安装或者未完全安装的。<br>&emsp;&emsp;&emsp;&emsp;1）首先，检测是否已经安装过Vim;</font></font></p><blockquote><p>输入命令：rpm -qa|grep vim</p></blockquote><p><img src="/img/TIM截图20181026134634.png" alt=""></p><blockquote><p>显示出完整的包名： vim-common,vim-enhanced,vim-minimal,vim-filesystem 表示安装成功，有的centos系统，默认包名不同。</p></blockquote><p>&emsp;&emsp;&emsp;&emsp;2）若是缺少Vim包名：则在root下使用命令如下：</p><blockquote><p>比如说： vim-minimal这个包少了，执行：yum -y install vim-minimal 命令，它会自动下载安装。</p></blockquote><p>&emsp;&emsp;&emsp;&emsp;3）若下载完成，进行安装：</p><blockquote><p>命令：yum -y install vim<font color="black" size="4" face="微软雅黑"> 安装完成后则可以使用vim编辑器</font></p></blockquote><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(2).gcc/g++<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<font color="black" size="4" face="微软雅黑">Centos中使用yum来配置gcc和g++，在root账户下，若要安装gcc，则在命令行中输入:yum -y install gcc，按回车键就能够进行gcc的安装;若要安装g++，则需要在命令行中输入：yum -y install gcc-c++，就能够进行g++的安装。<br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">(3).gdb</font></font></font></p><blockquote><p>先使用如下命令看系统中是否安装了gdb，如果安装了，如下图</p></blockquote><p><img src="/img/TIM截图20181026134729.png" alt="">s</p><blockquote><p>如果没有安装，则Centos中使用yum来安装gdb,在root账户下，在命令行中输入：yum install gdb，使用：which gdb 查看是否安装成功</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;了解关于Linux系统的发展渊源，体悟开源的精神所在！&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://yoursite.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
      <category term="重要目录" scheme="http://yoursite.com/tags/%E9%87%8D%E8%A6%81%E7%9B%AE%E5%BD%95/"/>
    
      <category term="GCC/G++等安装" scheme="http://yoursite.com/tags/GCC-G-%E7%AD%89%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>栈应用及迷宫问题</title>
    <link href="http://yoursite.com/2018/10/24/%E6%A0%88%E5%BA%94%E7%94%A8%E5%8F%8A%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/24/栈应用及迷宫问题/</id>
    <published>2018-10-24T10:22:15.000Z</published>
    <updated>2019-04-04T13:21:19.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a><font color="black" size="4" face="微软雅黑"><font color="black" size="4" face="微软雅黑">一、栈</font></font></h3><ul><li><font color="black" size="4" face="微软雅黑"> 栈是一种重要的线性结构，在数据结构而言，其本质操作是线性表操作的子集。但在数据类型来说，是一种重要的抽象数据类型。在面向对象的程序设计中，栈是多数据类型。<a id="more"></a></font></li><li><font color="black" size="4" face="微软雅黑">栈只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。不含任何元素的栈称为空栈，栈又称为后进先出的线性表，简称LIFO结构。栈可以将数据从一种序列变到另一种序列。</font></li></ul><hr><h3 id="二、栈的分类"><a href="#二、栈的分类" class="headerlink" title="二、栈的分类"></a><font color="black" size="4" face="微软雅黑">二、栈的分类</font></h3><ul><li><font color="black" size="4" face="微软雅黑">顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，一般使用过程中所需的最大空间，故先给栈分配一个基本容量，在使用过程中然后增容。</font></li><li><font color="black" size="4" face="微软雅黑">链式栈，是一种不连续的存储结构，元素以Node的形式存储，包含数据域和指针域，指针域指向下一个节点，每个节点随机分布，为动态开辟节点。<br></font></li></ul><hr><h3 id="三、栈的基本模块"><a href="#三、栈的基本模块" class="headerlink" title="三、栈的基本模块"></a><font color="black" size="4" face="微软雅黑">三、栈的基本模块</font></h3><font color="black" size="4" face="微软雅黑">无论是链式栈还是顺序栈其基本操作都一样，包含栈的创建，初始化，销毁，插入，删除，取栈顶元素等，只是其实现方式不同。下面就是顺序栈的模块。<br><font color="green" size="4" face="宋体">头文件”Stack.h”<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//typedef int DataType;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//#define N 10</span></span><br><span class="line"><span class="comment">//typedef struct Stack</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//DataType _a[N];//规定数组空间大小</span></span><br><span class="line"><span class="comment">//int _top; // 栈顶</span></span><br><span class="line"><span class="comment">//&#125;Stack;//静态栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Pos</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> _row;</span><br><span class="line"><span class="keyword">int</span> _col;</span><br><span class="line">&#125;Pos;<span class="comment">//迷宫位置点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Pos DataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DataType* _a;<span class="comment">//节点指针</span></span><br><span class="line"><span class="keyword">int</span> _top;<span class="comment">// 栈顶</span></span><br><span class="line"><span class="keyword">int</span> _capacity;  <span class="comment">// 容量</span></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInit</span><span class="params">(Stack* ps)</span></span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackDestory</span><span class="params">(Stack* ps)</span></span>;<span class="comment">//销毁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(Stack* ps, DataType x)</span></span>;<span class="comment">//压栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(Stack* ps)</span></span>;<span class="comment">//出栈</span></span><br><span class="line"><span class="function">DataType <span class="title">StackTop</span><span class="params">(Stack* ps)</span></span>;<span class="comment">//取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(Stack* ps)</span></span>;<span class="comment">//判空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackSize</span><span class="params">(Stack* ps)</span></span>;<span class="comment">//栈的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void TestStack();</span></span><br></pre></td></tr></table></figure><br><br><font color="green" size="4" face="宋体">函数文件”Stack.c”<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackInit</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ps-&gt;_a = (DataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DataType)* <span class="number">3</span>);<span class="comment">//动态开辟空间</span></span><br><span class="line">assert(ps);<span class="comment">//防止开辟失败</span></span><br><span class="line">ps-&gt;_capacity = <span class="number">3</span>;</span><br><span class="line">ps-&gt;_top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackDestory</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);<span class="comment">//断言</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ps-&gt;_a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(ps-&gt;_a);</span><br><span class="line">ps-&gt;_a = <span class="literal">NULL</span>;</span><br><span class="line">ps-&gt;_capacity = ps-&gt;_top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (ps-&gt;_top--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(ps-&gt;_top);</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;_capacity = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPush</span><span class="params">(Stack* ps, DataType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ps-&gt;_top == ps-&gt;_capacity)<span class="comment">//越界</span></span><br><span class="line">&#123;</span><br><span class="line">ps-&gt;_a = (DataType*)<span class="built_in">realloc</span>(ps-&gt;_a, <span class="keyword">sizeof</span>(DataType)*(ps-&gt;_capacity * <span class="number">2</span>));<span class="comment">//增容</span></span><br><span class="line">assert(ps-&gt;_a);</span><br><span class="line"></span><br><span class="line">ps-&gt;_capacity *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">ps-&gt;_a[ps-&gt;_top] = x;</span><br><span class="line">ps-&gt;_top++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StackPop</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps-&gt;_a);</span><br><span class="line">assert(ps-&gt;_top &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ps-&gt;_top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DataType <span class="title">StackTop</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps-&gt;_a &amp;&amp; ps-&gt;_top &gt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> ps-&gt;_a[ps-&gt;_top - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//空 0</span></span><br><span class="line"><span class="comment">//非空 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ps-&gt;_top == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackSize</span><span class="params">(Stack* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(ps);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ps-&gt;_top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//void TestStack()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//Stack s;</span></span><br><span class="line"><span class="comment">//StackInit(&amp;s);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//StackPush(&amp;s, 1);</span></span><br><span class="line"><span class="comment">//StackPush(&amp;s, 2);</span></span><br><span class="line"><span class="comment">//StackPush(&amp;s, 3);</span></span><br><span class="line"><span class="comment">//StackPush(&amp;s, 4);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//while (StackEmpty(&amp;s))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf("%d ",StackTop(&amp;s));</span></span><br><span class="line"><span class="comment">//StackPop(&amp;s);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//printf("\n");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//StackDestory(&amp;s);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><br><br></font><hr><h3 id="四、迷宫"><a href="#四、迷宫" class="headerlink" title="四、迷宫"></a><font color="black" size="4" face="微软雅黑">四、迷宫</font></h3><ul><li><font color="black" size="4" face="微软雅黑">迷宫问题，望文生义就是在迷宫当中找到出口，出入口自定义，解决迷宫问题的过程中以回溯法为思想，应用栈的知识来解决这个问题。对于迷宫问题的思考是由解决简单的迷宫然后到环路迷宫这样一个过程的。</font></li></ul><ul><li><font color="blue" size="4" face="微软雅黑">回溯法：<font color="black" size="4" face="微软雅黑">对一个包括有很多个结点，<font color="blue" size="4" face="微软雅黑">每个结点有若干个搜索分支的问题，<font color="black" size="4" face="微软雅黑">把原问题分解为若干个子问题进行求解的算法；<font color="blue" size="4" face="微软雅黑">当搜索到某个结点发现无法再继续搜索下去时，就让搜索过程回溯到该结点的前一个结点，继续搜索该结点外的其他尚未搜索的分支；如果发现该结点无法再搜索下去，就让搜索过程回溯到这个结点的前一个结点继续这样的搜索过程。</font></font></font></font></font></li></ul><blockquote><p><font color="black" size="4" face="微软雅黑">1.简单迷宫——–从出口处将开始进行压栈，判断其上，下，左，右方向是否可走，若某个方向可走将其坐标进行压栈，并将坐标上的值置为2，再探测该坐标的分支，直到出口，返回1即找到出口，若在某一个结点处四个方向均不可走则返回上一个坐标，并将该坐标从栈中释放，若栈为空时仍未到出口处则返回0即未找到出口。<br>0 0 0 0 0 0<br>0 0 1 0 0 0<br>0 0 1 0 0 0<br>0 0 1 1 1 0<br>0 0 1 0 1 1<br>0 0 1 0 0 0</font></p></blockquote><blockquote><p><font color="black" size="4" face="微软雅黑">2.多路迷宫——–在简单迷宫的基础上当找到出口时并不返回值，当栈为空即回溯到出口时返回到主函数。<br>0 0 0 0 0 0<br>0 0 1 0 0 0<br>0 0 1 1 1  1<br>0 0 1 0 0 0<br>0 0 1 1 1 1<br>0 0 1 0 0 0</font></p></blockquote><blockquote><p><font color="black" size="4" face="微软雅黑">3.环路迷宫——–在多路迷宫的基础上，在设置压入栈的坐标的值时换为前一个坐标的值加1,即递增的。在判断某个坐标是否可走时变换条件，进而达到目的。<br>0 0 0 0 0 0<br>0 0 1 1 1 0<br>0 0 1 0 1  0<br>0 0 1 0 1 0<br>0 0 1 1 1 1<br>0 0 1 0 0 0</font></p></blockquote><p><font color="navy" size="5" face="微软雅黑">环路迷宫</font></p><p><font color="green" size="4" face="宋体">头文件”maze.h”</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"Stack.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> maze[N][N] = &#123;<span class="comment">//static,只在maze.c中可见</span></span><br><span class="line"><span class="comment">/*&#123; 0, 0, 0, 0, 0, 0 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 1, 1, 1 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 0, 0, 0 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 0, 0, 0 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 1, 1, 1 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 0, 0, 0 &#125;,*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*&#123; 0, 0, 0, 0, 0, 0 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 1, 1, 0 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 0, 1, 0 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 0, 1, 0 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 1, 1, 1 &#125;,</span></span><br><span class="line"><span class="comment">&#123; 0, 0, 1, 0, 0, 0 &#125;,*/</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMazePath</span><span class="params">(Pos entry, Pos <span class="built_in">exit</span>)</span></span>;<span class="comment">//获取迷宫通路:找到通路/找不到通路</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CheckAccess</span><span class="params">(Pos cur, Pos next)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfMaze</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestMaze</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><font color="green" size="4" face="宋体">函数文件”maze.c”</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"Maze.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CheckAccess</span><span class="params">(Pos cur, Pos next)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (next._row &gt;= <span class="number">0</span> &amp;&amp; next._row &lt; N</span><br><span class="line">&amp;&amp;next._col &gt;= <span class="number">0</span> &amp;&amp; next._col &lt; N</span><br><span class="line">&amp;&amp; (maze[next._row][next._col] == <span class="number">1</span> || maze[next._row][next._col] &gt; maze[cur._row][cur._col] + <span class="number">1</span>))<span class="comment">//当下一个坐标的值为1 或者比当前值加一还大就可以走</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetMazePath</span><span class="params">(Pos entry, Pos <span class="built_in">exit</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack path;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">StackInit(&amp;path);</span><br><span class="line">StackPush(&amp;path, entry);</span><br><span class="line">maze[entry._row][entry._col] = <span class="number">2</span>;<span class="comment">//入口初始化为2</span></span><br><span class="line"><span class="keyword">while</span> (StackEmpty(&amp;path))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Pos cur = entry;//当前位置</span></span><br><span class="line">Pos cur = StackTop(&amp;path);<span class="comment">//栈顶取出的当前位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//if (cur._col == 5)//多条通路</span></span><br><span class="line"><span class="keyword">if</span> (cur._row == <span class="built_in">exit</span>._row</span><br><span class="line">&amp;&amp;cur._col == <span class="built_in">exit</span>._col)<span class="comment">//当一条路径找到出口时，打印路径并且看路径长短</span></span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path._top; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[%d %d]-&gt;"</span>, path._a[i]._row, path._a[i]._col);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Exit\n\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span> || StackSize(&amp;path) &lt; size)</span><br><span class="line">&#123;</span><br><span class="line">size = StackSize(&amp;path);<span class="comment">//路径的长短</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Pos next;</span><br><span class="line"><span class="comment">//上</span></span><br><span class="line">next = cur;<span class="comment">//当前位置</span></span><br><span class="line">next._row -= <span class="number">1</span>;<span class="comment">//下一个位置</span></span><br><span class="line"><span class="keyword">if</span> (CheckAccess(cur, next))</span><br><span class="line">&#123;</span><br><span class="line">maze[next._row][next._col] = maze[cur._row][cur._col] + <span class="number">1</span>;</span><br><span class="line">StackPush(&amp;path, next);<span class="comment">//下一个位置可以通，入栈</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下</span></span><br><span class="line">next = cur;</span><br><span class="line">next._row += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (CheckAccess(cur, next))</span><br><span class="line">&#123;</span><br><span class="line">maze[next._row][next._col] = maze[cur._row][cur._col] + <span class="number">1</span>;</span><br><span class="line">StackPush(&amp;path, next);<span class="comment">//下一个位置可以通，入栈</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左</span></span><br><span class="line">next = cur;</span><br><span class="line">next._col -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (CheckAccess(cur, next))</span><br><span class="line">&#123;</span><br><span class="line">maze[next._row][next._col] = maze[cur._row][cur._col] + <span class="number">1</span>;</span><br><span class="line">StackPush(&amp;path, next);<span class="comment">//下一个位置可以通，入栈</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右</span></span><br><span class="line">next = cur;</span><br><span class="line">next._col += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (CheckAccess(cur, next))</span><br><span class="line">&#123;</span><br><span class="line">maze[next._row][next._col] = maze[cur._row][cur._col] + <span class="number">1</span>;</span><br><span class="line">StackPush(&amp;path, next);<span class="comment">//下一个位置可以通，入栈</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//走到四个方向不通的位置</span></span><br><span class="line"><span class="comment">//回溯</span></span><br><span class="line">StackPop(&amp;path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)<span class="comment">//判断是否找到出口</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfMaze</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, maze[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="green" size="4" face="微软雅黑">主函数文件”main.c”</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"maze.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestMaze</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Pos entry;</span><br><span class="line">entry._row = <span class="number">5</span>;</span><br><span class="line">entry._col = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Pos <span class="built_in">exit</span>;</span><br><span class="line"><span class="built_in">exit</span>._row = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">exit</span>._col = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"迷宫地图:\n"</span>);</span><br><span class="line">PrintfMaze();</span><br><span class="line"><span class="keyword">if</span> (GetMazePath(entry, <span class="built_in">exit</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"有出口，最短路径为：%d \n\n"</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"无出口！\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"走出后迷宫地图:\n"</span>);</span><br><span class="line">PrintfMaze();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TestMaze();</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font><h3 id="五、运行结果"><a href="#五、运行结果" class="headerlink" title="五、运行结果"></a><font color="black" size="4" face="微软雅黑">五、运行结果</font></h3><p> <font color="black" size="4" face="微软雅黑">1.简单迷宫<br> <img src="/img/TIM截图20181026135127.png" alt="在这里插入图片描述"></font></p><p><font color="black" size="4" face="微软雅黑">2.多路迷宫<br><img src="/img/TIM截图20181026135302.png" alt="在这里插入图片描述"></font></p><p><font color="black" size="4" face="微软雅黑">3.环路迷宫<br><img src="/img/TIM截图20181026135343.png" alt="在这里插入图片描述"></font></p></font></font></font>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、栈&quot;&gt;&lt;a href=&quot;#一、栈&quot; class=&quot;headerlink&quot; title=&quot;一、栈&quot;&gt;&lt;/a&gt;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;一、栈&lt;/font&gt;&lt;/font&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt; 栈是一种重要的线性结构，在数据结构而言，其本质操作是线性表操作的子集。但在数据类型来说，是一种重要的抽象数据类型。在面向对象的程序设计中，栈是多数据类型。
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="栈" scheme="http://yoursite.com/tags/%E6%A0%88/"/>
    
      <category term="迷宫" scheme="http://yoursite.com/tags/%E8%BF%B7%E5%AE%AB/"/>
    
      <category term="回溯法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux开发工具相关问题</title>
    <link href="http://yoursite.com/2018/10/21/Linux%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/21/Linux开发工具相关问题/</id>
    <published>2018-10-21T11:55:04.982Z</published>
    <updated>2019-04-04T15:36:59.522Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;<font color="black" size="4" face="微软雅黑">在Linux的系统设置问题上，学会使用文本编辑器来编辑Linux参数配置文件是一项很重要的能力。Linux环境下的文本编辑器有很多，重点掌握VIM却是很有必要的。VIM是VI的升级版，很多软件的编辑接口会主动调用VI，而VIM已经不仅仅可以作为一个文本编辑器，也可以作为程序开发工具，供程序开发者使用。<br> <a id="more"></a></font></p><h3 id="一、-vim的配置"><a href="#一、-vim的配置" class="headerlink" title="一、 vim的配置"></a><font color="black" size="4" face="微软雅黑">一、 vim的配置</font></h3><p>&emsp;<font color="black" size="4" face="微软雅黑"> 一些简单配置Linux的命令有：</font></p><blockquote><p>set nu                           // 在左侧行号<br>set tabstop=4              //tab 长度设置为 4<br>set nobackup               //覆盖文件时不备份<br>set cursorline               //突出显示当前行<br>set ruler                       //在右下角显示光标位置的状态行<br>set autoindent             //自动缩进<br>set mouse=a              //允许使用鼠标移动光标<br>set showmode            //显示左下角状态行<br>set hlsearch                 //搜索时关键字高亮反白<br>set showcmd</p></blockquote><p>&emsp;<font color="black" size="4" face="微软雅黑">配置vim的文件在目录/etc下面，有个名为vimrc的文件，这就是系统中公共的vim配置文件，对所有用户都开放。而在每个用户的主目录下，都可以自己建立私有的配置文件，命名为：”.vimrc”。用vim打开.vimrc键入上述命令保存即可</font></p><blockquote><p>&emsp;<font color="black" size="4" face="微软雅黑">关于vim的简单配置详细的介绍：<a href="https://www.cnblogs.com/mocuishle/p/7966236.html" target="_blank" rel="noopener">VIM简单配置</a><br>&emsp;<font color="black" size="4" face="微软雅黑">如何获得良好的界面：<a href="https://blog.csdn.net/u010871048/article/details/44243774/" target="_blank" rel="noopener">vim配置界面</a><br>&emsp;<font color="black" size="4" face="微软雅黑">要想获得更强大的功能可以点击：<a href="https://blog.csdn.net/freeking101/article/details/62037014" target="_blank" rel="noopener">大牛：超级强大的VIM配置(vimplus)</a></font></font></font></p></blockquote><h3 id="二、常用的编辑器-以及这些编辑器之间的区别和优缺点"><a href="#二、常用的编辑器-以及这些编辑器之间的区别和优缺点" class="headerlink" title="二、常用的编辑器, 以及这些编辑器之间的区别和优缺点."></a><font color="black" size="4" face="微软雅黑">二、常用的编辑器, 以及这些编辑器之间的区别和优缺点.</font></h3><ul><li><p><font color="black" size="4" face="微软雅黑">VI 编辑器是一个基于命令行的、功能强大的文本编辑器，最早为 Unix 系统开发，后来也被移植到许多的 Unix 和 Linux 发行版上。VIM（也被称作 VI IMproved）—VI 编辑器的高阶版本，在 VI 已经很强的功能上添加了更多的功能，这些功能有:</font></p><ul><li><font color="black" size="4" face="微软雅黑">支持更多 Linux 发行版</font></li><li><font color="black" size="4" face="微软雅黑">支持多种编程语言，包括 python、c++、perl 等语言的代码块折叠，语法高亮，</font></li><li><font color="black" size="4" face="微软雅黑">支持通过多种网络协议，包括 http、ssh 等编辑文件，</font></li><li><font color="black" size="4" face="微软雅黑">支持编辑压缩归档中的文件</font></li></ul></li><li><p><font color="black" size="4" face="微软雅黑">Emacs：著名的集成开发环境和文本编辑器。Emacs和Vim对于 Linux 桌面上进行文本编辑是重量级的，Emacs演化出了众多分支，其中使用最广泛的两种是：1984年由Richard Stallman发起的GNU Emacs，以及1991年发起的XEmacs。XEmacs是GNU Emacs的分支，至今仍保持着相当的兼容性。最新的的GNU EMACS的功能包括:</font></p><ul><li><font color="black" size="4" face="微软雅黑">内容感知编辑模式，包括许多文件类型的语法着色。</font></li><li><font color="black" size="4" face="微软雅黑">完整的内置文档，包括新用户教程。</font></li><li><font color="black" size="4" face="微软雅黑">几乎所有人类脚本都支持 完全Unicode。</font></li><li><font color="black" size="4" face="微软雅黑">高度可定制，使用Emacs Lisp代码或图形界面。</font></li><li><font color="black" size="4" face="微软雅黑">超越文本编辑，包括功能的整个生态系统的项目策划人，邮件和新闻阅读器，调试器接口， 日历，和更多。</font></li><li><font color="black" size="4" face="微软雅黑">用于下载和安装扩展的包装系统等等</font></li></ul></li></ul><blockquote><p>详情点击：<a href="http://www.gnu.org/software/emacs/" target="_blank" rel="noopener">GNU</a></p></blockquote><ul><li><font color="black" size="4" face="微软雅黑">Eclipse：Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。最初主要用来Java语言开发，但是目前亦有人通过插件使其作为其他计算机语言比如C++和Python的开发工具。<ul><li><font color="black" size="4" face="微软雅黑">在Eclipse中，完全胜任以下编程语言的工作——Python, R, Ruby, JavaScript, Natural, Lasso, C, C++, COBOL, Scheme, Clojure, Groovy等等</font></li></ul></font></li></ul><blockquote><p><font color="black" size="4" face="微软雅黑"><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">ECLIPSEFOUNDATION</a></font></p></blockquote><ul><li><font color="black" size="4" face="微软雅黑">Brackets：Adobe公司发布了Brackets 1.0，一款针对Web设计人员的免费开源文本编辑器，内置HTML，CSS和JavaScript，方便开发者进行HTML，CSS和JavaScript编程。Brackets 1.0适用于Windows，Mac和Linux操作系统，为Web设计人员和开发人员提供针对性的功能，如：<ul><li><font color="black" size="4" face="微软雅黑">实时预览，在浏览器视图和源代码之间轻松切换，</font></li><li><font color="black" size="4" face="微软雅黑">在特定的代码位进行内联编辑工作，而无需弹出式窗口或其他选项卡。</font></li><li><font color="black" size="4" face="微软雅黑">下载和使用扩展，添加功能以帮助他们的工作流程，如Git整合和JSHint支持</font></li><li><font color="black" size="4" face="微软雅黑">摘要预览，自动从PSD获取设计信息，</font></li><li><font color="black" size="4" face="微软雅黑">Brackets作为一个开源项目，对于想要自定义文本编辑器的用户，可以从Github上Brackets项目页面下载源代码并修改代码进行编译，来适合自己的需求。</font></li></ul></font></li></ul><blockquote><p><font color="black" size="4" face="微软雅黑">官方网站：<a href="http://brackets.io/" target="_blank" rel="noopener">http://brackets.io/</a></font></p><p><font color="black" size="4" face="微软雅黑">Github代码托管：<a href="https://www.github.com/adobe/brackets" target="_blank" rel="noopener">https://www.github.com/adobe/brackets</a></font></p></blockquote><ul><li><font color="black" size="4" face="微软雅黑">LightTable是一个免费开放源代码的编辑器，该编辑器有一个非常干净的界面，并有大量扩展。它与Windows、Mac和Linux都兼容，是高度可定制的。使用Light Table，开发者只需打开一个浏览器窗口即可实时查看更改，并且支持不同的嵌入<ul><li><font color="black" size="4" face="微软雅黑">更改: 我们从 NW.js 切换到了 Electron</font></li><li><font color="black" size="4" face="微软雅黑">更改: Light Table 的发行与自更新进程完全地公开在github上</font></li><li><font color="black" size="4" face="微软雅黑">增加: Light Table 可以用提供的脚本在各个支持的平台上从源码构建    </font></li><li><font color="black" size="4" face="微软雅黑">增加: Light Table 大部分的 node 代码库将通过 npm 依赖来安装，以取代以前采用分叉库的方式</font></li><li><font color="black" size="4" face="微软雅黑">增加: 有效文档。更多详情内容见下面</font></li><li><font color="black" size="4" face="微软雅黑">修复: 版本号 &gt;= OSX 10.10的系统下的主要的可用性问题</font></li><li><font color="black" size="4" face="微软雅黑">更改: 官方不再提供 32位 Linux 软件包下载，不过仍然支持从源码构建</font></li><li><font color="black" size="4" face="微软雅黑">修复: ClojureScript eval 支持 ClojureScript 的现代版本</font></li></ul></font></li></ul><blockquote><p><font color="black" size="4" face="微软雅黑">参阅更多 github.com/LightTable/LightTable/releases</font></p></blockquote><ul><li><font color="black" size="4" face="微软雅黑">Chocolat：Chocolat本身是Mac OS 的最佳代码编辑器。该编辑器旨在与OS无缝集成，Chocolat为JS、Python和HTML提供拖放功能、拆分编辑、代码折叠和代码完成，兼具原生的Cocoa及强大的文本编辑功能。Chocolat支持很多种编程语言的关键字高亮显示、窗口分割、标签页、色彩主题等功能。界面和MacVim非常相似<ul><li><font color="black" size="4" face="微软雅黑">Sublime Text：Sublime Text 是一个轻量、简洁、高效、跨平台的编辑器。</font></li><li><font color="black" size="4" face="微软雅黑">支持多光标操作：它能让你对文本中的多个地方同时做修改，你可以看到多个地方在你输入的时候同时发生变化，</font></li><li><font color="black" size="4" face="微软雅黑">command palette能够让你轻松的做任何操作，勉去了记忆众多快捷键的痛苦。你只需要打开command palette ，输入几个字母，Sublime Text会用模糊查询给你提供建议和选项。跟直接使用快捷键几乎没区别</font></li><li><font color="black" size="4" face="微软雅黑">编辑文件的同时你可以启动编译，看到输出结果，这种交互能让你快速发现编译错误</font></li><li><font color="black" size="4" face="微软雅黑">扩展性很好，它使用了Python式的插件系统。</font></li></ul></font></li></ul><h3 id="三、-常用的编译器-不限制编程语言-不限制平台"><a href="#三、-常用的编译器-不限制编程语言-不限制平台" class="headerlink" title="三、 常用的编译器(不限制编程语言, 不限制平台)"></a><font color="black" size="4" face="微软雅黑">三、 常用的编译器(不限制编程语言, 不限制平台)</font></h3><ul><li><p><font color="black" size="4" face="微软雅黑">MSVC:是指微软的VC编译器,随着微软发布基于Clang / C2,MSVC与Clang / C2并行，继 Google Chrome 宣布弃用微软 C++ 编译器（MSVC）Windows 版 Chrome 改用 Clang 之后，Mozilla 的 Firefox 浏览器也宣布开始使用 Clang 编译器编译其 Windows 版本。</font></p></li><li><p><font color="black" size="4" face="微软雅黑">Clang：Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的 C/C++/Objective C/Objective C++ 编译器，其目标（之一）就是超越 GCC。Clang 的特性有：</font></p><ul><li><font color="black" size="4" face="微软雅黑">快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 是 Apple GCC 4.0 的 2.4x 快。</font></li><li><font color="black" size="4" face="微软雅黑">内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10x。</font></li><li><font color="black" size="4" face="微软雅黑">诊断信息可读性强：其中错误的语法不但有源码提示，还会在错误的调用和相关上下文的下方有提示。</font></li><li><font color="black" size="4" face="微软雅黑">GCC 兼容性。</font></li><li><font color="black" size="4" face="微软雅黑">设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。</font></li><li><font color="black" size="4" face="微软雅黑">基于库的模块化设计，易于 IDE 集成及其他用途的重用。由于历史原因，GCC 是一个单一的可执行程序编译器，其内部完成了从预处理到最后代码生成的全部过程，中间诸多信息都无法被其他程序重用。Clang 将编译过程分成彼此分离的几个阶段，AST 信息可序列化。通过库的支持，程序能够获取到 AST 级别的信息，将大大增强对于代码的操控能力。对于 IDE 而言，代码补全、重构是重要的功能，然而如果没有底层的支持，只使用 tags 分析或是正则表达式匹配是很难达成的。</font></li></ul></li><li><p><font color="black" size="4" face="微软雅黑">GCC/G++：gcc和g++都是GNU(组织)的一个编译器。gcc 是c的编译器，g++是c++的编译器。(常见GCC和G++的误区：[GCC和G++的区别])(<a href="https://my.oschina.net/Failure/blog/114283" target="_blank" rel="noopener">https://my.oschina.net/Failure/blog/114283</a>)</font></p></li><li><p><font color="black" size="4" face="微软雅黑">ICC：全称Intel C++ Compiler，是Intel开发的C/C++/Fortran编译器套装，适用于Linux、Microsoft和Mac OS X操作系统，没有非IA指令集版本(就是说仅供x86架构CPU使用)。ICC广泛应用于高性能计算、分布式计算等商业计算领域，其向量化和并行化性能是业界的标杆，能够充分发挥现代处理器的特性。(ICC官方网：)<a href="https://iccwbo.org/" target="_blank" rel="noopener">ICC</a></font></p></li><li><p><font color="black" size="4" face="微软雅黑">IBM XL C++：IBM® XL C/C++ 是一种编译器，有助于为 IBM Power Systems™ 创建和维护使用 C/C++ 编写的应用，能最大限度地提高硬件利用率。缺点则是在编译时间上往往过长。对C++标准的支持、开源软件的支持、错误信息的提示上都不够友好，但随着13.2开始结合Clang正在进行优化。(官方网站：<a href="https://www.ibm.com/cn-zh/marketplace/xl-cpp-aix-compiler-power" target="_blank" rel="noopener">IBM XL C++</a>)</font></p></li></ul><h3 id="四、为什么调试的时候需要编译选项中添加-g-介绍readelf命令"><a href="#四、为什么调试的时候需要编译选项中添加-g-介绍readelf命令" class="headerlink" title="四、为什么调试的时候需要编译选项中添加 -g. 介绍readelf命令."></a><font color="black" size="4" face="微软雅黑">四、为什么调试的时候需要编译选项中添加 -g. 介绍readelf命令.</font></h3><p>&emsp;1 .<font color="black" size="4" face="微软雅黑">调试的时候加上 -g 是为了生成调试信息，以便于GNU调试器利用该信息，<br>&emsp;2.<font color="black" size="4" face="微软雅黑">readelf命令用来显示一个或者多个elf格式的目标文件的信息，可以通过它的选项来控制显示哪些信息。这里的elf-file(s)就表示那些被检查的文件。可以支持32位，64位的elf格式文件，也支持包含elf文件的文档（这里一般指的是使用ar命令将一些elf文件打包之后生成的例如lib*.a之类的“静态库”文件）。(ELF文件， 其实就是Executable &amp; Linkable Format, 是一种文件格式， 我们常见的目标文件、动态库和可执行文件， 都属于这个类型。)</font></font></p><h3 id="五、-在Linux下实现进度条程序-通过makefile进行编译-以及实现全彩色的进度条"><a href="#五、-在Linux下实现进度条程序-通过makefile进行编译-以及实现全彩色的进度条" class="headerlink" title="五、 在Linux下实现进度条程序. 通过makefile进行编译. 以及实现全彩色的进度条."></a><font color="black" size="4" face="微软雅黑">五、 在Linux下实现进度条程序. 通过makefile进行编译. 以及实现全彩色的进度条.</font></h3><p>&emsp;<font color="black" size="4" face="微软雅黑">1.缓冲区概念<br>缓冲区(buffer)这个中文译意源自当计算机的高速部件与低速部件通讯时,必须将高速部件的输出暂存到某处,以保证高速部件与低速部件相吻合. 后来这个意思被扩展了,成为”临时存贮区”的意思。<br>  缓冲区分为：无缓冲、行缓冲、全缓冲。<br>  &emsp;&emsp;无缓冲：表示的是没有缓冲，可以将信息立马显现出来，典型代表是标准错误流stderr。<br>  &emsp;&emsp;行缓冲：表示的是输入输出遇到换行才执行真正的I/O操作。典型的代表是键盘的操作。<br>  &emsp;&emsp;全缓冲：表示的是输入输出写满缓冲区才执行I/O操作。典型的代表是磁盘的读写。<br>  &emsp;&emsp;fflush:<br>  &emsp;&emsp;&emsp;fflush，函数名， 清除读写缓冲区，需要立即把输出缓冲区的数据进行物理写入时。<br>  &emsp;&emsp;&emsp;fflush(stdin)刷新标准输入缓冲区，把输入缓冲区里的东西丢弃[非标准]<br>  &emsp;&emsp;&emsp;fflush(stdout)刷新标准输出缓冲区，把输出缓冲区里的东西打印到标准输出设备上<br><a href="https://blog.csdn.net/Important_/article/details/78632400" target="_blank" rel="noopener">Linux下实现进度条</a><br>&emsp;<font color="black" size="4" face="微软雅黑">2.进度条<br>prograss_bar.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">char bar[102] = &#123; 0 &#125;;</span><br><span class="line">const char* lable = &quot;|/-\\&quot;;</span><br><span class="line">while(i &lt;= 100)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;[%-100s][%d%%][%c]\r&quot;,bar, i, lable[i%4]);//缓冲区未刷新</span><br><span class="line">fflush(stdout);//刷新缓冲区</span><br><span class="line">bar[i++] = &apos;#&apos;;</span><br><span class="line">usleep(100000);//沉睡100ms</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></font></font></p><font color="black" size="4" face="微软雅黑">Makefile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">prograss_bar:prograss_bar.o</span><br><span class="line">gcc prograss_bar.c -o prograss_bar</span><br><span class="line">prograss_bar.o:prograss_bar.s</span><br><span class="line">gcc -c prograss_bar.s -o prograss_bar.o</span><br><span class="line">prograss_bar.s:prograss_bar.i</span><br><span class="line">gcc -S prograss_bar.i -o prograss_bar.s</span><br><span class="line">prograss_bar.i:prograss_bar.c</span><br><span class="line">gcc -E prograss_bar.c -o prograss_bar.i</span><br><span class="line"></span><br><span class="line">.PHONE:clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -f prograss_bar.i prograss_bar.s prograss_bar.o prograss_bar</span><br></pre></td></tr></table></figure><br><br><img src="https://img-blog.csdnimg.cn/20190404231532400.png" alt="在这里插入图片描述"><br>&emsp;<font color="black" size="4" face="微软雅黑">3.彩色进度条<br>prograss_bar.c<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">char bar[102] = &#123; 0 &#125;;</span><br><span class="line">const char* lable = &quot;|/-\\&quot;;</span><br><span class="line">while(i &lt;= 100)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;\e[34m[%-100s][%d%%][%c]\r\e[0m&quot;,bar, i, lable[i%4]);</span><br><span class="line">fflush(stdout);</span><br><span class="line">bar[i++] = &apos;#&apos;;</span><br><span class="line">usleep(100000);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><img src="https://img-blog.csdnimg.cn/20190404231651881.png" alt="在这里插入图片描述"><br>&emsp;<font color="black" size="4" face="微软雅黑">4.当出现下面的情况时可以试下调整字体大小（Ctrl + ‘-‘ 和 Ctrl + Shift+ ‘+’）或者是分辨率。<br><img src="https://img-blog.csdnimg.cn/20190404231725331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t1aXNpOTU=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><br><font color="black" size="4" face="微软雅黑"><strong>六、Linux下软件安装的几种方式(源码安装, rpm安装, yum安装)</strong><br><font color="black" size="4" face="微软雅黑">1.源码安装：编译源码，然后安装<br>&emsp;1.1安装准备<br>&emsp;&emsp;a..首先用yum安装gcc，用于编译源码<br>&emsp;&emsp;b.管网下载源码包<br>&emsp;&emsp;c、winSCP windows与Linux传输文件（若直接用安装软件的linux电脑下载就不用传输了）<br>&emsp;1.2 安装过程<br>&emsp;&emsp;a、解压<br>&emsp;&emsp;b、进入解压后的目录配置文件  ./configure # 大多数情况下源码包都会带configure这样一个配置工具，具体使用方法可以vim查看其内容<br>&emsp;&emsp;c、make #编译源码包 如果报错了 make clean 清除缓存重新make<br>&emsp;&emsp;d、make install # 安装然后删除源码包软件和安装目录<br><font color="black" size="4" face="微软雅黑">2.rpm安装：<br>&emsp;rpm安装：安装别人编译好的软件包<br>&emsp;rpm即blackhat Package Manager，blackhat的软件包管方式，适用rpm install 命令<br>&emsp;rpm不仅已经把软件源代码编译成二进制文件，而且对软件包依赖的文件，系统环境等做了统计文件扩展名：rpm   还有一种SRPM：没有编译成二进制文件，但是也包含rpm的特性<br><font color="black" size="4" face="微软雅黑">3.yum安装<br>&emsp;用rpm方式安装软件，如果依赖的软件没有事先安装，软件无法安装成功。<br>&emsp;为了解决这个问题，推出yum方式。既然依赖的软件没有安装在机器上，那么就先安装依赖文件，再安装我需要安装的软件。因此yum在安装软件同时安装依赖文件。因此需要一个yum源来放依赖的软件源，对比被安装机器上rpm软件库归根到底，yum也是基于rpm的。<br><font color="black" size="4" face="微软雅黑">Linux下软件安装方式详解：<a href="https://www.cnblogs.com/gmlkl/p/9344244.html#_label4_7" target="_blank" rel="noopener">Linux安装软件</a><br></font></font></font></font></font></font></font></font>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;在Linux的系统设置问题上，学会使用文本编辑器来编辑Linux参数配置文件是一项很重要的能力。Linux环境下的文本编辑器有很多，重点掌握VIM却是很有必要的。VIM是VI的升级版，很多软件的编辑接口会主动调用VI，而VIM已经不仅仅可以作为一个文本编辑器，也可以作为程序开发工具，供程序开发者使用。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux开发工具" scheme="http://yoursite.com/tags/Linux%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>不求甚解</title>
    <link href="http://yoursite.com/2018/10/21/Mind10_21/"/>
    <id>http://yoursite.com/2018/10/21/Mind10_21/</id>
    <published>2018-10-21T02:55:24.201Z</published>
    <updated>2019-04-03T15:00:31.418Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">以前觉得做学问难，做人简单，现在发觉到底是做人难，做学问简单啊！<br> <a id="more"></a><br>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">我是一个追着自己兴趣走的人，虽然家境一般，但是父母在我成长的过程中很大程度上给了我一定的自由，现在的我很感激我过去18年的遇到的人、事、物，他们让我拥有了一个健全的人格和时间观，谢谢。</font></font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">几年了，一路兜兜转转又回到了学校，有很多事发生，有很多人错过，心底里压了很多事没办法说出来，这就是成长的代价了吧。我喜欢很多东西，画画，文学。要是没有接触计算机的话，我想我可能会作为一个小说家，或者公务员，然后接结束大学生涯，在开始那未知的生活。谁曾想，或许从一开始的接触就决定了这一辈子将离不开这个由0和1组成的世界了。现在的我每每回想起过去的自己就好像自己是个未开心智的混沌顽石一样，熬过了五百年的风雨，方才一朝破石而出。很幸运的是我不像那孙猴子一样无父无母，我也没有被压在五行山下然后才懂得自己这一生的使命是什么，少年有个美好的童年，青年有一场平平淡淡的爱情，中年能有毅力打拼一番事业，老年能有个陪你说话的老伴，这就是我的理想中的完美的一生。</font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">说起来好奇计算机还是《黑客帝国》这部电影带我入“坑”呢，从此一发不可收拾，后来长大后，我就得我性格里有一种东西就是掌控自己的一切，我讨厌那种不受人掌控的无奈。所以我想通过我自己个人的努力让自己在这世界上能获得自由，所幸的是计算机的力量是无与伦比的，所以让我沉醉，享受。</font></p><p>&emsp;&emsp;<font color="black" size="4" face="微软雅黑">不求甚解，我觉得是我为人处世，工作学习的总结了，该认真探索的我积极了解，不该我了解的我一听而过，当做长见识，所以在0和1中穿梭的我，却要做到求甚解。</font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;font color=&quot;black&quot; size=&quot;4&quot; face=&quot;微软雅黑&quot;&gt;以前觉得做学问难，做人简单，现在发觉到底是做人难，做学问简单啊！&lt;br&gt;
    
    </summary>
    
      <category term="心路" scheme="http://yoursite.com/categories/%E5%BF%83%E8%B7%AF/"/>
    
    
      <category term="我的学习之路" scheme="http://yoursite.com/tags/%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
    
  </entry>
  
</feed>
