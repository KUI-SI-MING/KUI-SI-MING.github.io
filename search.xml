<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux学习基础]]></title>
    <url>%2F2018%2F10%2F25%2FLinux%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&emsp;了解到Linux系统的产生和发展的过程，对于我来说是一件很幸运的事情，因为这件事让我看到了技术人的品质，开源真的是对技术人的最好的奖励，可以让代码承接自己的精神传扬下去。 一. 基本命令 01. ls指令 语法：ls [选项] [目录或文件功能：目录：该命令列出该目录下所有子目录与文件。文件：列出文件名即其他信息常用选项： -a 列出目录下所有文件，包括以 . 开头的隐含文件. -i 输出文件的 i 节点的索引信息。 -l 列出文件的详细信息。 02. pwd命令 语法：pwd功能：显示用户当前所在目录 03. cd指令 语法：cd 目录名功能：改变工作目录， 将当前工作目录改变到指定目录下举例： cd .. ：返回上级目录 cd /home/xiaomoing/lunix/ ：绝对路径 cd ../day02/ :相对路径 cd ~:进入用户目录 cd -:返回最近访问目录 04. touch指令 语法:touch [选项]…文件…功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的文件常用选项： -d 使用指定的日期或时间。 -r 把指定文档或目录的日期时间，设定成和参考文档或目录的日期时间相同 05. mkdir指令 语法：mkdir [选项] dirname…功能：在当前目录创建一个名为”diname” 的目录常用选项: -p –parents 可以是一个路径名称， 此时若路径上的某些目录不存在，系统可以一次建立多个目录 06. rmdir指令 和 rm 指令 语法：rmdir [-p][driName]功能：删除空目录常用选项： -p 当前子目录被删除后如果父目录为空，就连带删除父目录语法：rm [-f-i-r-v][dirName/dir]功能：删除文件或目录常用选项： -f 文件为只读时也可以删除 -i 删除前逐一询问确认 -r 删除目录及其下所有文件 07. man指令 语法：[选项] 命令功能：访问Lunix手册常用选项： -k 根据关键字搜索联机帮助 -a 将所有的章节都显示出来 08. cp指令 语法：cp [选项] 源文件或目录 目标文件或目录功能：复制文件或目录说明：cp指令用于复制文件或目录， 如同时指定两个以上的文件或目录， 且最后的目的地是一个已经存在的目录， 则它会把前面指定的所有文件或目录复制到此目录中，若不存在，则会显示错误信息。常用选项： -f 强制复目录或文件， 不论文件或目录是否存在 -i 覆盖文件之前询问用户 -r 递归处理，将指定目录下的文件与子目录一并处理 -R 递归处理 09. mv指令 语法：mv [选项] 源文件或目录 目标文件或目录功能：视命令中第二个参数类型的不同（是目标文件还是目标目录），MV命令将文件重命名或将其移入一个新的目录中。当第二个参数类型是文件时，完成文件重命名。当第二个参数类型是已存在的目录时，源文件或目录参数可以有多个，mv命令将各参数指定的文件均移动到目标目录中。常用选项： -f 如果目标文件已经存在，直接覆盖不会询问 -i 若目标文件已经存在，会询问是否覆盖 10. cat/tac指令 语法：cat [选项][文件]功能：查看目标文件的内容常用选项： -b 对非空输出行编号 -n 对输出的所有行进行编号 -s 不输出多行空行 11. more指令 语法：more [选项][文件]功能：功能类似cat常用选项： -n 对输出所有行进行编号 ｑ 退出more 12. less指令 语法：less [参数] 文件功能：使用less可以随意浏览文件，且在查看前不会加载整个文件常用选项： -i 忽略搜索时的大小写 -N 显示每行的行号 /字符串 向下搜索“字符串”的功能 ?字符串 向上搜索“字符串”的功能 n: 重复前一个搜索 13. head指令 语法：head [参数]…[文件]…功能：显示档案的开头至标准输出中，默认打印开头10行选项： -n&lt;行数&gt; 显示的行数 14. tail指令 语法：tail [必要参数][选择参数][文件]功能：显示指定文件末尾内容，不指定文件时作为输入信息进行处理，从指定点开始将文件写入标准输出，选项： -f 循环读数 -n&lt;行数&gt; 显示行数 15. Cal指令 语法：cal [参数][月份][年份]功能：用于查看日历常用选项： -3 显示系统的前一个月，当前月，下一个月的日历 -j 显示当年的第几天 -y 显示当前年份的日历 16. find指令 语法：find pathname ~options功能：用于在文件树查找文件，并作出相应的处理选项：-name 按照文件名查找文件 17. grep指令 语法：gre [选项]搜寻字符串 文件功能：在文件中搜索字符串，将找到的行打印出来常用选项： -i 忽略大小写的不同 -n 输出行号 -v 反向选择， 显示出没有“搜寻字符串”内容的那一行 18. zip/unzip指令 语法：zip 压缩文件.zip 目录或文件功能：将目录或文件压缩成zip格式常用选项： -r 递归处理,将指定目录下所有的文件与子目录一并处理 19. tar指令 语法：tar [选项]文件与目录…参数…功能：打包/解包，不打开它，直接看内容常用选项： -c 建立一个压缩文件的参数指令 -x 解开一个压缩文件的参数指令 -z 是否同时具有gzip的属性？ -f 使用档名，请留意，在f之后要立即接档名，不要加参数 20. uname指令 语法：uname [选项]功能：获取电脑和操作系统的相关信息常用选项： -a 或-all 详细输出所有信息 二. 进入目录需要哪些权限, 在目录中执行增删查(cd, touch, ls, rm, mv等)改文件动作, 需要哪些权限.Linux中的基本权限（r、w、x） 1、读（r/4）：read对于文件来说，具有读取文件内容的权限；对于目录来说，具有浏览该目录信息的权限。 2、写（w/2）：write对于文件来说，具有修改文件内容的权限；对于目录来说，具有删除、移动目录内文件的权限。 3、执行（x/1）；execute对于文件来说，具有执行文件的权限；对于目录来说，具有进入目录的权限。 文件权限值得表示方法 a)字符表示方法 b)8进制数值表示方法 修改权限的方法 1. chmod chmod [参数] 权限 文件名 设置文件的访问权限 一. 用户表示符 +/-=权限字符 实例： 二. 三位8进制数字 实例 三．进入目录需要哪些权限, 在目录中执行增删查(cd, touch, ls, rm, mv等)改文件动作, 需要哪些权限？ cd：a.语法 cd 目录名（进入目录） b.所需权限x touch：a.语法 touch 文件名（创建文件） b.所需权限wx ls：a.语法 ls （显示当前目录下的所有文件） b.所需权限rx rm：a.语法 rm 文件名（删除文件） b.所需权限wx mv：a.语法 mv 文件名1 文件名2（把文件名1修改为文件名2） b.所需权限wx 三. Linux下的重要目录/proc, /sys, /SElinux, /bin, /usr/lib, /usr/local, /var, /tmp /proc:特殊文件目录。这个目录采用一种特殊的文件格式（proc格式，内核支持这种格式。其中包括了全部虚拟文件。它们并不是保存在磁盘中，也不占用磁盘空间，当查看它们时，实际上看到的是内存里的信息，这些文件有助于我们了解系统内部信息）。 /sys: 文件系统访问 Linux内核 /SElinux:SELinux是一种基于域-类型模型(domain-type)的强制访问控制(MAC)安全系统，它由NSA编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了SELinux的补丁，最后还有一个相应的安全策略 /usr/lib:/usr/local/lib： 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules /usr/local:存放软件升级包 /var:内容经常变化的目录。此目录下文件的大小可能改变，如缓冲文件、日志文件、缓存文件等一般会放在这里 /tmp:一般用户或正在执行的程序临时存放文件的目录即临时文件,任何人都可以访问,重要数据不可放置在此目录下 四. 重要命令. du, df, top, free, pstack, su, sudo(sudo -, sudo -s), adduser, password du 作用是磁盘空间使用情况，功能是逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块的情况，如果没有指定目录，则对当前的目录进行统计。主要参数： s：只显示各档案大小的总合 b：大小用bytes来表示 x：跳过在不同文件系统上的目录不予统计 a：递归地显示指定目录中各文件及子孙目录中各文件占用的数据块数 df 命令用来检查文件系统的磁盘空间占用情况，使用权限是所有用户。主要参数： －s：对每个Names参数只给出占用的数据块总数。 －a：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定－s，也不指定－a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。 －k：以1024字节为单位列出磁盘空间使用情况。 －x：跳过在不同文件系统上的目录不予统计。 －l：计算所有的文件大小，对硬链接文件则计算多次。 －i：显示inode信息而非块使用量。 －h：以容易理解的格式印出文件系统大小，例如136KB、254MB、21GB。 －P：使用POSIX输出格式。 －T：显示文件系统类型 top 基本格式df [options]作用:命令用来显示执行中的程序进程，使用权限是所有用户主要参数： d：指定更新的间隔，以秒计算。 q：没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行。 c：显示进程完整的路径与名称。 S：累积模式，会将己完成或消失的子行程的CPU时间累积起来。 s：安全模式。 i：不显示任何闲置(Idle)或无用(Zombie)的行程。 n：显示更新的次数，完成后将会退出top。 free 格式free [－b|－k|－m] [－o] [－s delay] [－t] [－V]作用:free命令用来显示内存的使用情况，使用权限是所有用户。主要参数： －b －k －m：分别以字节（KB、MB）为单位显示内存使用情况。 －s delay：显示每隔多少秒数来显示一次内存使用情况。 －t：显示内存总和列。 －o：不显示缓冲区调节列。 pstack:显示每个进程的栈跟踪pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。 su 格式 su [选项]… [-] [USER [ARG]…]作用是变更为其它使用者的身份，超级用户除外，需要键入该使用者的密码。主要参数： -f ， –fast：不必读启动文件（如 csh.cshrc 等），仅用于csh或tcsh两种Shell。 -l ， –login：加了这个参数之后，就好像是重新登陆为该使用者一样，大部分环境变量（例如HOME、SHELL和USER等）都是以该使用者（USER）为主，并且工作目录也会改变。如果没有指定USER，缺省情况是root。 -m， -p ，–preserve-environment：执行su时不改变环境变数。 -c command：变更账号为USER的使用者，并执行指令（command）后再变回原来使用者。 USER：欲变更的使用者账号，ARG传入新的Shell参数。 sudo(sudo -, sudo -s)命令的配置在/etc/sudoers文件中。当用户使用sudo时，需要输入口令以验证使用者身份。随后的一段时间内可以使用定义好的命令，当使用配置文件中没有的命令时，将会有报警的记录。sudo是系统管理员用来允许某些用户以root身份运行部分/全部系统命令的程序。一个明显的用途是增强了站点的安全性，如果需要每天以超级用户的身份做一些日常工作，经常执行一些固定的几个只有超级用户身份才能执行的命令，那么用sudo是非常适合的。 pstack 命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。 adduser（1）创建用户命令两条： adduser useradd（2）用户删除命令： userdel两个用户创建命令之间的区别： adduser： 会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。 useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。 password:登陆密码管理passwd 作为普通用户和超级权限用户都可以运行，但作为普通用户只能更改自己的用户密码，但前提是没有被root用户锁定；如果root用户运行passwd ，可以设置或修改任何用户的密码；主要参数： -d：删除密码，仅有系统管理者才能使用； -f：强制执行； -k：设置只有在密码过期失效后，方能更新； -l：锁住密码； -s：列出密码的相关信息，仅有系统管理者才能使用； -u：解开已上锁的帐号。 五. 如何使用命令安装gcc/g++, gdb, vimvim是Linux下的编辑器，linux中使用gcc来编译C程序，使用g++来编译C++程序，使用gdb来调试程序 一、vim安装完Centos 后，默认是安装了Vi编辑器的。但Vim编辑器是没安装或者未完全安装的。1）首先，检测是否已经安装过Vim;输入命令：rpm -qa|grep vim显示出完整的包名： vim-common,vim-enhanced,vim-minimal,vim-filesystem 表示安装成功，有的centos系统，默认包名不同。2）若是缺少Vim包名：则在root下使用命令如下：比如说： vim-minimal这个包少了，执行：yum -y install vim-minimal 命令，它会自动下载安装。3）若下载完成，进行安装：命令：yum -y install vim* 安装完成后则可以使用vim编辑器 二、gcc/g++Centos中使用yum来配置gcc和g++，在root账户下，若要安装gcc，则在命令行中输入:yum -y install gcc，按回车键就能够进行gcc的安装;若要安装g++，则需要在命令行中输入：yum -y install gcc-c++，就能够进行g++的安装。gdb先使用如下命令看系统中是否安装了gdb，如果安装了，如下图如果没有安装，则Centos中使用yum来安装gdb,在root账户下，在命令行中输入：yum install gdb，使用：which gdb 查看是否安装成功]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>重要目录</tag>
        <tag>GCC/G++等安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈应用及迷宫问题]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%A0%88%E5%BA%94%E7%94%A8%E5%8F%8A%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、栈 栈是一种重要的线性结构，在数据结构而言，其本质操作是线性表操作的子集。但在数据类型来说，是一种重要的抽象数据类型。在面向对象的程序设计中，栈是多数据类型。 栈只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。不含任何元素的栈称为空栈，栈又称为后进先出的线性表，简称LIFO结构。栈可以将数据从一种序列变到另一种序列。 二、栈的分类 顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，一般使用过程中所需的最大空间，故先给栈分配一个基本容量，在使用过程中然后增容。 链式栈，是一种不连续的存储结构，元素以Node的形式存储，包含数据域和指针域，指针域指向下一个节点，每个节点随机分布，为动态开辟节点。 三、栈的基本模块无论是链式栈还是顺序栈其基本操作都一样，包含栈的创建，初始化，销毁，插入，删除，取栈顶元素等，只是其实现方式不同。下面就是顺序栈的模块。栈代码：头文件”Stack.h”12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;////typedef int DataType;////#define N 10//typedef struct Stack//&#123;// DataType _a[N];//规定数组空间大小// int _top; // 栈顶//&#125;Stack;//静态栈typedef struct Pos&#123; int _row; int _col;&#125;Pos;//迷宫位置点typedef Pos DataType;typedef struct Stack&#123; DataType* _a; //节点指针 int _top; // 栈顶 int _capacity; // 容量&#125;Stack;void StackInit(Stack* ps);//初始化void StackDestory(Stack* ps);//销毁void StackPush(Stack* ps, DataType x);//压栈void StackPop(Stack* ps);//出栈DataType StackTop(Stack* ps);//取栈顶元素int StackEmpty(Stack* ps);//判空int StackSize(Stack* ps);//栈的大小//void TestStack();函数文件”Stack.c”12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &quot;Stack.h&quot;void StackInit(Stack* ps)&#123; ps-&gt;_a = (DataType*)malloc(sizeof(DataType)* 3);//动态开辟空间 assert(ps);//防止开辟失败 ps-&gt;_capacity = 3; ps-&gt;_top = 0;&#125;void StackDestory(Stack* ps)&#123; assert(ps);//断言 if (ps-&gt;_a) &#123; free(ps-&gt;_a); ps-&gt;_a = NULL; ps-&gt;_capacity = ps-&gt;_top = 0; &#125; while (ps-&gt;_top--) &#123; free(ps-&gt;_top); &#125; ps-&gt;_capacity = 0;&#125;void StackPush(Stack* ps, DataType x)&#123; assert(ps); if (ps-&gt;_top == ps-&gt;_capacity)//越界 &#123; ps-&gt;_a = (DataType*)realloc(ps-&gt;_a, sizeof(DataType)*(ps-&gt;_capacity * 2));//增容 assert(ps-&gt;_a); ps-&gt;_capacity *= 2; &#125; ps-&gt;_a[ps-&gt;_top] = x; ps-&gt;_top++;&#125;void StackPop(Stack* ps)&#123; assert(ps-&gt;_a); assert(ps-&gt;_top &gt; 0); ps-&gt;_top--;&#125;DataType StackTop(Stack* ps)&#123; assert(ps-&gt;_a &amp;&amp; ps-&gt;_top &gt; 0); return ps-&gt;_a[ps-&gt;_top - 1];&#125;//空 0//非空 1int StackEmpty(Stack* ps)&#123; assert(ps); return ps-&gt;_top == 0 ? 0 : 1;&#125;int StackSize(Stack* ps)&#123; assert(ps); return ps-&gt;_top;&#125;//测试代码//void TestStack()//&#123;// Stack s;// StackInit(&amp;s);//// StackPush(&amp;s, 1);// StackPush(&amp;s, 2);// StackPush(&amp;s, 3);// StackPush(&amp;s, 4);//// while (StackEmpty(&amp;s))// &#123;// printf(&quot;%d &quot;,StackTop(&amp;s));// StackPop(&amp;s);// &#125;// printf(&quot;\n&quot;);////// StackDestory(&amp;s);//&#125; 四、迷宫 迷宫问题，望文生义就是在迷宫当中找到出口，出入口自定义，解决迷宫问题的过程中以回溯法为思想，应用栈的知识来解决这个问题。对于迷宫问题的思考是由解决简单的迷宫然后到环路迷宫这样一个过程的。 回溯法：对一个包括有很多个结点，每个结点有若干个搜索分支的问题，把原问题分解为若干个子问题进行求解的算法；当搜索到某个结点发现无法再继续搜索下去时，就让搜索过程回溯到该结点的前一个结点，继续搜索该结点外的其他尚未搜索的分支；如果发现该结点无法再搜索下去，就让搜索过程回溯到这个结点的前一个结点继续这样的搜索过程。 1.简单迷宫——–从出口处将开始进行压栈，判断其上，下，左，右方向是否可走，若某个方向可走将其坐标进行压栈，并将坐标上的值置为2，再探测该坐标的分支，直到出口，返回1即找到出口，若在某一个结点处四个方向均不可走则返回上一个坐标，并将该坐标从栈中释放，若栈为空时仍未到出口处则返回0即未找到出口。0 0 0 0 0 00 0 1 0 0 00 0 1 0 0 00 0 1 1 1 00 0 1 0 1 10 0 1 0 0 0 2.多路迷宫——–在简单迷宫的基础上当找到出口时并不返回值，当栈为空即回溯到出口时返回到主函数。0 0 0 0 0 00 0 1 0 0 00 0 1 1 1 10 0 1 0 0 00 0 1 1 1 10 0 1 0 0 0 3.环路迷宫——–在多路迷宫的基础上，在设置压入栈的坐标的值时换为前一个坐标的值加1,即递增的。在判断某个坐标是否可走时变换条件，进而达到目的。0 0 0 0 0 00 0 1 1 1 00 0 1 0 1 00 0 1 0 1 00 0 1 1 1 10 0 1 0 0 0 迷宫代码（环路迷宫代码）：头文件”maze.h” 12345678910111213141516171819202122232425262728293031323334#pragma once#include&quot;Stack.h&quot;#define N 6int size;static int maze[N][N] = &#123;//static,只在maze.c中可见 /*&#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;,*/ /*&#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 0 &#125;, &#123; 0, 0, 1, 0, 1, 0 &#125;, &#123; 0, 0, 1, 0, 1, 0 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;,*/ &#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 0 &#125;, &#123; 0, 0, 1, 0, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;,&#125;;int GetMazePath(Pos entry, Pos exit);//获取迷宫通路:找到通路/找不到通路int CheckAccess(Pos cur, Pos next);void PrintfMaze();void TestMaze(); 函数文件”maze.c” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&quot;Maze.h&quot;int CheckAccess(Pos cur, Pos next)&#123; if (next._row &gt;= 0 &amp;&amp; next._row &lt; N &amp;&amp;next._col &gt;= 0 &amp;&amp; next._col &lt; N &amp;&amp; (maze[next._row][next._col] == 1 || maze[next._row][next._col] &gt; maze[cur._row][cur._col] + 1))//当下一个坐标的值为1 或者比当前值加一还大就可以走 &#123; return 1; &#125; else &#123; return 0; &#125;&#125;int size = 0;int GetMazePath(Pos entry, Pos exit)&#123; Stack path; int flag = 0; StackInit(&amp;path); StackPush(&amp;path, entry); maze[entry._row][entry._col] = 2;//入口初始化为2 while (StackEmpty(&amp;path)) &#123; //Pos cur = entry;//当前位置 Pos cur = StackTop(&amp;path);//栈顶取出的当前位置 //if (cur._col == 5)//多条通路 if (cur._row == exit._row &amp;&amp;cur._col == exit._col)//当一条路径找到出口时，打印路径并且看路径长短 &#123; flag = 1; for (int i = 0; i &lt; path._top; i++) &#123; printf(&quot;[%d %d]-&gt;&quot;, path._a[i]._row, path._a[i]._col); &#125; printf(&quot; Exit\n\n&quot;); if (size == 0 || StackSize(&amp;path) &lt; size) &#123; size = StackSize(&amp;path);//路径的长短 &#125; &#125; Pos next; //上 next = cur;//当前位置 next._row -= 1;//下一个位置 if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //下 next = cur; next._row += 1; if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //左 next = cur; next._col -= 1; if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //右 next = cur; next._col += 1; if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //走到四个方向不通的位置 //回溯 StackPop(&amp;path); &#125; if (flag == 0)//判断是否找到出口 return 0; else return 1;&#125;void PrintfMaze()&#123; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; printf(&quot;%d &quot;, maze[i][j]); &#125; printf(&quot;\n&quot;); &#125; printf(&quot;\n&quot;);&#125; 主函数文件”main.c” 12345678910111213141516171819202122232425262728293031#include &quot;maze.h&quot;void TestMaze()&#123; Pos entry; entry._row = 5; entry._col = 2; Pos exit; exit._row = 4; exit._col = 5; printf(&quot;迷宫地图:\n&quot;); PrintfMaze(); if (GetMazePath(entry, exit)) &#123; printf(&quot;有出口，最短路径为：%d \n\n&quot;, size); &#125; else &#123; printf(&quot;无出口！\n\n&quot;); &#125; printf(&quot;走出后迷宫地图:\n&quot;); PrintfMaze();&#125;int main()&#123; TestMaze(); system(&quot;pause&quot;); return 0;&#125; 五、运行结果 1.简单迷宫 2.多路迷宫 3.环路迷宫 结合之前的栈的基本操作代码就可以解决迷宫问题了。-(￣▽￣)-]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>迷宫</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux开发工具相关问题]]></title>
    <url>%2F2018%2F10%2F21%2FLinux%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在Linux的系统设置问题上，学会使用文本编辑器来编辑Linux参数配置文件是一项很重要的能力。Linux环境下的文本编辑器有很多，重点掌握VIM却是很有必要的。VIM是VI的升级版，很多软件的编辑接口会主动调用VI，而VIM已经不仅仅可以作为一个文本编辑器，也可以作为程序开发工具，供程序开发者使用。 一、 vim的配置 一些简单配置Linux的命令有： set nu // 在左侧行号set tabstop=4 //tab 长度设置为 4set nobackup //覆盖文件时不备份set cursorline //突出显示当前行set ruler //在右下角显示光标位置的状态行set autoindent //自动缩进set mouse=a //允许使用鼠标移动光标set showmode //显示左下角状态行set hlsearch //搜索时关键字高亮反白set showcmd 配置vim的文件在目录/etc下面，有个名为vimrc的文件，这就是系统中公共的vim配置文件，对所有用户都开放。而在每个用户的主目录下，都可以自己建立私有的配置文件，命名为：”.vimrc”。用vim打开.vimrc键入上述命令保存即可。 关于vim的简单配置详细的介绍：VIM简单配置如何获得良好的界面：vim配置界面要想获得更强大的功能可以点击：大牛：超级强大的VIM配置(vimplus) 二、常用的编辑器, 以及这些编辑器之间的区别和优缺点.Linux中强大的编辑器列表 VI 编辑器是一个基于命令行的、功能强大的文本编辑器，最早为 Unix 系统开发，后来也被移植到许多的 Unix 和 Linux 发行版上。 VIM（也被称作 VI IMproved）——VI 编辑器的高阶版本，在 VI 已经很强的功能上添加了更多的功能，这些功能有： 支持更多 Linux 发行版， 支持多种编程语言，包括 python、c++、perl 等语言的代码块折叠，语法高亮， 支持通过多种网络协议，包括 http、ssh 等编辑文件， 支持编辑压缩归档中的文件， Emacs：著名的集成开发环境和文本编辑器。Emacs和Vim对于 Linux 桌面上进行文本编辑是重量级的，Emacs演化出了众多分支，其中使用最广泛的两种是：1984年由Richard Stallman发起的GNU Emacs，以及1991年发起的XEmacs。XEmacs是GNU Emacs的分支，至今仍保持着相当的兼容性。最新的的GNU EMACS的功能包括: 内容感知编辑模式，包括许多文件类型的语法着色。 完整的内置文档，包括新用户教程。 几乎所有人类脚本都支持 完全Unicode。 高度可定制，使用Emacs Lisp代码或图形界面。 超越文本编辑，包括功能的整个生态系统的项目策划人，邮件和新闻阅读器，调试器接口， 日历，和更多。 用于下载和安装扩展的包装系统等等 详情点击：GNU Eclipse：Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。最初主要用来Java语言开发，但是目前亦有人通过插件使其作为其他计算机语言比如C++和Python的开发工具。 在Eclipse中，完全胜任以下编程语言的工作——Python, R, Ruby, JavaScript, Natural, Lasso, C, C++, COBOL, Scheme, Clojure, Groovy等等 Eclipse官网：ECLIPSEFOUNDATION Brackets：Adobe公司发布了Brackets 1.0，一款针对Web设计人员的免费开源文本编辑器，内置HTML，CSS和JavaScript，方便开发者进行HTML，CSS和JavaScript编程。Brackets 1.0适用于Windows，Mac和Linux操作系统，为Web设计人员和开发人员提供针对性的功能，如： 实时预览，在浏览器视图和源代码之间轻松切换， 在特定的代码位进行内联编辑工作，而无需弹出式窗口或其他选项卡。 下载和使用扩展，添加功能以帮助他们的工作流程，如Git整合和JSHint支持 摘要预览，自动从PSD获取设计信息， Brackets作为一个开源项目，对于想要自定义文本编辑器的用户，可以从Github上Brackets项目页面下载源代码并修改代码进行编译，来适合自己的需求。 官方网站：http://brackets.io/ Github代码托管：https://www.github.com/adobe/brackets LightTable是一个免费开放源代码的编辑器，该编辑器有一个非常干净的界面，并有大量扩展。它与Windows、Mac和Linux都兼容，是高度可定制的。使用Light Table，开发者只需打开一个浏览器窗口即可实时查看更改，并且支持不同的嵌入。 更改: 我们从 NW.js 切换到了 Electron 更改: Light Table 的发行与自更新进程完全地公开在github上 增加: Light Table 可以用提供的脚本在各个支持的平台上从源码构建 增加: Light Table 大部分的 node 代码库将通过 npm 依赖来安装，以取代以前采用分叉库的方式 增加: 有效文档。更多详情内容见下面 修复: 版本号 &gt;= OSX 10.10的系统下的主要的可用性问题 更改: 官方不再提供 32位 Linux 软件包下载，不过仍然支持从源码构建 修复: ClojureScript eval 支持 ClojureScript 的现代版本 参阅更多 github.com/LightTable/LightTable/releases Chocolat：Chocolat本身是Mac OS 的最佳代码编辑器。该编辑器旨在与OS无缝集成，Chocolat为JS、Python和HTML提供拖放功能、拆分编辑、代码折叠和代码完成，兼具原生的Cocoa及强大的文本编辑功能。Chocolat支持很多种编程语言的关键字高亮显示、窗口分割、标签页、色彩主题等功能。界面和MacVim非常相似。 Sublime Text：Sublime Text 是一个轻量、简洁、高效、跨平台的编辑器。 支持多光标操作：它能让你对文本中的多个地方同时做修改，你可以看到多个地方在你输入的时候同时发生变化， command palette能够让你轻松的做任何操作，勉去了记忆众多快捷键的痛苦。你只需要打开command palette ，输入几个字母，Sublime Text会用模糊查询给你提供建议和选项。跟直接使用快捷键几乎没区别 编辑文件的同时你可以启动编译，看到输出结果，这种交互能让你快速发现编译错误 扩展性很好，它使用了Python式的插件系统。 三、 常用的编译器(不限制编程语言, 不限制平台) MSVC:是指微软的VC编译器,随着微软发布基于Clang / C2,MSVC与Clang / C2并行，继 Google Chrome 宣布弃用微软 C++ 编译器（MSVC）Windows 版 Chrome 改用 Clang 之后，Mozilla 的 Firefox 浏览器也宣布开始使用 Clang 编译器编译其 Windows 版本。 Clang：Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的 C/C++/Objective C/Objective C++ 编译器，其目标（之一）就是超越 GCC。Clang 的特性有： 快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 是 Apple GCC 4.0 的 2.5x 快。 内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10x。 诊断信息可读性强：其中错误的语法不但有源码提示，还会在错误的调用和相关上下文的下方有提示。 GCC 兼容性。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 基于库的模块化设计，易于 IDE 集成及其他用途的重用。由于历史原因，GCC 是一个单一的可执行程序编译器，其内部完成了从预处理到最后代码生成的全部过程，中间诸多信息都无法被其他程序重用。Clang 将编译过程分成彼此分离的几个阶段，AST 信息可序列化。通过库的支持，程序能够获取到 AST 级别的信息，将大大增强对于代码的操控能力。对于 IDE 而言，代码补全、重构是重要的功能，然而如果没有底层的支持，只使用 tags 分析或是正则表达式匹配是很难达成的。 GCC/G++：gcc和g++都是GNU(组织)的一个编译器。gcc 是c的编译器，g++是c++的编译器。(常见GCC和G++的误区：[GCC和G++的区别])(https://my.oschina.net/Failure/blog/114283) ICC：全称Intel C++ Compiler，是Intel开发的C/C++/Fortran编译器套装，适用于Linux、Microsoft和Mac OS X操作系统，没有非IA指令集版本(就是说仅供x86架构CPU使用)。ICC广泛应用于高性能计算、分布式计算等商业计算领域，其向量化和并行化性能是业界的标杆，能够充分发挥现代处理器的特性。(ICC官方网：)ICC IBM XL C++：IBM® XL C/C++ 是一种编译器，有助于为 IBM Power Systems™ 创建和维护使用 C/C++ 编写的应用，能最大限度地提高硬件利用率。缺点则是在编译时间上往往过长。对C++标准的支持、开源软件的支持、错误信息的提示上都不够友好，但随着13.2开始结合Clang正在进行优化。(官方网站：[IBM XL C++](https://www.ibm.com/cn-zh/marketplace/xl-cpp-aix-compiler-power)) 四、为什么调试的时候需要编译选项中添加 -g. 介绍readelf命令.1 .调试的时候加上 -g 是为了生成调试信息，以便于GNU调试器利用该信息，2.readelf命令用来显示一个或者多个elf格式的目标文件的信息，可以通过它的选项来控制显示哪些信息。这里的elf-file(s)就表示那些被检查的文件。可以支持32位，64位的elf格式文件，也支持包含elf文件的文档（这里一般指的是使用ar命令将一些elf文件打包之后生成的例如lib*.a之类的“静态库”文件）。(ELF文件， 其实就是Executable &amp; Linkable Format, 是一种文件格式， 我们常见的目标文件、动态库和可执行文件， 都属于这个类型。)五、 在Linux下实现进度条程序. 通过makefile进行编译. 以及实现全彩色的进度条.1.缓冲区概念缓冲区(buffer)这个中文译意源自当计算机的高速部件与低速部件通讯时,必须将高速部件的输出暂存到某处,以保证高速部件与低速部件相吻合. 后来这个意思被扩展了,成为”临时存贮区”的意思。 缓冲区分为：无缓冲、行缓冲、全缓冲。 无缓冲：表示的是没有缓冲，可以将信息立马显现出来，典型代表是标准错误流stderr。 行缓冲：表示的是输入输出遇到换行才执行真正的I/O操作。典型的代表是键盘的操作。 全缓冲：表示的是输入输出写满缓冲区才执行I/O操作。典型的代表是磁盘的读写。 fflush: fflush，函数名， 清除读写缓冲区，需要立即把输出缓冲区的数据进行物理写入时。 fflush(stdin)刷新标准输入缓冲区，把输入缓冲区里的东西丢弃[非标准] fflush(stdout)刷新标准输出缓冲区，把输出缓冲区里的东西打印到标准输出设备上本文来自 Important_ 的CSDN 博客 ，全文地址请点击：[Linux下实现进度条](https://blog.csdn.net/Important_/article/details/78632500)2.进度条代码prograss_bar.c12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main()&#123; int i = 0; char bar[102] = &#123; 0 &#125;; const char* lable = &quot;|/-\\&quot;; while(i &lt;= 100) &#123; printf(&quot;[%-100s][%d%%][%c]\r&quot;,bar, i, lable[i%4]);//缓冲区未刷新 fflush(stdout);//刷新缓冲区 bar[i++] = &apos;#&apos;; usleep(100000);//沉睡100ms &#125; printf(&quot;\n&quot;); return 0;&#125;Makefile12345678910111213prograss_bar:prograss_bar.o gcc prograss_bar.c -o prograss_barprograss_bar.o:prograss_bar.s gcc -c prograss_bar.s -o prograss_bar.oprograss_bar.s:prograss_bar.i gcc -S prograss_bar.i -o prograss_bar.sprograss_bar.i:prograss_bar.c gcc -E prograss_bar.c -o prograss_bar.i.PHONE:cleanclean: rm -f prograss_bar.i prograss_bar.s prograss_bar.o prograss_bar3.彩色进度条prograss_bar.c12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main()&#123; int i = 0; char bar[102] = &#123; 0 &#125;; const char* lable = &quot;|/-\\&quot;; while(i &lt;= 100) &#123; printf(&quot;\e[34m[%-100s][%d%%][%c]\r\e[0m&quot;,bar, i, lable[i%4]); fflush(stdout); bar[i++] = &apos;#&apos;; usleep(100000); &#125; printf(&quot;\n&quot;); return 0;&#125;4.当出现下面的情况时可以试下调整字体大小（Ctrl + ‘-‘ 和 Ctrl + Shift+ ‘+’）或者是分辨率。六、 Linux下软件安装的几种方式(源码安装, rpm安装, yum安装)1.源码安装：编译源码，然后安装&emsp;1.1安装准备&emsp;&emsp;a..首先用yum安装gcc，用于编译源码&emsp;&emsp;b.管网下载源码包&emsp;&emsp;c、winSCP windows与Linux传输文件（若直接用安装软件的linux电脑下载就不用传输了）&emsp;1.2 安装过程&emsp;&emsp;a、解压&emsp;&emsp;b、进入解压后的目录配置文件 ./configure # 大多数情况下源码包都会带configure这样一个配置工具，具体使用方法可以vim查看其内容&emsp;&emsp;c、make #编译源码包 如果报错了 make clean 清除缓存重新make&emsp;&emsp;d、make install # 安装然后删除源码包软件和安装目录2.rpm安装：&emsp;rpm安装：安装别人编译好的软件包&emsp;rpm即Redhat Package Manager，Redhat的软件包管方式，适用rpm install 命令&emsp;rpm不仅已经把软件源代码编译成二进制文件，而且对软件包依赖的文件，系统环境等做了统计文件扩展名：rpm 还有一种SRPM：没有编译成二进制文件，但是也包含rpm的特性3.yum安装&emsp;用rpm方式安装软件，如果依赖的软件没有事先安装，软件无法安装成功。&emsp;为了解决这个问题，推出yum方式。既然依赖的软件没有安装在机器上，那么就先安装依赖文件，再安装我需要安装的软件。因此yum在安装软件同时安装依赖文件。因此需要一个yum源来放依赖的软件源，对比被安装机器上rpm软件库归根到底，yum也是基于rpm的。Linux下软件安装方式详解：[Linux安装软件](https://www.cnblogs.com/gmlkl/p/9354254.html#_label4_7)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不求甚解]]></title>
    <url>%2F2018%2F10%2F21%2FMind10_21%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;谨以为向自由世界奋斗的勇士们致敬！ &emsp;&emsp;我是一个追着自己兴趣走的人，虽然家境一般，但是父母在我成长的过程中很大程度上给了我一定的自由，现在的我很感激我过去18年的遇到的人、事、物，他们让我拥有了一个健全的人格和时间观，谢谢。 &emsp;&emsp;几年了，一路兜兜转转又回到了学校，有很多事发生，有很多人错过，心底里压了很多事没办法说出来，这就是成长的代价了吧。我喜欢很多东西，画画，文学。要是没有接触计算机的话，我想我可能会作为一个小说家，或者公务员，然后接结束大学生涯，在开始那未知的生活。谁曾想，或许从一开始的接触就决定了这一辈子将离不开这个由0和1组成的世界了。现在的我每每回想起过去的自己就好像自己是个未开心智的混沌顽石一样，熬过了五百年的风雨，方才一朝破石而出。很幸运的是我不像那孙猴子一样无父无母，我也没有被压在五行山下然后才懂得自己这一生的使命是什么，少年有个美好的童年，青年有一场平平淡淡的爱情，中年能有毅力打拼一番事业，老年能有个陪你说话的老伴，这就是我的理想中的完美的一生。 &emsp;&emsp;说起来好奇计算机还是《黑客帝国》这部电影带我入“坑”呢，从此一发不可收拾，后来长大后，我就得我性格里有一种东西就是掌控自己的一切，我讨厌那种不受人掌控的无奈。所以我想通过我自己个人的努力让自己在这世界上能获得自由，所幸的是计算机的力量是无与伦比的，所以让我沉醉，享受。 &emsp;&emsp;不求甚解，我觉得是我为人处世，工作学习的总结了，该认真探索的我积极了解，不该我了解的我一听而过，当做长见识，所以在0和1中穿梭的我，却要做到求甚解。]]></content>
      <categories>
        <category>心录</category>
      </categories>
      <tags>
        <tag>我的学习之路</tag>
      </tags>
  </entry>
</search>
