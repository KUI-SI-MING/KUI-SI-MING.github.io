<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 进程相关（二）]]></title>
    <url>%2F2018%2F11%2F10%2FLinux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、模拟实现僵尸进程, 孤儿进程&emsp;&emsp;1.僵尸进程：僵尸进程是一个比较特殊的状态，当进程退出并且父进程没有读取到子进程退出的返回代码时就会产生僵尸进程，而且僵尸进程会以终止状态保持在进程表中，并且会一直等待父进程读取退出户状态代码，那么当子进程退出，父进程在运行，但父进程没有读取到子进程状态，那么子进程就进入到僵尸状态。&emsp;&emsp;&emsp;1.2、实现一个僵尸进程1234567891011121314151617181920212223 1 #include &lt;stdio.h&gt; 2 #include &lt;stdlib.h&gt; 3 4 int main() 5 &#123; 6 pid_t id = fork(); 7 if(id &lt; 0) 8 &#123; 9 perror("fork"); 10 return 1; 11 &#125; 12 else if(id &gt; 0)&#123; 13 printf("parent [%d] is sleeping...\n", getpid()); 14 sleep(30); 15 &#125; 16 else&#123; 17 printf("child [%d] is begin...\n", getpid()); 18 sleep(5); 19 exit(EXIT_SUCCESS); 20 &#125; 21 return 0; 22 &#125; ~ 首先在另一个终端下执行while :; do ps aux | grep static | grep -v grep; sleep 1; echo &quot;#############&quot;; done启动监控 然后执行./static 之后就可以看到子进程变成了僵尸进程 &emsp;&emsp;2.孤儿进程:相比于僵尸进程，如果父进程提前退出，那么子进程后退出， 这时子进程就称为“孤儿进程”，当然了OS不可能放任孤儿进程不管，孤儿进程被1号init进程领养，也由init进程回收。&emsp;&emsp;&emsp;2.1、实现孤儿进程123456789101112131415161718192021221 #include &lt;stdio.h&gt; 2 #include &lt;unistd.h&gt; 3 #include &lt;stdlib.h&gt; 4 5 int main() 6 &#123; 7 pid_t id = fork(); 8 if(id &lt; 0) 9 &#123; 10 perror("fork"); 11 return 1; 12 &#125; 13 else if(id == 0)&#123;//child 14 printf("I am child, pid is [%d]\n", getpid()); 15 sleep(10); 16 &#125;else&#123; 17 printf("I am parent, pid is [%d]\n", getpid()); 18 sleep(3); 19 exit(0); 20 &#125; 21 return 0; 22 &#125; 1234561 orphan_process:Orphan_process.c 2 gcc -o $@ $^ 3 4 .PHONY:clean 5 clean: 6 rm -rf orphan_process 首先在另一个终端下执行while :; do ps aux | grep orphan_process | grep -v grep; sleep 1; echo &quot;#############&quot;; done启动监控 执行./orphan_process 之后就可以看到子进程被回收 二、setenv, export等环境变量相关的函数和命令 环境变量里包含了程序运行时的完整路径，以便于我们在其他地方运行某个程序时，OS会在环境变量里搜索该程序的路径，然后运行。 Linux中的环境变量 12345678910PATH //这个变量包含了一系列由冒号分隔开的目录，系统就从这些目录里寻找可执行文件。如果你输入的可执行文件（例如ls、rc-update或者emerge） 不在这些目录中，系统就无法执行它（除非你输入这个命令的完整路径，如/bin/ls）。 ROOTPATH //这个变量的功能和PATH相同，但它只罗列出超级用户（root）键入命令时所需检查的目录。 LDPATH //这个变量包含了一系列用冒号隔开的目录，动态链接器将在这些目录里查找库文件。 MANPATH //这个变量包含了一系列用冒号隔开的目录，命令man会在这些目录里搜索man页面。 INFODIR //这个变量包含了一系列用冒号隔开的目录，命令info将在这些目录里搜索info页面。 PAGER //这个变量包含了浏览文件内容的程序的路径（例如less或者more）。 EDITOR //这个变量包含了修改文件内容的程序（文件编辑器）的路径（比如nano或者vi）。 KDEDIRS //这个变量包含了一系列用冒号隔开的目录，里面放的是KDE相关的资料。 CONFIG_PROTECT //这个变量包含了一系列用空格隔开的目录，它们在更新的时候会被Portage保护起来。 CONFIG_PROTECT_MASK //这个变量包含了一系列用空格隔开的目录，它们在更新的时候不会被Portage保护起来。 环境变量命令 1234561.echo //显示某个环境变量值 echo $PATH 2.export //设置一个新的环境变量 export HELLO="hello" (可以无引号) 3.env //显示所有环境变量 4.set //显示本地定义的shell变量 5.unset //清除环境变量 unset HELLO 6.readonly //设置只读环境变量 readonly HELLO C语言中的getenv(); setenv(); unsetenv();函数可以设置或访问某一个环境变量。 &emsp;&emsp;&emsp;(1)getenv()函数 123456SYNOPSIS #include &lt;stdlib.h&gt; char *getenv(const char *name); char *secure_getenv(const char *name); Feature Test Macro Requirements for glibc (see feature_test_macros(7)): secure_getenv(): _GNU_SOURCE &emsp;&emsp;&emsp;根据getenv()函数的定义可以看出，一共有两个getenv()函数,其中char *getenv(const char *name);是如果所查找的环境变量不存在就返回一个NULL指针，存在就返回其地址，由于其返回值存放在一个数组里，所以不用担心再次查询会覆盖之前的值，而char *secure_getenv(const char *name);也是同样的返回值，但其应用于线程安全。 &emsp;&emsp;&emsp;(2)setenv()函数 12345678910111213SYNOPSIS #include &lt;stdlib.h&gt; int setenv(const char *name, const char *value, int overwrite); Feature Test Macro Requirements for glibc (see feature_test_macros(7)): setenv(), unsetenv(): _BSD_SOURCE || _POSIX_C_SOURCE &gt;= 200112L || _XOPEN_SOURCE &gt;= 600 DESCRIPTION The setenv() function adds the variable name to the environment with the value value, if name does not already exist. If name does exist in the environment, then its value is changed to value if overwrite is nonzero; if overwrite is zero, then the value of name is not changed. This function makes copies of the strings pointed to by name and value (by contrast with putenv(3)). &emsp;&emsp;&emsp;setenv()函数，顾名思义可以设置环境变量，当环境变量中没有要添加的name时就添加该变量名，若存在就看overwrite是否非零，若为零就不覆盖，若非零就覆盖。成功时返回0，错误时返回-1，并指出原因。 - &lt;font color=black size=4 face=&quot;仿&quot;&gt;unsetenv()函数 12345678910SYNOPSIS #include &lt;stdlib.h&gt; int unsetenv(const char *name); Feature Test Macro Requirements for glibc (see feature_test_macros(7)): setenv(), unsetenv(): _BSD_SOURCE || _POSIX_C_SOURCE &gt;= 200112L || _XOPEN_SOURCE &gt;= 600 The unsetenv() function deletes the variable name from the environment. If name does not exist in the environment, then the function succeeds, and the environment is unchanged. &emsp;&emsp;&emsp;unsetenv()函数就是删除某个环境变量，若某个环境变量不存就返回成功，环境变量不作改变，返回值和setenv()函数一致。&emsp;&emsp;&emsp;(3)指针变量environ指向的是一个包含所有环境变量的列表.使用以下代码可以打印出所有环境变量 1234567891 #include &lt;stdio.h&gt; 2 extern char**environ; 3 int main () 4 &#123; 5 char**path; 6 for (path =environ;*path !=NULL;++path) 7 printf ("%s \n ",*path); 8 return 0; 9 &#125; &emsp;&emsp;&emsp;可以看到以下结果 12345678910111213141516171819202122232425262728293031 SSH_AUTH_SOCK=/run/user/1000/keyring/sshSESSION_MANAGER=local/unix:@/tmp/.ICE-unix/1837,unix/unix:/tmp/.ICE-unix/1837USERNAME=kuiGNOME_SHELL_SESSION_MODE=classicPATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/kui/.local/bin:/home/kui/binMAIL=/var/spool/mail/kuiDESKTOP_SESSION=gnome-classiQT_IM_MODULE=ximQT_QPA_PLATFORMTHEME=qgnomeplatformXDG_SESSION_TYPE=x11PWD=/home/kuiXMODIFIERS=@im=ibusLANG=zh_CN.UTF-8GDM_LANG=zh_CN.UTF-8GDMSESSION=gnome-classicHISTCONTROL=ignoredupsXDG_SEAT=seat0HOME=/home/kuiSHLVL=2GNOME_DESKTOP_SESSION_ID=this-is-deprecatedXDG_SESSION_DESKTOP=gnome-classicLOGNAME=kuiXDG_DATA_DIRS=/home/kui/.local/share/flatpak/exports/share/:/var/lib/flatpak/exports/share/:/usr/local/share/:/usr/share/DBUS_SESSION_BUS_ADDRESS=unix:abstract=/tmp/dbus-8PBK3gNeEw,guid=e9d3af1ed81eabd51e3431735bef8722LESSOPEN=||/usr/bin/lesspipe.sh %sWINDOWPATH=1XDG_RUNTIME_DIR=/run/user/1000DISPLAY=:0XDG_CURRENT_DESKTOP=GNOME-Classic:GNOMECOLORTERM=truecolorXAUTHORITY=/run/gdm/auth-for-kui-KUriSB/database_=./test]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>僵尸进程</tag>
        <tag>孤儿进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos7下提交GitHub代码]]></title>
    <url>%2F2018%2F11%2F08%2Fcentos7%E4%B8%8B%E6%8F%90%E4%BA%A4GitHub%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[一、建立GitHub远程仓库 在Github官网上建立一个仓库 二、安装Git在终端运行1yum install git 之后可以查看其版本：1git --version 三、克隆远程仓库到本地 新建仓库之后点开可以看见http网址，直接复制即可 1git clone https://github.com/KUI-SI-MING/Linux.git/ 克隆成功后可以看到 四、添加到索引库1git add path //path可以是文件也可以是目录 五、将索引库提交到本地版本库1git commit -m &quot;描述信息&quot; 提交成功后可以看到12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485[kui@localhost Kui]$ git commit -m &quot;First&quot;[master（根提交） 4c9ee01] First Committer: kui_nian &lt;kui@localhost.localdomain&gt;您的姓名和邮件地址基于登录名和主机名进行了自动设置。请检查它们正确与否。您可以通过下面的命令对其进行明确地设置以免再出现本提示信息： git config --global user.name &quot;Your Name&quot; git config --global user.email you@example.com设置完毕后，您可以用下面的命令来修正本次提交所使用的用户身份： git commit --amend --reset-author 3 files changed, 59 insertions(+) create mode 100755 myshell/Makefile create mode 100755 myshell/myshell create mode 100755 myshell/myshell.c[kui@localhost Kui]$ git config --global user.name &quot;Your Name&quot;[kui@localhost Kui]$ git config --global user.name &quot;Your Name&quot;[kui@localhost Kui]$ git config --global user.name &quot;kui-si-ming&quot;[kui@localhost Kui]$ git config --global user.email kuisi5495@163.com[kui@localhost Kui]$ git commit --amend --reset-authorError detected while processing /home/kui/.vimrc:line 5:E492: Not an editor command: Plug &apos;Valloric/YouCompleteMe&apos;line 6:E492: Not an editor command: Plug &apos;bling/vim-airline&apos;line 7:E492: Not an editor command: Plug &apos;vim-airline/vim-airline-themes&apos;line 8:E492: Not an editor command: Plug &apos;morhetz/gruvbox&apos;line 9:E492: Not an editor command: Plug &apos;octol/vim-cpp-enhanced-highlight&apos;line 10:E492: Not an editor command: Plug &apos;SirVer/ultisnips&apos;line 11:E492: Not an editor command: Plug &apos;tpope/vim-surround&apos;line 12:E492: Not an editor command: Plug &apos;flazz/vim-colorschemes&apos;line 13:E492: Not an editor command: Plug &apos;scrooloose/nerdtree&apos;line 14:E492: Not an editor command: Plug &apos;python-mode/python-mode&apos;line 15:E492: Not an editor command: Plug &apos;scrooloose/nerdcommenter&apos;line 16:E492: Not an editor command: Plug &apos;Yggdroot/LeaderF&apos;line 17:E492: Not an editor command: Plug &apos;cpiger/NeoDebug&apos;line 18:E492: Not an editor command: Plug &apos;ryanoasis/vim-devicons&apos;line 22:E492: Not an editor command: Plug &apos;autozimu/LanguageClient-neovim&apos;, &#123; &apos;branch&apos;: &apos;next&apos;, &apos;do&apos;: &apos;bash install.sh&apos;, &#125;line 29:E185: Cannot find color scheme &apos;luna-term&apos;line 58:E518: Unknown option: foldmethod=markerline 141:E518: Unknown option: foldenableline 149:E518: Unknown option: foldmethod=indentline 150:E518: Unknown option: foldlevel=99line 294:E31: No such mappingline 295:E31: No such mappingline 296:E31: No such mappingline 297:E31: No such mappingline 298:E31: No such mappingline 299:E31: No such mappingline 300:E31: No such mappingline 301:E31: No such mappingPress ENTER or type command to continue[master 0ec225e] First 3 files changed, 59 insertions(+) create mode 100755 myshell/Makefile create mode 100755 myshell/myshell create mode 100755 myshell/myshell.c 按照提示信息修改用户名和邮箱 五、部署到远程仓库1git push origin master 部署成功之后可以看到1234567891011121314[kui@localhost Kui]$ git push origin masterUsername for &apos;https://github.com&apos;: kui-si-mingPassword for &apos;https://kui-si-ming@github.com&apos;:Counting objects: 6, done.Delta compression using up to 2 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 3.74 KiB | 0 bytes/s, done.Total 6 (delta 0), reused 0 (delta 0)remote:remote: Create a pull request for &apos;master&apos; on GitHub by visiting:remote: https://github.com/KUI-SI-MING/Kui/pull/new/masterremote:To https://github.com/KUI-SI-MING/Kui.git * [new branch] master -&gt; master 这样就大功告成啦。在官网就可以看到]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>提交Github代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ templates]]></title>
    <url>%2F2018%2F11%2F08%2FC-templates%2F</url>
    <content type="text"><![CDATA[&emsp;C++ templates的最初发展是为了建立“类型安全”的容器如：vector，list和map。但是随着templates的发展，有人意识到C++ templates机制本身就是一步完整的图灵机：它可以被用来计算任何可以计算的值，于是导出了模板元编程，创造出了“在C++编译器内执行并于编译完成时停止执行”的程序。 一、C++模板 泛型编程&emsp;关于泛型编程就是编写与类型无关的通用代码，是代码复用的一种手段。而模板是泛型编程的基础。模板又可以分为函数模板和类模板。函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本。 函数模板&emsp;模板是一个蓝图，它本身并不是函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来应该我们做的重复的事情交给了编译器在编译器编译阶段，对于模板函数的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。比如：当用double类型使用函数模板时，编译器通过对实参类型的推演，将T确定为double类型，然后产生一份专门处理double类型代码，对于字符类型也是如此。在实现函数模板的实例化时可以分为隐式实例化和显式实例化。 1.隐式实例化：让编译器根据实参推演模板参数的实际类型2.显式实例化：在函数名后的&lt;&gt;中指定模板参数的实际类型 &emsp;&emsp;&emsp;对于函数模板参数的匹配则又可以分为以下几点： 1.一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数2.对于非模板函数和同名函数模板，如果其他条件都相同，在调动时会优先调用非模板函数而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数， 那么将选择模板3.显式指定一个空的模板实参列表，该语法告诉编译器只有模板才能来匹配这个调用， 而且所有的模板参数都应该根据实参演绎出来4.模板函数不允许自动类型转换，但普通函数可以进行自动类型转换 类模板&emsp;类模板中函数放在类外进行定义时，需要加模板参数列表，类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的类，而实例化的结果才是真正的类。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>泛型编程</tag>
        <tag>C++模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++初识]]></title>
    <url>%2F2018%2F11%2F06%2FC-%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[&emsp;计算机革命起源于一台机器。因此，程序设计语言的起源看上去也起源于那台机器。 一、关于的C++发展史&emsp;程序作为算法和数据的集合，在计算机的发展中一直未变，发展演化的是他们之间的关系，就是所谓的程序设计方法。&emsp;C语言是结构化和模块化的语言，适合处理较小规模的程序。对于复杂的问题，规模较大的程序，需要高度的抽象和建模时，C语言则不合适。为了解决软件危机， 在 20 世纪 70 年代,程序设计的焦点从过程化程序设计方法转移到了抽象数据类型(abstract data type )简写为 ADT 的程序设计上,现在通常称之为基于对象(object based)的程序设计 。&emsp;1982年，Bjarne Stroustrup博士在C语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与C语言的渊源关系，命名为C++。因此：C++是基于C语言而产生的，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计。&emsp;如今的C++大厦是一钉一卯创建起来的，来看下C++历史版本。 二、C++ 入门基础 &emsp;命名空间：在C/C++中，变量、函数和许多类都是大量存在的，这些变量、函数和类的名称将都存在于全局作用域中，可能会导致很多冲突。使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突或名字污染，namespace关键字的出现就是针对这种问题的。&emsp;名字空间是很有用的工具，但名字空间的出现意味着在写程序之前必须知道他们。所有的C++标准库都封装在“std”(standard)。名字空间和包含头文件的方法之间相互关系若给出#include &lt;iostream.h&gt;它相当于#include &lt;iostream&gt; using namespace std &emsp;缺省参数：是一种虽然并不普遍，但在多数情况下仍然适用的实参值。 函数可以用参数表中的初始化语法为一个或多个参数指定缺省实参 ，调用包含缺省实参的函数时，我们可以，也可以不为该参数提供实参，如果提供了实参，则它将覆盖缺省的实参值 。函数调用的实参按位置解析，缺省实参只能用来替换函数调用缺少的尾部 （tailing） 实参 。函数声明可以为全部或部分参数指定缺省实参，在左边参数的任何缺省实参被提供之前，最右边未初始化参数必须被提供缺省实参，这是由于函数调用的实参是按照位置来解析的。一个参数只能在一个文件中被指定一次缺省实参 。 &emsp;函数重载：在 C++中，可以为两个或多个函数提供相同的名字，只要它们的每个参数表惟一就行或者是参数的个数不同，或者是参数类型不同 。 名字修饰：为了让重载函数正确的工作，编译器要用不同的参数类型来修饰不同的函数名，而这种名字修饰没有统一的标准，所以不同的编译器可能会产生不同的内部名（可在汇编代码看到），名字修饰的另一个好处是类型安全连接。即使当函数的调用与声明不符时，C++在链接时会报告错误信息，而这在大项目中将会避免很多隐藏的错误。 C语言中对于同名函数，在汇编语言中链接时符号表中的命名为函数名 + 地址，这样对于同名的函数而言，编译器找不到需要跳转的地址，所以不支持函数重载。而C++有自己的函数命名规则，即在符号表中用函数名修饰规则表示函数名，不同参数的函数名不一样，编译器能根据函数名找到跳转的地址。 用返回值重载：虽然内部函数修饰了返回值，当编译器能从上下文中唯一确定函数的意思时，没有问题，但在C中总是可以调用一个函数但忽略它的返回值，即调用了函数的副作用，那么此时编译器调用哪个函数，而且程序员自己也不知道那个函数被调用，所以C++中禁止这样做。 指针和引用：引用就像是能自动地被编译器间接引用的常量型指针。常用雨于函数参数表中和函数的返回值，也可独立使用。C++支持相近类型（类型的意义近似相同）的隐式转换 int e = 10; const double&amp; f = e;//f并不是e的别名而是编译器隐式转换所创建的临时变量的别名。 引用和指针的区别:引用和指针在语法上不一样但在底层实现上是一样的。引用只能在定义时初始化一次，之后不能改变指向其它变量（从一而终）；指针变量的值可变。引用必须指向有效的变量，指针可以为空。sizeof指针对象和引用对象的意义不一样。sizeof引用得到的是所指向的变量的大小，而sizeof指针是对象地址的大小。指针和引用自增(++)自减(–)意义不一样。相对而言，引用比指针更安全。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++发展史</tag>
        <tag>函数重载</tag>
        <tag>命名空间</tag>
        <tag>指针和引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程相关（一）]]></title>
    <url>%2F2018%2F11%2F05%2FLinux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、进程的调度算法&emsp;1.进程调度：多进程环境，望文生义，有多个进程同时进行,但具体到单个CPU级别，则在任何时刻只能有一个进程执行，因此操作系统需要决定哪个进程可以执行，哪个进程需要等待，而这就是进程调度。&emsp;2.进程状态: a.等待态：等待某个事件的完成；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b.就绪态：等待系统分配处理器以便运行&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;c.运行态：占有处理器正在运行&emsp;3.三种进程状态的转换：运行态-&gt;等待态：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;等待态-&gt;就绪态：等待的条件已经满足，只需要分配到处理器后就能运行；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;就绪态-&gt;运行态：系统按某种策略选中就绪队列中的一个进程占用处理器；&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;运行态-&gt;就绪态：由于外界原因让运行状态的进程让出处理器，例如有更高优先级的进程来抢占处理器，或时间片（时间片是系统分配给程序的运行时间）用完。 &emsp;4。调度目标:1.程序使用CPU的三种模式：IO密集型、计算密集型和平衡型。对于IO密集型程序来说，响应时间非常重要；对于CPU密集型来说，CPU的周转时间就比较重要；对于平衡型程序来说，响应和周转之间的平衡是最重要的。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;2.CPU的调度就是要达到极小化平均响应时间、极大化系统吞吐率、保持系统各个功能部件均处于繁忙状态和提供某种公平的机制。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;3.对于实时系统来说，调度的目标就是要达到截止时间前完成所应该完成的任务和提供性能的可预测性。 &emsp;5.调度方式： 剥夺方式——当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给他的处理机，将之分配给其他进程，剥夺原则有：优先权原则、短进程优先原则、时间片原则。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 非剥夺方式：分配程序一旦把处理机分配给某进程后便让他一直运行下去，直到进程完成或发生事件而阻塞时，才把处理机分配给另一个进程。 &emsp;6.调度算法：a.先来先服务调度算法,FCFS（First come first serve)，或者称为FIFO算法。先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。这个算法的优点是简单，实现容易，并且似乎公平；缺点在于短的任务有可能变的非常慢，因为其前面的任务占用很长时间，造成了平均响应时间非常慢。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;b.短任务优先算法（STCF算法（Short time to complete first)），这种算法的核心就是所有的程序都有一个优先级，短任务的优先级比长任务的高，而OS总是安排优先级高的进程运行。STCF又分为两类：非抢占式和抢占式。非抢占式STCF就是让已经在CPU上运行的程序执行到结束或者阻塞，然后在所有的就绪进程中选择执行时间最短的来执行；而抢占式STCF就不是这样，在每进来一个新的进程时，就对所有进程（包括正在CPU上执行的进程）进行检查，谁的执行时间短，就运行谁。对预计执行时间短的进程有限分配处理机，通常后来的短进程不会抢先正在执行的进程；对长进程非常不利，可能长时间得不到执行。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;c.时间片轮询算法，这是对FIFO算法的改进，目的是改善短程序（运行时间短）的响应时间，其方法就是周期性地进行进程切换。这个算法的关键点在于时间片的选择，时间片过大，那么轮转就越接近FIFO，如果太小，进程切换的开销大于执行程序的开销，从而降低了系统效率。因此选择合适的时间片就非常重要。选择时间片的两个需要考虑的因素：一次进程切换所使用的系统消耗以及我们能接受的整个系统消耗、系统运行的进程数。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;d.优先级调度:优先级调度，STCF遇到的问题是长任务的程序可能饥饿，那么优先级调度算法可以通过给长任务的进程更高的优先级来解决这个问题；优先级调度遇到的问题可能是短任务的进程饥饿，这个可以通过动态调整优先级来解决。实际上动态调整优先级（称为权值）+时间片轮询的策略正是linux的进程调度策略之一的 SCHED_OTHER分时调度策略,它的调度过程如下：（1）创建任务指定采用分时调度策略，并指定优先级nice值(-20~19)。—-&gt;（2）将根据每个任务的nice值确定在cpu上的执行时间(counter)。—-&gt;（3）如果没有等待资源，则将该任务加入到就绪队列中。—-&gt;（4）调度程序遍历就绪队列中的任务，通过对每个任务动态优先级的计算(counter+20-nice)结果，选择计算结果最大的一个去运行，当这个时间片用完后(counter减至0)或者主动放弃cpu时，该任务将被放在就绪队列末尾(时间片用完)或等待队列(因等待资源而放弃cpu)中。—-&gt;（5）此时调度程序重复上面计算过程，转到第4步。—-&gt;（6）当调度程序发现所有就绪任务计算所得的权值都为不大于0时，重复第2步。此外linux还有两个实时进程的调度策略：FIFO和RR,实时进程会立即抢占非实时进程。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;e其他调度算法，保证调度算法保证每个进程享用的CPU时间完全一样；彩票调度算法是一种概率调度算法，通过给进程“发彩票”的多少，来赋予不同进程不同的调用时间，彩票调度算法的优点是非常灵活，如果你给短任务发更多“彩票”，那么就类似STCF调度，如果给每个进程一样多的“彩票”，那么就类似保证调度；用户公平调度算法，是按照每个用户，而不是按照每个进程来进行公平分配CPU时间，这是为了防止贪婪用户启用了过多进程导致系统效率降低甚至停顿。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;f.实时系统的调度算法，实时系统需要考虑每个具体任务的响应时间必须符合要求，在截止时间前完成。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(1)EDF调度算法，就是最早截止任务优先（Earliest deadline first)算法，也就是让最早截止的任务先做。当新的任务过来时，如果它的截止时间更靠前，那么就让新任务抢占正在执行的任务。EDF算法其实是贪心算法的一种体现。如果一组任务可以被调度（也就是所有任务的截止时间在理论上都可以得到满足），那么EDF可以满足。如果一批任务不能全部满足（全部在各自的截止时间前完成），那EDF满足的任务数最多，这就是它最优的体现。EDF其实就是抢占式的STCF，只不过将程序的执行时间换成了截止时间。EDF的缺点在于需要对每个任务的截止时间做计算并动态调整优先级，并且抢占任务也需要消耗系统资源。因此它的实际效果比理论效果差一点。&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(2)RMS调度算法，EDF是动态调度算法，而RMS（rate monotonic scheduling)算法是一种静态最优算法；该算法在进行调度前先计算出所有任务的优先级，然后按照计算出来的优先级进行调度，任务执行中间既不接收新任务，也不进行优先级调整或者CPU抢占。因此它的优点是系统消耗小，缺点就是不灵活了。对于RMS算法，关键点在于判断一个任务组是否能被调度，这里有一个定律，如果一个系统的所有任务的CPU利用率都低于ln2，那么这些任务的截止时间均可以得到满足，ln2约等于0.693147，也就是此时系统还剩下有30%的CPU时间。这个证明是Liu和Kayland在1973年给出的。 二、task_struct结构体中的各个字段的含义&emsp;&emsp;在linux中，每创建一个进程就会产生一个进程描述符，这个”进程描述符”就是task_struct，在task_struct里面保存了许多关于进程控制的信息。 task_struct是Linux内核的一种数据结构，每个进程都把它的信息放在task_struct这个数据结构里，包含： 标示符：描述本进程的唯一标示符，用来区别其他进程。 状态：任务状态，退出代码，退出信号等。 优先级：相对于其他进程的优先级。 程序计数器：程序中即将被执行的下一条指令的地址。 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针。 上下文数据：进程执行时处理器的寄存器中的数据。 I/O状态信息：包括显示的I/O请求，分配给进程的I/O设备和正在被进程使用的文件列表。 记账信息：可能包括处理器时间总和，使用的时钟总数，时间限制，记账号等。 成员分类如下：1.进程标识符（PID）12pid_t pid;pid_t tgid;在CONFIG_BASE_SMALL配置为0的情况下，PID的取值范围是0到32767，即系统中的进程数最大为32768个。2.进程的状态12volatile long state;int exit_state;state成员的取值如下：123456789101112#define TASK_RUNNING 0//进程要么正在执行，要么准备执行#define TASK_INTERRUPTIBLE 1 //可中断的睡眠，可以通过一个信号唤醒#define TASK_UNINTERRUPTIBLE 2 //不可中断睡眠，不可以通过信号进行唤醒#define __TASK_STOPPED 4 //进程停止执行#define __TASK_TRACED 8 //进程被追踪/* in tsk-&gt;exit_state */#define EXIT_ZOMBIE 16 //僵尸状态的进程，表示进程被终止，但是父进程还没 有获取它的终止信息，比如进程有没有执行完等信息。 #define EXIT_DEAD 32 //进程的最终状态，进程死亡。/* in tsk-&gt;state again */#define TASK_DEAD 64 //死亡#define TASK_WAKEKILL 128 //唤醒并杀死的进程#define TASK_WAKING 256 //唤醒进程3.进程的内核栈1void *stack;进程通过alloc_thread_info函数分配它的内核栈，通过free_thread_info函数释放所分配的内核栈1234567891011121314 /* linux-2.6.38.8/kernel/fork.c */static inline struct thread_info *alloc_thread_info(struct task_struct *tsk)&#123;#ifdef CONFIG_DEBUG_STACK_USAGE gfp_t mask = GFP_KERNEL | __GFP_ZERO;#else gfp_t mask = GFP_KERNEL;#endif return (struct thread_info *)__get_free_pages(mask, THREAD_SIZE_ORDER);&#125;static inline void free_thread_info(struct thread_info *ti)&#123; free_pages((unsigned long)ti, THREAD_SIZE_ORDER);&#125;Linux内核通过thread_union联合体来表示进程的内核栈，其中THREAD_SIZE宏的大小为8192。1234union thread_union &#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE/sizeof(long)];&#125;;进程内核栈与进程描述符的关系如下图：4.标记1unsigned int flags; /* per process flags, defined below */flags成员的可能取值如下：12345678910111213141516171819202122232425262728293031#define PF_KSOFTIRQD 0x00000001 /* I am ksoftirqd */#define PF_STARTING 0x00000002 /* being created */#define PF_EXITING 0x00000004 /* getting shut down */#define PF_EXITPIDONE 0x00000008 /* pi exit done on shut down */#define PF_VCPU 0x00000010 /* I'm a virtual CPU */#define PF_WQ_WORKER 0x00000020 /* I'm a workqueue worker */#define PF_FORKNOEXEC 0x00000040 /* forked but didn't exec */#define PF_MCE_PROCESS 0x00000080 /* process policy on mce errors */#define PF_SUPERPRIV 0x00000100 /* used super-user privileges */#define PF_DUMPCORE 0x00000200 /* dumped core */#define PF_SIGNALED 0x00000400 /* killed by a signal */#define PF_MEMALLOC 0x00000800 /* Allocating memory */#define PF_USED_MATH 0x00002000 /* if unset the fpu must be initialized before use */#define PF_FREEZING 0x00004000 /* freeze in progress. do not account to load */#define PF_NOFREEZE 0x00008000 /* this thread should not be frozen */#define PF_FROZEN 0x00010000 /* frozen for system suspend */#define PF_FSTRANS 0x00020000 /* inside a filesystem transaction */#define PF_KSWAPD 0x00040000 /* I am kswapd */#define PF_OOM_ORIGIN 0x00080000 /* Allocating much memory to others */#define PF_LESS_THROTTLE 0x00100000 /* Throttle me less: I clean memory */#define PF_KTHREAD 0x00200000 /* I am a kernel thread */#define PF_RANDOMIZE 0x00400000 /* randomize virtual address space */#define PF_SWAPWRITE 0x00800000 /* Allowed to write to swap */#define PF_SPREAD_PAGE 0x01000000 /* Spread page cache over cpuset */#define PF_SPREAD_SLAB 0x02000000 /* Spread some slab caches over cpuset */#define PF_THREAD_BOUND 0x04000000 /* Thread bound to specific cpu */#define PF_MCE_EARLY 0x08000000 /* Early kill for mce process policy */#define PF_MEMPOLICY 0x10000000 /* Non-default NUMA mempolicy */#define PF_MUTEX_TESTER 0x20000000 /* Thread belongs to the rt mutex tester */#define PF_FREEZER_SKIP 0x40000000 /* Freezer should not count it as freezable */#define PF_FREEZER_NOSIG 0x80000000 /* Freezer won't send signals to it */5.进程之间的亲属关系：12345struct task_struct *real_parent; /* real parent process */struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */struct list_head children; /* list of my children */struct list_head sibling; /* linkage in my parent's children list */struct task_struct *group_leader; /* threadgroup leader */在Linux系统中，所有进程之间都有着直接或间接地联系，每个进程都有其父进程，也可能有零个或多个子进程。拥有同一父进程的所有进程具有兄弟关系。real_parent指向其父进程，如果创建它的父进程不再存在，则指向PID为1的init进程。parent指向其父进程，当它终止时，必须向它的父进程发送信号。它的值通常与real_parent相同。children表示链表的头部，链表中的所有元素都是它的子进程。sibling用于把当前进程插入到兄弟链表中。group_leader指向其所在进程组的领头进程。6.ptrace系统调用12345678 unsigned int ptrace; struct list_head ptraced; struct list_head ptrace_entry; unsigned long ptrace_message; siginfo_t *last_siginfo; /* For ptrace use. */#ifdef CONFIG_HAVE_HW_BREAKPOINT atomic_t ptrace_bp_refcnt;#endif成员ptrace被设置为0时表示不需要被跟踪，它的可能取值如下：1234567891011/* linux-2.6.38.8/include/linux/ptrace.h */#define PT_PTRACED 0x00000001#define PT_DTRACE 0x00000002 /* delayed trace (used on m68k, i386) */#define PT_TRACESYSGOOD 0x00000004#define PT_PTRACE_CAP 0x00000008 /* ptracer can follow suid-exec */#define PT_TRACE_FORK 0x00000010#define PT_TRACE_VFORK 0x00000020#define PT_TRACE_CLONE 0x00000040#define PT_TRACE_EXEC 0x00000080#define PT_TRACE_VFORK_DONE 0x00000100#define PT_TRACE_EXIT 0x000002007.进程调度1234567int prio, static_prio, normal_prio;unsigned int rt_priority;const struct sched_class *sched_class;struct sched_entity se;struct sched_rt_entity rt;unsigned int policy;cpumask_t cpus_allowed;实时优先级范围是0到MAX_RT_PRIO-1（即99），而普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1（即100到139）。值越大静态优先级越低。static_prio用于保存静态优先级，可以通过nice系统调用来进行修改。rt_priority用于保存实时优先级。normal_prio的值取决于静态优先级和调度策略。prio用于保存动态优先级。policy表示进程的调度策略，目前主要有以下五种：123456#define SCHED_NORMAL 0//按照优先级进行调度（有些地方也说是CFS调度器）#define SCHED_FIFO 1//先进先出的调度算法#define SCHED_RR 2//时间片轮转的调度算法#define SCHED_BATCH 3//用于非交互的处理机消耗型的进程#define SCHED_IDLE 5//系统负载很低时的调度算法#define SCHED_RESET_ON_FORK 0x400000008.时间数据成员12345678910111213cputime_t utime, stime, utimescaled, stimescaled; cputime_t gtime; cputime_t prev_utime, prev_stime;//记录当前的运行时间（用户态和内核态） unsigned long nvcsw, nivcsw; //自愿/非自愿上下文切换计数 struct timespec start_time; //进程的开始执行时间 struct timespec real_start_time; //进程真正的开始执行时间 unsigned long min_flt, maj_flt; struct task_cputime cputime_expires;//cpu执行的有效时间 struct list_head cpu_timers[3];//用来统计进程或进程组被处理器追踪的时间 struct list_head run_list; unsigned long timeout;//当前已使用的时间（与开始时间的差值） unsigned int time_slice;//进程的时间片的大小 int nr_cpus_allowed;9.信号处理信息1234567struct signal_struct *signal;//指向进程信号描述符 struct sighand_struct *sighand;//指向进程信号处理程序描述符 sigset_t blocked, real_blocked;//阻塞信号的掩码 sigset_t saved_sigmask; /* restored if set_restore_sigmask() was used */ struct sigpending pending;//进程上还需要处理的信号 unsigned long sas_ss_sp;//信号处理程序备用堆栈的地址 size_t sas_ss_size;//信号处理程序的堆栈的地址10.文件系统信息1234/* filesystem information */ struct fs_struct *fs;//文件系统的信息的指针/* open file information */ struct files_struct *files;//打开文件的信息指针task_struct的定义及注释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113struct task_struct &#123;volatile long state; //说明了该进程是否可以执行,还是可中断等信息unsigned long flags; //Flage 是进程号,在调用fork()时给出int sigpending; //进程上是否有待处理的信号mm_segment_t addr_limit; //进程地址空间,区分内核进程与普通进程在内存存放的位置不同 //0-0xBFFFFFFF for user-thead //0-0xFFFFFFFF for kernel-thread//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度volatile long need_resched;int lock_depth; //锁深度long nice; //进程的基本时间片//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHERunsigned long policy;struct mm_struct *mm; //进程内存管理信息int processor;//若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新unsigned long cpus_runnable, cpus_allowed;struct list_head run_list; //指向运行队列的指针unsigned long sleep_time; //进程的睡眠时间//用于将系统中所有的进程连成一个双向循环链表, 其根是init_taskstruct task_struct *next_task, *prev_task;struct mm_struct *active_mm;struct list_head local_pages; //指向本地页面 unsigned int allocation_order, nr_local_pages;struct linux_binfmt *binfmt; //进程所运行的可执行文件的格式int exit_code, exit_signal;int pdeath_signal; //父进程终止时向子进程发送的信号unsigned long personality;//Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序int did_exec:1;pid_t pid; //进程标识符,用来代表一个进程pid_t pgrp; //进程组标识,表示进程所属的进程组pid_t tty_old_pgrp; //进程控制终端所在的组标识pid_t session; //进程的会话标识pid_t tgid;int leader; //表示进程是否为会话主管struct task_struct *p_opptr,*p_pptr,*p_cptr,*p_ysptr,*p_osptr;struct list_head thread_group; //线程链表struct task_struct *pidhash_next; //用于将进程链入HASH表struct task_struct **pidhash_pprev;wait_queue_head_t wait_chldexit; //供wait4()使用struct completion *vfork_done; //供vfork() 使用unsigned long rt_priority; //实时优先级，用它计算实时进程调度时的weight值//it_real_value，it_real_incr用于REAL定时器，单位为jiffies, 系统根据it_real_value//设置定时器的第一个终止时间. 在定时器到期时，向进程发送SIGALRM信号，同时根据//it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。//当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送//信号SIGPROF，并根据it_prof_incr重置时间.//it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种//状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据//it_virt_incr重置初值。unsigned long it_real_value, it_prof_value, it_virt_value;unsigned long it_real_incr, it_prof_incr, it_virt_value;struct timer_list real_timer; //指向实时定时器的指针struct tms times; //记录进程消耗的时间unsigned long start_time; //进程创建的时间//记录进程在每个CPU上所消耗的用户态时间和核心态时间long per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS];//内存缺页和交换信息://min_flt, maj_flt累计进程的次缺页数（Copy on Write页和匿名页）和主缺页数（从映射文件或交换//设备读入的页面数）； nswap记录进程累计换出的页面数，即写到交换设备上的页面数。//cmin_flt, cmaj_flt, cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。//在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中unsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;int swappable:1; //表示进程的虚拟地址空间是否允许换出//进程认证信息//uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid//euid，egid为有效uid,gid//fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件//系统的访问权限时使用他们。//suid，sgid为备份uid,giduid_t uid,euid,suid,fsuid;gid_t gid,egid,sgid,fsgid;int ngroups; //记录进程在多少个用户组中gid_t groups[NGROUPS]; //记录进程所在的组//进程的权能，分别是有效位集合，继承位集合，允许位集合kernel_cap_t cap_effective, cap_inheritable, cap_permitted;int keep_capabilities:1;struct user_struct *user;struct rlimit rlim[RLIM_NLIMITS]; //与进程相关的资源限制信息unsigned short used_math; //是否使用FPUchar comm[16]; //进程正在运行的可执行文件名 //文件系统信息int link_count, total_link_count;//NULL if no tty 进程所在的控制终端，如果不需要控制终端，则该指针为空struct tty_struct *tty;unsigned int locks;//进程间通信信息struct sem_undo *semundo; //进程在信号灯上的所有undo操作struct sem_queue *semsleeping; //当进程因为信号灯操作而挂起时，他在该队列中记录等待的操作//进程的CPU状态，切换时，要保存到停止进程的task_struct中struct thread_struct thread; //文件系统信息struct fs_struct *fs; //打开文件信息struct files_struct *files; //信号处理函数spinlock_t sigmask_lock;struct signal_struct *sig; //信号处理函数sigset_t blocked; //进程当前要阻塞的信号，每个信号对应一位struct sigpending pending; //进程上是否有待处理的信号unsigned long sas_ss_sp;size_t sas_ss_size;int (*notifier)(void *priv);void *notifier_data;sigset_t *notifier_mask;u32 parent_exec_id;u32 self_exec_id;spinlock_t alloc_lock;void *journal_info;&#125;;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>进程调度算法</tag>
        <tag>task_struct结构体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[指针、数组、函数的“复杂关系]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%8C%87%E9%92%88%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%87%BD%E6%95%B0%E7%9A%84%E2%80%9C%E5%A4%8D%E6%9D%82%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[一、指针数组①定义指针数组: 首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。 例如：int p1[10]; 这是一个数组，其包含10 个指向int 类型数据的指针，即指针数组。int 修饰数组的元素。 ②应用:1.指针数组常用在主函数传参，在写主函数时，参数有两个，一个确定参数个数，一个这是指针数组用来接收每个参数（字符串）的地址。 int main(int argc, char *argv[]) 2.子函数传参的时候，传递数组的首地址，应该用二级指针接收。 void fun(char **pp);//子函数中的形参 fun(char *p[]);//主函数中的实参 二、数组指针①定义数组指针: 首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，不能直接得出它指向的数组占多少字节。它是“指向数组的指针”的简称。 例如：int (*p2)[10]; p2 是一个指针，它指向一个包含10 个int 类型数据的数组，即数组指针。int 修饰数组的内容。 ②应用1.123456789101112131415161718int main()&#123;char a[5] = &#123;'A', 'B', 'C', 'D'&#125;; char (*p3)[5] = &amp;a; char (*p4)[5] = a;//左边的类型是指向整个数组的指针，右边的数据类型是指向单个字符的指针，会进行隐式的类型转换，将a 指针转换为指向整个数组的指针 printf("%p \n",a);//数组首元素的地址 printf("%p \n", p3);//&amp;a 是整个数组的首地址 printf("%p \n", p4);//a是数组首元素的首地址 printf("%p \n", a + 1);//跳过一个char 类型的字节 printf("%p \n", p3 + 1);//跳过一个指针数组的字节 printf("%p \n", p4 + 1);//转换后 + 1 会跳过一个指针数组的字节 system("pause"); return 0;&#125; 2.12345678910111213141516int main()&#123; char a[5]=&#123;'A','B','C','D'&#125;; char (*p3)[10] = &amp;a; char (*p4)[10] = a; printf("%p \n",a);//数组首元素的地址 printf("%p \n", p3);//&amp;a 是整个数组的首地址 printf("%p \n", p4);//a是数组首元素的首地址 printf("%p \n", a + 1);//跳过一个char 类型的字节 printf("%p \n", p3 + 1);//跳过一个指针数组的字节 printf("%p \n", p4 + 1);//转换后 + 1 会跳过一个指针数组的字节 system("pause"); return 0;&#125; ④总结应用: 数组指针是一个指针，可以用来接收一个二维数组的地址。 void fun(int (*P)[4]);//子函数中的形参，数组指针 a[3][4] = {0};//主函数中定义的二维数组 fun(a);//主函数调用子函数的实参，是二维数组的首元素首地址 三、函数指针①定义函数指针: 函数指针就是函数的指针。它是一个指针，指向一个函数。 例如：void (*pfun1)(); pfun是一个指针变量，它指向一个函数，这个函数没有参数，函数的返回值为一个空类型。②应用1.12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;include &lt;asssert.h&gt;char * fun(char * p1,char * p2)&#123; assert(p1 != NULL); assert(p2 != NULL); int i = 0; i = strcmp(p1, p2);//字符串比较，若两者相等返回p1；否则返回 p2 if (0 == i) &#123; return p1; &#125; else &#123; return p2; &#125;&#125;int main()&#123; char * (*pf)(char * p1, char * p2);//pf是一个指针，指向一个参数为两个 char *，返回类型为 char *的函数 pf = &amp;fun;//将函数fun的地址赋给pf printf("%s \n", (*pf) ("aa", "bb"));return 0;&#125; 四、函数指针数组 ①定义函数指针数组: 把函数的地址存到一个数组中，那这个数组就叫函数指针数组。 例如：char (pf[3])(char *p); 它是一个数组，数组名为pf，数组内存储了3 个指向函数的指针。这些指针指向一些返回值类型为指向字符的指针、参数为一个指向字符的指针的函数。②应用1.转移表实现计算器12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;int Add(int a, int b)&#123; return a + b;&#125;int Sub(int a, int b)&#123; return a - b;&#125;int Mul(int a, int b)&#123; return a*b;&#125;int Div(int a, int b)&#123; return a / b;&#125;int div(int a, int b)&#123;return a / b;&#125;int main()&#123; int x = 0; int y = 0; int input = 1; int ret = 0; int(*p[5])(int x, int y) = &#123; 0, Add, Sub, Mul, Div &#125;; //转移表数组存放了不同子函数的地址 while (input) &#123; printf("*************************\n"); printf(" 1:Add 2:Sub \n"); printf(" 3:Mul 4:Div \n"); printf("*************************\n"); printf("请选择："); scanf("%d", &amp;input); if ((input &lt;= 4 &amp;&amp; input &gt;= 1)) &#123; printf("输入操作数："); scanf("%d%d", &amp;x, &amp;y); ret = (*p[input])(x, y); printf("ret = %d\n", ret); &#125; else printf("输入有误\n"); &#125; system("pause"); return 0;&#125; ③总结作用: 函数指针数组在子函数较多时可以通过不同的调用方法调用函数就来减少代码，使其更加简便。 五、指向函数指针数组的指针①定义指向函数指针数组的指针: 指向函数指针数组的指针是.一个指针，指针指向.一个 数组 ，数组的元素都是函数指针 。 例如：char ((pf)[3])(char p); pf 是指针。这个指针指向一个包含了3 个元素的数组；这个数组里面存的是指向函数的指针；这些指针指向一些返回值类型为指向字符的指针、参数为一个指向字符的指针的函数。②应用1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;char * fun1(char * p)&#123; printf("%s\n", p); return p;&#125;char * fun2(char * p)&#123; printf("%s\n", p); return p;&#125;char * fun3(char * p)&#123; printf("%s\n", p); return p;&#125;&#125;intmain()&#123; char * (*a[3])(char * p);//函数指针数组a char * (*(*pf)[3])(char * p);//指向函数指针数组的指针pf pf = &amp;a; a[0] = fun1;//函数名即函数地址 a[1] = &amp;fun2; a[2] = &amp;fun3; pf[0][0]("fun1"); pf[0][1]("fun2"); pf[0][2]("fun3"); system("pause");return 0;&#125; ③总结无论是指向函数指针数组的指针，还是其它的内容，都应该注意 * 和 [ ] 的结合，从而来辨清其概念。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>指针数组</tag>
        <tag>数组指针</tag>
        <tag>函数指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟实现memcpy和memmove函数]]></title>
    <url>%2F2018%2F11%2F01%2F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0memcpy%E5%92%8Cmemmove%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[模拟实现库函数memcpy和memmove函数 一、memcpy 关于memcpy函数:memcpy函数的原型为：void *memcpy(void *dest, void *src, unsigned int count);是在不相关空间中进行的可以将指定字节数的内容拷贝到目标空间的C库函数。返回值为一个指针。可以说memcpy函数是memmove函数的一个子函数。 模拟实现：1234567891011121314151617181920212223242526void * my_memcpy(void *dst, const void *sou, size_t num)&#123; assert(dst != NULL); assert(sou != NULL); void *ret = dst;//用空类型来接收参数和返回参数 while (num--) &#123; *(char *)dst = *(char *)sou;//因为不确定其参数类型，故将其强转为（char *）型用一个字节进行来计算 dst = (char *)dst + 1; sou = (char *)sou + 1; &#125; return ret;&#125;int main()&#123; char str1[] = "sbcdefghi"; char str2[] = "aabbcc"; int sz = sizeof(str2) / sizeof(str2[0]); char *ret = my_memcpy(str1, str2, 5); printf("%s \n", str1); system("pause"); return 0;&#125; 如图： 二，memmove 关于memcpy函数:memmove函数的原型为:void *memmove( void* dest, const void* src, size_t count );它和memcpy函数的区别即在于该函数可以实现内存重叠区域的内容拷贝，若目标区域和源区域没有重叠，则功能和memcpy函数相同。 模拟实现图解： 当目标区域的首地址小于原区域的首地址时 当目标区域的首地址大于原区域的首地址小于源区域的末地址时当目标区域首地址大于源区域整个空间时，无论是从前向后传值还是从后向前传值都可以。123456789101112131415161718192021222324252627282930313233343536373839404142void * my_memmove(void * dst, const void *sou, size_t count)&#123; void *ret = dst;//ret为空类型 assert(dst != NULL); assert(sou != NULL); if (dst &lt;= sou || (char *)dst &gt;= ((char *)sou + count)) &#123; while (count--) &#123; //从前向后拷贝 *(char *)dst = *(char *)sou;//一字节进行处理 dst = (char *)dst + 1; sou = (char *)sou + 1; &#125; &#125; else &#123; while (count--) &#123; //从后向前拷贝 *((char *)dst + count) = *((char *)sou + count);//count--已经完成减一，在这儿一定不要再减一 &#125; &#125; return (ret);&#125;int main()&#123; int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 ,0&#125;; int i = 0; int sz = sizeof(arr) / sizeof(arr[0]); my_memmove(arr + 3, arr ,4 * sizeof (int ));//把arr[0]到arr[3]拷贝到arr[3]之后的内存 for (i = 0; i &lt; sz; i++) &#123; printf("%d ", arr[i]); &#125; printf(" \n"); system("pause"); return 0;&#125; 如图：]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>模拟实现库函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几个经典的关于动态内存的面试题]]></title>
    <url>%2F2018%2F10%2F28%2F%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[经典永远是经典，永远值得人去学习，瞻仰。 学习了几个经典的关于动态内存的面试题，分享一下学习过程。一、12345678910111213141516171819void GetMemory(char *p)&#123; p = (char *)malloc(100);//局部变量，函数参数 p 存放在内存的栈区，用完销毁，&#125;void Test(void)&#123; char *str = NULL; GetMemory(str);//问题一、str指针变量，在函数传参时是值传递，即p是str的一份临时拷贝，当给 p 开辟空间后，返回Test函数，而空间已经在函数GetMemory运行完时被销毁了， //而且返回后对于str来说，并未开辟相应的空间，仍然是空指针 strcpy(str, "hello world"); printf(str);//问题二、内存泄漏&#125;int main()&#123; Test(); system("pause"); return 0;&#125; 修改后1234567891011121314151617181920void GetMemory(char **p)//用二级指针来接收str的地址&#123; *p = (char *)malloc(100);//给str 开辟空间&#125;void Test(void)&#123; char *str = NULL; GetMemory(&amp;str); strcpy(str, "hello world"); printf(str); printf("\n"); free(str); str = NULL;&#125;int main()&#123; Test(); system("pause"); return 0;&#125; 二、123456789101112131415161718char* GetMemory(void)&#123; char p[] = "hello world";//问题一、局部数组，创建之后在函数运行完之后会销毁， return p;//返回栈空间的地址出错&#125;void Test(void)&#123; char* str = NULL; str = GetMemory();//str野指针 printf(str);//输出随机值&#125;int main()&#123; Test(); system("pause"); return 0;&#125; 修改后12345678910111213141516171819char* GetMemory(void)&#123; char* p = "hello world"; return p;//函数返回时先传递给寄存器，然后再赋给str&#125;void Test(void)&#123; char* str = NULL; str = GetMemory(); printf(str);&#125;int main()&#123; Test(); system("pause"); return 0;&#125; 三、123456789101112131415161718void GetMemory(char **p, int num)&#123; *p = (char *)malloc(num);&#125;void Test(void)&#123; char *str = NULL; GetMemory(&amp;str, 100); strcpy(str, "hello world"); printf(str); printf("\n");//问题：内存泄漏&#125;int main()&#123; Test(); system("pause"); ret 修改123456789101112131415161718192021void GetMemory(char **p, int num)&#123; *p = (char *)malloc(num);&#125;void Test(void)&#123; char *str = NULL; GetMemory(&amp;str, 100); strcpy(str, "hello world"); printf(str); printf("\n"); free(str); str = NULL;&#125;int main()&#123; Test(); system("pause"); return 0;&#125; 四、1234567891011121314151617void Test(void)&#123; char *str = (char *)malloc(100); strcpy(str, "hello"); free(str); if (str != NULL)//访问内存出错，str已经释放 &#123; strcpy(str, "world"); printf(str); &#125;&#125;int main()&#123; Test(); system("pause"); return 0;&#125; 修改后1234567891011121314151617void Test(void)&#123; char *str = (char *)malloc(100); if (str != NULL) &#123; strcpy(str, "hello world"); printf(str); &#125; free(str); str = NULL;&#125;int main()&#123; Test(); system("pause"); return 0;&#125; 关于动态内存的常见错误，我会在接下来更新哦！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>动态内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让面试官满意的代码——模拟实现简单库函数]]></title>
    <url>%2F2018%2F10%2F26%2F%E8%AE%A9%E9%9D%A2%E8%AF%95%E5%AE%98%E6%BB%A1%E6%84%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%BA%93%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;关于C语言的库函数是面试官面试的热点护体，一方面是对函数的了解另一方面也是对C语言的应用有所考察。 一、模拟实现strlen 方式一 123456789101112//方式一：设置计数器int my_strlen(const char * str)&#123; assert(str != NULL); int count = 0; while (*str) &#123; str++; count++; &#125; return count;&#125; 方式二 12345678910//二、不能创建临时变量计数器——递归int my_strlen(const char * str)&#123; assert(str != NULL); if (*str == '\0') return 0; else return 1 + my_strlen(str + 1);&#125; 方式三 123456789101112//三、指针 — 指针 即元素个数int my_strlen(char *s)&#123; assert(s != NULL); char *p = s; while (*p != '\0') &#123; p++; &#125; return p - s;&#125; main函数 123456789int main()&#123; char str[] = "abcdef"; printf(" %d \n", my_strlen(str));//6 system("pause"); return 0;&#125; 二、模拟实现strcpy 1234567891011121314151617181920char *my_strcpy(char *target, const char *source)&#123; char *start = target; assert(target != NULL); assert(source != NULL); while (*target++ = *source++) &#123; ; &#125; return start;&#125;int main()&#123; char str1[10] = "0";//防止越界产生 char str2[15] = "abcdef"; printf("str1: %s \n", my_strcpy(str1, str2)); system("pause"); return 0;&#125; 三、模拟实现strcat 1234567891011121314151617181920212223char *my_strcat(char *target, const char *source)&#123; char *start = target; assert(target != NULL); assert(source != NULL); while (*target) &#123; target++; &#125; while (*target++ = *source++) &#123; ; &#125; return start;&#125;int main()&#123; char str1[15] = "abcdef"; char str2[] = "ghijk"; printf("str1: %s \n", my_strcat(str1, str2)); system("pause"); return 0;&#125; 四、模拟实现strstr 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748char *my_strstr(const char *str1, const char *str2)&#123; assert(str1); assert(str2); char *cp = (char *)str1; char *substr = (char *)str2; char *s1 = NULL; if (*str2 == '\0') &#123; return NULL; &#125; while (*cp) &#123; s1 = cp; substr = str2; while (*s1 &amp;&amp; *substr &amp;&amp; (*s1 == *substr)) &#123; s1++; substr++; &#125; if (*substr == '\0') &#123; return cp; &#125; cp++; if (*cp == '\0') return NULL; &#125;&#125;int main()&#123; const char str1[] = "abbbcccdefgh"; const char str2[] = "ghi"; char *ret = my_strstr(str1, str2); if (ret == NULL) &#123; printf(" str2 不是 str1 的子字符串\n"); &#125; else &#123; printf(" str2 是 atr1 的从 %d 位开始的子字符串\n",ret - str1+1); &#125; system("pause"); return 0;&#125; 五、模拟实现strchr 12345678910111213141516171819202122232425262728char *my_strchr(const char *str, char c)&#123; assert(str != NULL); while (*str) &#123; if (*(str++) == c)//对实际地址进行了后置++操作 &#123; return str - 1; &#125; &#125; return NULL;&#125;int main()&#123; char str[] = "abcdefdgh"; char c = 'a'; char *p = my_strchr(str, c); if (NULL == *p) &#123; printf(" %s 字符串中没有 %c 字符\n",str, c); &#125; else &#123; printf("%c 首次出现在 %s 的位置是：%d \n",c, str, p - str + 1); &#125; system("pause"); return 0;&#125; 六、模拟实现strcpy 12345678910111213141516171819202122232425262728293031323334353637383940int my_strcmp(const char *s1, const char *s2)&#123; assert(s1 != NULL); assert(s2 != NULL); int ret = 0; while (!(ret = *(unsigned char *)s1 - *(unsigned char *)s2) &amp;&amp; *s2)// 用！操作符控制循环，将比较换为减法得到数值正负， &#123; ++s1; ++s2; &#125; if (ret &lt; 0) &#123; ret = -1; &#125; else if (ret &gt; 0) &#123; ret = 1; &#125; return ret;&#125;int main()&#123; char str1[] = "cd"; char str2[] = "ab"; int i = my_strcmp(str1, str2); if (0 == i) &#123; printf("str1 :%s 和 str2 :%s 相等\n",str1, str2); &#125; else if (0 &lt; i) &#123; printf("str1:%s 大于 str2:%s \n",str1, str2); &#125; else &#123; printf("str1:%s 小于 str2:%s \n", str1, str2); &#125; system("pause"); return 0;&#125; 小结好东西要留到最后阐述，一步一步的深入去讲应该是一个不错的选择！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>模拟C库函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习基础]]></title>
    <url>%2F2018%2F10%2F25%2FLinux%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[&emsp;了解到Linux系统的产生和发展的过程，对于我来说是一件很幸运的事情，因为这件事让我看到了技术人的品质，开源真的是对技术人的最好的奖励，可以让代码承接自己的精神传扬下去。 一. 基本命令 01. ls指令 语法：ls [选项] [目录或文件功能：目录：该命令列出该目录下所有子目录与文件。文件：列出文件名即其他信息常用选项： -a 列出目录下所有文件，包括以 . 开头的隐含文件. -i 输出文件的 i 节点的索引信息。 -l 列出文件的详细信息。 02. pwd命令 语法：pwd功能：显示用户当前所在目录 03. cd指令 语法：cd 目录名功能：改变工作目录， 将当前工作目录改变到指定目录下举例： cd .. ：返回上级目录 cd /home/xiaomoing/lunix/ ：绝对路径 cd ../day02/ :相对路径 cd ~:进入用户目录 cd -:返回最近访问目录 04. touch指令 语法:touch [选项]…文件…功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间，或者新建一个不存在的文件常用选项： -d 使用指定的日期或时间。 -r 把指定文档或目录的日期时间，设定成和参考文档或目录的日期时间相同 05. mkdir指令 语法：mkdir [选项] dirname…功能：在当前目录创建一个名为”diname” 的目录常用选项: -p –parents 可以是一个路径名称， 此时若路径上的某些目录不存在，系统可以一次建立多个目录 06. rmdir指令 和 rm 指令 语法：rmdir [-p][driName]功能：删除空目录常用选项： -p 当前子目录被删除后如果父目录为空，就连带删除父目录语法：rm [-f-i-r-v][dirName/dir]功能：删除文件或目录常用选项： -f 文件为只读时也可以删除 -i 删除前逐一询问确认 -r 删除目录及其下所有文件 07. man指令 语法：[选项] 命令功能：访问Lunix手册常用选项： -k 根据关键字搜索联机帮助 -a 将所有的章节都显示出来 08. cp指令 语法：cp [选项] 源文件或目录 目标文件或目录功能：复制文件或目录说明：cp指令用于复制文件或目录， 如同时指定两个以上的文件或目录， 且最后的目的地是一个已经存在的目录， 则它会把前面指定的所有文件或目录复制到此目录中，若不存在，则会显示错误信息。常用选项： -f 强制复目录或文件， 不论文件或目录是否存在 -i 覆盖文件之前询问用户 -r 递归处理，将指定目录下的文件与子目录一并处理 -R 递归处理 09. mv指令 语法：mv [选项] 源文件或目录 目标文件或目录功能：视命令中第二个参数类型的不同（是目标文件还是目标目录），MV命令将文件重命名或将其移入一个新的目录中。当第二个参数类型是文件时，完成文件重命名。当第二个参数类型是已存在的目录时，源文件或目录参数可以有多个，mv命令将各参数指定的文件均移动到目标目录中。常用选项： -f 如果目标文件已经存在，直接覆盖不会询问 -i 若目标文件已经存在，会询问是否覆盖 10. cat/tac指令 语法：cat [选项][文件]功能：查看目标文件的内容常用选项： -b 对非空输出行编号 -n 对输出的所有行进行编号 -s 不输出多行空行 11. more指令 语法：more [选项][文件]功能：功能类似cat常用选项： -n 对输出所有行进行编号 ｑ 退出more 12. less指令 语法：less [参数] 文件功能：使用less可以随意浏览文件，且在查看前不会加载整个文件常用选项： -i 忽略搜索时的大小写 -N 显示每行的行号 /字符串 向下搜索“字符串”的功能 ?字符串 向上搜索“字符串”的功能 n: 重复前一个搜索 13. head指令 语法：head [参数]…[文件]…功能：显示档案的开头至标准输出中，默认打印开头10行选项： -n&lt;行数&gt; 显示的行数 14. tail指令 语法：tail [必要参数][选择参数][文件]功能：显示指定文件末尾内容，不指定文件时作为输入信息进行处理，从指定点开始将文件写入标准输出，选项： -f 循环读数 -n&lt;行数&gt; 显示行数 15. Cal指令 语法：cal [参数][月份][年份]功能：用于查看日历常用选项： -3 显示系统的前一个月，当前月，下一个月的日历 -j 显示当年的第几天 -y 显示当前年份的日历 16. find指令 语法：find pathname ~options功能：用于在文件树查找文件，并作出相应的处理选项：-name 按照文件名查找文件 17. grep指令 语法：gre [选项]搜寻字符串 文件功能：在文件中搜索字符串，将找到的行打印出来常用选项： -i 忽略大小写的不同 -n 输出行号 -v 反向选择， 显示出没有“搜寻字符串”内容的那一行 18. zip/unzip指令 语法：zip 压缩文件.zip 目录或文件功能：将目录或文件压缩成zip格式常用选项： -r 递归处理,将指定目录下所有的文件与子目录一并处理 19. tar指令 语法：tar [选项]文件与目录…参数…功能：打包/解包，不打开它，直接看内容常用选项： -c 建立一个压缩文件的参数指令 -x 解开一个压缩文件的参数指令 -z 是否同时具有gzip的属性？ -f 使用档名，请留意，在f之后要立即接档名，不要加参数 20. uname指令 语法：uname [选项]功能：获取电脑和操作系统的相关信息常用选项： -a 或-all 详细输出所有信息 二. 进入目录需要哪些权限, 在目录中执行增删查(cd, touch, ls, rm, mv等)改文件动作, 需要哪些权限.Linux中的基本权限（r、w、x） 1、读（r/4）：read对于文件来说，具有读取文件内容的权限；对于目录来说，具有浏览该目录信息的权限。 2、写（w/2）：write对于文件来说，具有修改文件内容的权限；对于目录来说，具有删除、移动目录内文件的权限。 3、执行（x/1）；execute对于文件来说，具有执行文件的权限；对于目录来说，具有进入目录的权限。 文件权限值得表示方法 a)字符表示方法 b)8进制数值表示方法 修改权限的方法 1. chmod chmod [参数] 权限 文件名 设置文件的访问权限 一. 用户表示符 +/-=权限字符 实例： 二. 三位8进制数字 实例 三．进入目录需要哪些权限, 在目录中执行增删查(cd, touch, ls, rm, mv等)改文件动作, 需要哪些权限？ cd：a.语法 cd 目录名（进入目录） b.所需权限x touch：a.语法 touch 文件名（创建文件） b.所需权限wx ls：a.语法 ls （显示当前目录下的所有文件） b.所需权限rx rm：a.语法 rm 文件名（删除文件） b.所需权限wx mv：a.语法 mv 文件名1 文件名2（把文件名1修改为文件名2） b.所需权限wx 三. Linux下的重要目录/proc, /sys, /SElinux, /bin, /usr/lib, /usr/local, /var, /tmp /proc:特殊文件目录。这个目录采用一种特殊的文件格式（proc格式，内核支持这种格式。其中包括了全部虚拟文件。它们并不是保存在磁盘中，也不占用磁盘空间，当查看它们时，实际上看到的是内存里的信息，这些文件有助于我们了解系统内部信息）。 /sys: 文件系统访问 Linux内核 /SElinux:SELinux是一种基于域-类型模型(domain-type)的强制访问控制(MAC)安全系统，它由NSA编写并设计成内核模块包含到内核中，相应的某些安全相关的应用也被打了SELinux的补丁，最后还有一个相应的安全策略 /usr/lib:/usr/local/lib： 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules /usr/local:存放软件升级包 /var:内容经常变化的目录。此目录下文件的大小可能改变，如缓冲文件、日志文件、缓存文件等一般会放在这里 /tmp:一般用户或正在执行的程序临时存放文件的目录即临时文件,任何人都可以访问,重要数据不可放置在此目录下 四. 重要命令. du, df, top, free, pstack, su, sudo(sudo -, sudo -s), adduser, password du 作用是磁盘空间使用情况，功能是逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块的情况，如果没有指定目录，则对当前的目录进行统计。主要参数： s：只显示各档案大小的总合 b：大小用bytes来表示 x：跳过在不同文件系统上的目录不予统计 a：递归地显示指定目录中各文件及子孙目录中各文件占用的数据块数 df 命令用来检查文件系统的磁盘空间占用情况，使用权限是所有用户。主要参数： －s：对每个Names参数只给出占用的数据块总数。 －a：递归地显示指定目录中各文件及子目录中各文件占用的数据块数。若既不指定－s，也不指定－a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。 －k：以1024字节为单位列出磁盘空间使用情况。 －x：跳过在不同文件系统上的目录不予统计。 －l：计算所有的文件大小，对硬链接文件则计算多次。 －i：显示inode信息而非块使用量。 －h：以容易理解的格式印出文件系统大小，例如136KB、254MB、21GB。 －P：使用POSIX输出格式。 －T：显示文件系统类型 top 基本格式df [options]作用:命令用来显示执行中的程序进程，使用权限是所有用户主要参数： d：指定更新的间隔，以秒计算。 q：没有任何延迟的更新。如果使用者有超级用户，则top命令将会以最高的优先序执行。 c：显示进程完整的路径与名称。 S：累积模式，会将己完成或消失的子行程的CPU时间累积起来。 s：安全模式。 i：不显示任何闲置(Idle)或无用(Zombie)的行程。 n：显示更新的次数，完成后将会退出top。 free 格式free [－b|－k|－m] [－o] [－s delay] [－t] [－V]作用:free命令用来显示内存的使用情况，使用权限是所有用户。主要参数： －b －k －m：分别以字节（KB、MB）为单位显示内存使用情况。 －s delay：显示每隔多少秒数来显示一次内存使用情况。 －t：显示内存总和列。 －o：不显示缓冲区调节列。 pstack:显示每个进程的栈跟踪pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。 su 格式 su [选项]… [-] [USER [ARG]…]作用是变更为其它使用者的身份，超级用户除外，需要键入该使用者的密码。主要参数： -f ， –fast：不必读启动文件（如 csh.cshrc 等），仅用于csh或tcsh两种Shell。 -l ， –login：加了这个参数之后，就好像是重新登陆为该使用者一样，大部分环境变量（例如HOME、SHELL和USER等）都是以该使用者（USER）为主，并且工作目录也会改变。如果没有指定USER，缺省情况是root。 -m， -p ，–preserve-environment：执行su时不改变环境变数。 -c command：变更账号为USER的使用者，并执行指令（command）后再变回原来使用者。 USER：欲变更的使用者账号，ARG传入新的Shell参数。 sudo(sudo -, sudo -s)命令的配置在/etc/sudoers文件中。当用户使用sudo时，需要输入口令以验证使用者身份。随后的一段时间内可以使用定义好的命令，当使用配置文件中没有的命令时，将会有报警的记录。sudo是系统管理员用来允许某些用户以root身份运行部分/全部系统命令的程序。一个明显的用途是增强了站点的安全性，如果需要每天以超级用户的身份做一些日常工作，经常执行一些固定的几个只有超级用户身份才能执行的命令，那么用sudo是非常适合的。 pstack 命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。 adduser（1）创建用户命令两条： adduser useradd（2）用户删除命令： userdel两个用户创建命令之间的区别： adduser： 会自动为创建的用户指定主目录、系统shell版本，会在创建时输入用户密码。 useradd：需要使用参数选项指定上述基本设置，如果不使用任何参数，则创建的用户无密码、无主目录、没有指定shell版本。 password:登陆密码管理passwd 作为普通用户和超级权限用户都可以运行，但作为普通用户只能更改自己的用户密码，但前提是没有被root用户锁定；如果root用户运行passwd ，可以设置或修改任何用户的密码；主要参数： -d：删除密码，仅有系统管理者才能使用； -f：强制执行； -k：设置只有在密码过期失效后，方能更新； -l：锁住密码； -s：列出密码的相关信息，仅有系统管理者才能使用； -u：解开已上锁的帐号。 五. 如何使用命令安装gcc/g++, gdb, vimvim是Linux下的编辑器，linux中使用gcc来编译C程序，使用g++来编译C++程序，使用gdb来调试程序 一、vim安装完Centos 后，默认是安装了Vi编辑器的。但Vim编辑器是没安装或者未完全安装的。1）首先，检测是否已经安装过Vim;输入命令：rpm -qa|grep vim显示出完整的包名： vim-common,vim-enhanced,vim-minimal,vim-filesystem 表示安装成功，有的centos系统，默认包名不同。2）若是缺少Vim包名：则在root下使用命令如下：比如说： vim-minimal这个包少了，执行：yum -y install vim-minimal 命令，它会自动下载安装。3）若下载完成，进行安装：命令：yum -y install vim* 安装完成后则可以使用vim编辑器 二、gcc/g++Centos中使用yum来配置gcc和g++，在root账户下，若要安装gcc，则在命令行中输入:yum -y install gcc，按回车键就能够进行gcc的安装;若要安装g++，则需要在命令行中输入：yum -y install gcc-c++，就能够进行g++的安装。gdb先使用如下命令看系统中是否安装了gdb，如果安装了，如下图如果没有安装，则Centos中使用yum来安装gdb,在root账户下，在命令行中输入：yum install gdb，使用：which gdb 查看是否安装成功]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>重要目录</tag>
        <tag>GCC/G++等安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈应用及迷宫问题]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%A0%88%E5%BA%94%E7%94%A8%E5%8F%8A%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、栈 栈是一种重要的线性结构，在数据结构而言，其本质操作是线性表操作的子集。但在数据类型来说，是一种重要的抽象数据类型。在面向对象的程序设计中，栈是多数据类型。 栈只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。不含任何元素的栈称为空栈，栈又称为后进先出的线性表，简称LIFO结构。栈可以将数据从一种序列变到另一种序列。 二、栈的分类 顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，一般使用过程中所需的最大空间，故先给栈分配一个基本容量，在使用过程中然后增容。 链式栈，是一种不连续的存储结构，元素以Node的形式存储，包含数据域和指针域，指针域指向下一个节点，每个节点随机分布，为动态开辟节点。 三、栈的基本模块无论是链式栈还是顺序栈其基本操作都一样，包含栈的创建，初始化，销毁，插入，删除，取栈顶元素等，只是其实现方式不同。下面就是顺序栈的模块。栈代码：头文件”Stack.h”12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;////typedef int DataType;////#define N 10//typedef struct Stack//&#123;// DataType _a[N];//规定数组空间大小// int _top; // 栈顶//&#125;Stack;//静态栈typedef struct Pos&#123; int _row; int _col;&#125;Pos;//迷宫位置点typedef Pos DataType;typedef struct Stack&#123; DataType* _a; //节点指针 int _top; // 栈顶 int _capacity; // 容量&#125;Stack;void StackInit(Stack* ps);//初始化void StackDestory(Stack* ps);//销毁void StackPush(Stack* ps, DataType x);//压栈void StackPop(Stack* ps);//出栈DataType StackTop(Stack* ps);//取栈顶元素int StackEmpty(Stack* ps);//判空int StackSize(Stack* ps);//栈的大小//void TestStack();函数文件”Stack.c”12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include "Stack.h"void StackInit(Stack* ps)&#123; ps-&gt;_a = (DataType*)malloc(sizeof(DataType)* 3);//动态开辟空间 assert(ps);//防止开辟失败 ps-&gt;_capacity = 3; ps-&gt;_top = 0;&#125;void StackDestory(Stack* ps)&#123; assert(ps);//断言 if (ps-&gt;_a) &#123; free(ps-&gt;_a); ps-&gt;_a = NULL; ps-&gt;_capacity = ps-&gt;_top = 0; &#125; while (ps-&gt;_top--) &#123; free(ps-&gt;_top); &#125; ps-&gt;_capacity = 0;&#125;void StackPush(Stack* ps, DataType x)&#123; assert(ps); if (ps-&gt;_top == ps-&gt;_capacity)//越界 &#123; ps-&gt;_a = (DataType*)realloc(ps-&gt;_a, sizeof(DataType)*(ps-&gt;_capacity * 2));//增容 assert(ps-&gt;_a); ps-&gt;_capacity *= 2; &#125; ps-&gt;_a[ps-&gt;_top] = x; ps-&gt;_top++;&#125;void StackPop(Stack* ps)&#123; assert(ps-&gt;_a); assert(ps-&gt;_top &gt; 0); ps-&gt;_top--;&#125;DataType StackTop(Stack* ps)&#123; assert(ps-&gt;_a &amp;&amp; ps-&gt;_top &gt; 0); return ps-&gt;_a[ps-&gt;_top - 1];&#125;//空 0//非空 1int StackEmpty(Stack* ps)&#123; assert(ps); return ps-&gt;_top == 0 ? 0 : 1;&#125;int StackSize(Stack* ps)&#123; assert(ps); return ps-&gt;_top;&#125;//测试代码//void TestStack()//&#123;// Stack s;// StackInit(&amp;s);//// StackPush(&amp;s, 1);// StackPush(&amp;s, 2);// StackPush(&amp;s, 3);// StackPush(&amp;s, 4);//// while (StackEmpty(&amp;s))// &#123;// printf("%d ",StackTop(&amp;s));// StackPop(&amp;s);// &#125;// printf("\n");////// StackDestory(&amp;s);//&#125; 四、迷宫 迷宫问题，望文生义就是在迷宫当中找到出口，出入口自定义，解决迷宫问题的过程中以回溯法为思想，应用栈的知识来解决这个问题。对于迷宫问题的思考是由解决简单的迷宫然后到环路迷宫这样一个过程的。 回溯法：对一个包括有很多个结点，每个结点有若干个搜索分支的问题，把原问题分解为若干个子问题进行求解的算法；当搜索到某个结点发现无法再继续搜索下去时，就让搜索过程回溯到该结点的前一个结点，继续搜索该结点外的其他尚未搜索的分支；如果发现该结点无法再搜索下去，就让搜索过程回溯到这个结点的前一个结点继续这样的搜索过程。 1.简单迷宫——–从出口处将开始进行压栈，判断其上，下，左，右方向是否可走，若某个方向可走将其坐标进行压栈，并将坐标上的值置为2，再探测该坐标的分支，直到出口，返回1即找到出口，若在某一个结点处四个方向均不可走则返回上一个坐标，并将该坐标从栈中释放，若栈为空时仍未到出口处则返回0即未找到出口。0 0 0 0 0 00 0 1 0 0 00 0 1 0 0 00 0 1 1 1 00 0 1 0 1 10 0 1 0 0 0 2.多路迷宫——–在简单迷宫的基础上当找到出口时并不返回值，当栈为空即回溯到出口时返回到主函数。0 0 0 0 0 00 0 1 0 0 00 0 1 1 1 10 0 1 0 0 00 0 1 1 1 10 0 1 0 0 0 3.环路迷宫——–在多路迷宫的基础上，在设置压入栈的坐标的值时换为前一个坐标的值加1,即递增的。在判断某个坐标是否可走时变换条件，进而达到目的。0 0 0 0 0 00 0 1 1 1 00 0 1 0 1 00 0 1 0 1 00 0 1 1 1 10 0 1 0 0 0 迷宫代码（环路迷宫代码）：头文件”maze.h” 12345678910111213141516171819202122232425262728293031323334#pragma once#include"Stack.h"#define N 6int size;static int maze[N][N] = &#123;//static,只在maze.c中可见 /*&#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;,*/ /*&#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 0 &#125;, &#123; 0, 0, 1, 0, 1, 0 &#125;, &#123; 0, 0, 1, 0, 1, 0 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;,*/ &#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 0 &#125;, &#123; 0, 0, 1, 0, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;,&#125;;int GetMazePath(Pos entry, Pos exit);//获取迷宫通路:找到通路/找不到通路int CheckAccess(Pos cur, Pos next);void PrintfMaze();void TestMaze(); 函数文件”maze.c” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include"Maze.h"int CheckAccess(Pos cur, Pos next)&#123; if (next._row &gt;= 0 &amp;&amp; next._row &lt; N &amp;&amp;next._col &gt;= 0 &amp;&amp; next._col &lt; N &amp;&amp; (maze[next._row][next._col] == 1 || maze[next._row][next._col] &gt; maze[cur._row][cur._col] + 1))//当下一个坐标的值为1 或者比当前值加一还大就可以走 &#123; return 1; &#125; else &#123; return 0; &#125;&#125;int size = 0;int GetMazePath(Pos entry, Pos exit)&#123; Stack path; int flag = 0; StackInit(&amp;path); StackPush(&amp;path, entry); maze[entry._row][entry._col] = 2;//入口初始化为2 while (StackEmpty(&amp;path)) &#123; //Pos cur = entry;//当前位置 Pos cur = StackTop(&amp;path);//栈顶取出的当前位置 //if (cur._col == 5)//多条通路 if (cur._row == exit._row &amp;&amp;cur._col == exit._col)//当一条路径找到出口时，打印路径并且看路径长短 &#123; flag = 1; for (int i = 0; i &lt; path._top; i++) &#123; printf("[%d %d]-&gt;", path._a[i]._row, path._a[i]._col); &#125; printf(" Exit\n\n"); if (size == 0 || StackSize(&amp;path) &lt; size) &#123; size = StackSize(&amp;path);//路径的长短 &#125; &#125; Pos next; //上 next = cur;//当前位置 next._row -= 1;//下一个位置 if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //下 next = cur; next._row += 1; if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //左 next = cur; next._col -= 1; if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //右 next = cur; next._col += 1; if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //走到四个方向不通的位置 //回溯 StackPop(&amp;path); &#125; if (flag == 0)//判断是否找到出口 return 0; else return 1;&#125;void PrintfMaze()&#123; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; printf("%d ", maze[i][j]); &#125; printf("\n"); &#125; printf("\n");&#125; 主函数文件”main.c” 12345678910111213141516171819202122232425262728293031#include "maze.h"void TestMaze()&#123; Pos entry; entry._row = 5; entry._col = 2; Pos exit; exit._row = 4; exit._col = 5; printf("迷宫地图:\n"); PrintfMaze(); if (GetMazePath(entry, exit)) &#123; printf("有出口，最短路径为：%d \n\n", size); &#125; else &#123; printf("无出口！\n\n"); &#125; printf("走出后迷宫地图:\n"); PrintfMaze();&#125;int main()&#123; TestMaze(); system("pause"); return 0;&#125; 五、运行结果 1.简单迷宫 2.多路迷宫 3.环路迷宫 结合之前的栈的基本操作代码就可以解决迷宫问题了。-(￣▽￣)-]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>迷宫</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux开发工具相关问题]]></title>
    <url>%2F2018%2F10%2F21%2FLinux%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在Linux的系统设置问题上，学会使用文本编辑器来编辑Linux参数配置文件是一项很重要的能力。Linux环境下的文本编辑器有很多，重点掌握VIM却是很有必要的。VIM是VI的升级版，很多软件的编辑接口会主动调用VI，而VIM已经不仅仅可以作为一个文本编辑器，也可以作为程序开发工具，供程序开发者使用。 一、 vim的配置 一些简单配置Linux的命令有： set nu // 在左侧行号set tabstop=4 //tab 长度设置为 4set nobackup //覆盖文件时不备份set cursorline //突出显示当前行set ruler //在右下角显示光标位置的状态行set autoindent //自动缩进set mouse=a //允许使用鼠标移动光标set showmode //显示左下角状态行set hlsearch //搜索时关键字高亮反白set showcmd 配置vim的文件在目录/etc下面，有个名为vimrc的文件，这就是系统中公共的vim配置文件，对所有用户都开放。而在每个用户的主目录下，都可以自己建立私有的配置文件，命名为：”.vimrc”。用vim打开.vimrc键入上述命令保存即可。 关于vim的简单配置详细的介绍：VIM简单配置如何获得良好的界面：vim配置界面要想获得更强大的功能可以点击：大牛：超级强大的VIM配置(vimplus) 二、常用的编辑器, 以及这些编辑器之间的区别和优缺点.Linux中强大的编辑器列表 VI 编辑器是一个基于命令行的、功能强大的文本编辑器，最早为 Unix 系统开发，后来也被移植到许多的 Unix 和 Linux 发行版上。 VIM（也被称作 VI IMproved）——VI 编辑器的高阶版本，在 VI 已经很强的功能上添加了更多的功能，这些功能有： 支持更多 Linux 发行版， 支持多种编程语言，包括 python、c++、perl 等语言的代码块折叠，语法高亮， 支持通过多种网络协议，包括 http、ssh 等编辑文件， 支持编辑压缩归档中的文件， Emacs：著名的集成开发环境和文本编辑器。Emacs和Vim对于 Linux 桌面上进行文本编辑是重量级的，Emacs演化出了众多分支，其中使用最广泛的两种是：1984年由Richard Stallman发起的GNU Emacs，以及1991年发起的XEmacs。XEmacs是GNU Emacs的分支，至今仍保持着相当的兼容性。最新的的GNU EMACS的功能包括: 内容感知编辑模式，包括许多文件类型的语法着色。 完整的内置文档，包括新用户教程。 几乎所有人类脚本都支持 完全Unicode。 高度可定制，使用Emacs Lisp代码或图形界面。 超越文本编辑，包括功能的整个生态系统的项目策划人，邮件和新闻阅读器，调试器接口， 日历，和更多。 用于下载和安装扩展的包装系统等等 详情点击：GNU Eclipse：Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。最初主要用来Java语言开发，但是目前亦有人通过插件使其作为其他计算机语言比如C++和Python的开发工具。 在Eclipse中，完全胜任以下编程语言的工作——Python, R, Ruby, JavaScript, Natural, Lasso, C, C++, COBOL, Scheme, Clojure, Groovy等等 Eclipse官网：ECLIPSEFOUNDATION Brackets：Adobe公司发布了Brackets 1.0，一款针对Web设计人员的免费开源文本编辑器，内置HTML，CSS和JavaScript，方便开发者进行HTML，CSS和JavaScript编程。Brackets 1.0适用于Windows，Mac和Linux操作系统，为Web设计人员和开发人员提供针对性的功能，如： 实时预览，在浏览器视图和源代码之间轻松切换， 在特定的代码位进行内联编辑工作，而无需弹出式窗口或其他选项卡。 下载和使用扩展，添加功能以帮助他们的工作流程，如Git整合和JSHint支持 摘要预览，自动从PSD获取设计信息， Brackets作为一个开源项目，对于想要自定义文本编辑器的用户，可以从Github上Brackets项目页面下载源代码并修改代码进行编译，来适合自己的需求。 官方网站：http://brackets.io/ Github代码托管：https://www.github.com/adobe/brackets LightTable是一个免费开放源代码的编辑器，该编辑器有一个非常干净的界面，并有大量扩展。它与Windows、Mac和Linux都兼容，是高度可定制的。使用Light Table，开发者只需打开一个浏览器窗口即可实时查看更改，并且支持不同的嵌入。 更改: 我们从 NW.js 切换到了 Electron 更改: Light Table 的发行与自更新进程完全地公开在github上 增加: Light Table 可以用提供的脚本在各个支持的平台上从源码构建 增加: Light Table 大部分的 node 代码库将通过 npm 依赖来安装，以取代以前采用分叉库的方式 增加: 有效文档。更多详情内容见下面 修复: 版本号 &gt;= OSX 10.10的系统下的主要的可用性问题 更改: 官方不再提供 32位 Linux 软件包下载，不过仍然支持从源码构建 修复: ClojureScript eval 支持 ClojureScript 的现代版本 参阅更多 github.com/LightTable/LightTable/releases Chocolat：Chocolat本身是Mac OS 的最佳代码编辑器。该编辑器旨在与OS无缝集成，Chocolat为JS、Python和HTML提供拖放功能、拆分编辑、代码折叠和代码完成，兼具原生的Cocoa及强大的文本编辑功能。Chocolat支持很多种编程语言的关键字高亮显示、窗口分割、标签页、色彩主题等功能。界面和MacVim非常相似。 Sublime Text：Sublime Text 是一个轻量、简洁、高效、跨平台的编辑器。 支持多光标操作：它能让你对文本中的多个地方同时做修改，你可以看到多个地方在你输入的时候同时发生变化， command palette能够让你轻松的做任何操作，勉去了记忆众多快捷键的痛苦。你只需要打开command palette ，输入几个字母，Sublime Text会用模糊查询给你提供建议和选项。跟直接使用快捷键几乎没区别 编辑文件的同时你可以启动编译，看到输出结果，这种交互能让你快速发现编译错误 扩展性很好，它使用了Python式的插件系统。 三、 常用的编译器(不限制编程语言, 不限制平台) MSVC:是指微软的VC编译器,随着微软发布基于Clang / C2,MSVC与Clang / C2并行，继 Google Chrome 宣布弃用微软 C++ 编译器（MSVC）Windows 版 Chrome 改用 Clang 之后，Mozilla 的 Firefox 浏览器也宣布开始使用 Clang 编译器编译其 Windows 版本。 Clang：Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的 C/C++/Objective C/Objective C++ 编译器，其目标（之一）就是超越 GCC。Clang 的特性有： 快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 是 Apple GCC 4.0 的 2.5x 快。 内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10x。 诊断信息可读性强：其中错误的语法不但有源码提示，还会在错误的调用和相关上下文的下方有提示。 GCC 兼容性。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 基于库的模块化设计，易于 IDE 集成及其他用途的重用。由于历史原因，GCC 是一个单一的可执行程序编译器，其内部完成了从预处理到最后代码生成的全部过程，中间诸多信息都无法被其他程序重用。Clang 将编译过程分成彼此分离的几个阶段，AST 信息可序列化。通过库的支持，程序能够获取到 AST 级别的信息，将大大增强对于代码的操控能力。对于 IDE 而言，代码补全、重构是重要的功能，然而如果没有底层的支持，只使用 tags 分析或是正则表达式匹配是很难达成的。 GCC/G++：gcc和g++都是GNU(组织)的一个编译器。gcc 是c的编译器，g++是c++的编译器。(常见GCC和G++的误区：[GCC和G++的区别])(https://my.oschina.net/Failure/blog/114283) ICC：全称Intel C++ Compiler，是Intel开发的C/C++/Fortran编译器套装，适用于Linux、Microsoft和Mac OS X操作系统，没有非IA指令集版本(就是说仅供x86架构CPU使用)。ICC广泛应用于高性能计算、分布式计算等商业计算领域，其向量化和并行化性能是业界的标杆，能够充分发挥现代处理器的特性。(ICC官方网：)ICC IBM XL C++：IBM® XL C/C++ 是一种编译器，有助于为 IBM Power Systems™ 创建和维护使用 C/C++ 编写的应用，能最大限度地提高硬件利用率。缺点则是在编译时间上往往过长。对C++标准的支持、开源软件的支持、错误信息的提示上都不够友好，但随着13.2开始结合Clang正在进行优化。(官方网站：[IBM XL C++](https://www.ibm.com/cn-zh/marketplace/xl-cpp-aix-compiler-power)) 四、为什么调试的时候需要编译选项中添加 -g. 介绍readelf命令.1 .调试的时候加上 -g 是为了生成调试信息，以便于GNU调试器利用该信息，2.readelf命令用来显示一个或者多个elf格式的目标文件的信息，可以通过它的选项来控制显示哪些信息。这里的elf-file(s)就表示那些被检查的文件。可以支持32位，64位的elf格式文件，也支持包含elf文件的文档（这里一般指的是使用ar命令将一些elf文件打包之后生成的例如lib*.a之类的“静态库”文件）。(ELF文件， 其实就是Executable &amp; Linkable Format, 是一种文件格式， 我们常见的目标文件、动态库和可执行文件， 都属于这个类型。)五、 在Linux下实现进度条程序. 通过makefile进行编译. 以及实现全彩色的进度条.1.缓冲区概念缓冲区(buffer)这个中文译意源自当计算机的高速部件与低速部件通讯时,必须将高速部件的输出暂存到某处,以保证高速部件与低速部件相吻合. 后来这个意思被扩展了,成为”临时存贮区”的意思。 缓冲区分为：无缓冲、行缓冲、全缓冲。 无缓冲：表示的是没有缓冲，可以将信息立马显现出来，典型代表是标准错误流stderr。 行缓冲：表示的是输入输出遇到换行才执行真正的I/O操作。典型的代表是键盘的操作。 全缓冲：表示的是输入输出写满缓冲区才执行I/O操作。典型的代表是磁盘的读写。 fflush: fflush，函数名， 清除读写缓冲区，需要立即把输出缓冲区的数据进行物理写入时。 fflush(stdin)刷新标准输入缓冲区，把输入缓冲区里的东西丢弃[非标准] fflush(stdout)刷新标准输出缓冲区，把输出缓冲区里的东西打印到标准输出设备上本文来自 Important_ 的CSDN 博客 ，全文地址请点击：[Linux下实现进度条](https://blog.csdn.net/Important_/article/details/78632500)2.进度条代码prograss_bar.c12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main()&#123; int i = 0; char bar[102] = &#123; 0 &#125;; const char* lable = &quot;|/-\\&quot;; while(i &lt;= 100) &#123; printf(&quot;[%-100s][%d%%][%c]\r&quot;,bar, i, lable[i%4]);//缓冲区未刷新 fflush(stdout);//刷新缓冲区 bar[i++] = &apos;#&apos;; usleep(100000);//沉睡100ms &#125; printf(&quot;\n&quot;); return 0;&#125;Makefile12345678910111213prograss_bar:prograss_bar.o gcc prograss_bar.c -o prograss_barprograss_bar.o:prograss_bar.s gcc -c prograss_bar.s -o prograss_bar.oprograss_bar.s:prograss_bar.i gcc -S prograss_bar.i -o prograss_bar.sprograss_bar.i:prograss_bar.c gcc -E prograss_bar.c -o prograss_bar.i.PHONE:cleanclean: rm -f prograss_bar.i prograss_bar.s prograss_bar.o prograss_bar3.彩色进度条prograss_bar.c12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main()&#123; int i = 0; char bar[102] = &#123; 0 &#125;; const char* lable = &quot;|/-\\&quot;; while(i &lt;= 100) &#123; printf(&quot;\e[34m[%-100s][%d%%][%c]\r\e[0m&quot;,bar, i, lable[i%4]); fflush(stdout); bar[i++] = &apos;#&apos;; usleep(100000); &#125; printf(&quot;\n&quot;); return 0;&#125;4.当出现下面的情况时可以试下调整字体大小（Ctrl + ‘-‘ 和 Ctrl + Shift+ ‘+’）或者是分辨率。六、 Linux下软件安装的几种方式(源码安装, rpm安装, yum安装)1.源码安装：编译源码，然后安装&emsp;1.1安装准备&emsp;&emsp;a..首先用yum安装gcc，用于编译源码&emsp;&emsp;b.管网下载源码包&emsp;&emsp;c、winSCP windows与Linux传输文件（若直接用安装软件的linux电脑下载就不用传输了）&emsp;1.2 安装过程&emsp;&emsp;a、解压&emsp;&emsp;b、进入解压后的目录配置文件 ./configure # 大多数情况下源码包都会带configure这样一个配置工具，具体使用方法可以vim查看其内容&emsp;&emsp;c、make #编译源码包 如果报错了 make clean 清除缓存重新make&emsp;&emsp;d、make install # 安装然后删除源码包软件和安装目录2.rpm安装：&emsp;rpm安装：安装别人编译好的软件包&emsp;rpm即Redhat Package Manager，Redhat的软件包管方式，适用rpm install 命令&emsp;rpm不仅已经把软件源代码编译成二进制文件，而且对软件包依赖的文件，系统环境等做了统计文件扩展名：rpm 还有一种SRPM：没有编译成二进制文件，但是也包含rpm的特性3.yum安装&emsp;用rpm方式安装软件，如果依赖的软件没有事先安装，软件无法安装成功。&emsp;为了解决这个问题，推出yum方式。既然依赖的软件没有安装在机器上，那么就先安装依赖文件，再安装我需要安装的软件。因此yum在安装软件同时安装依赖文件。因此需要一个yum源来放依赖的软件源，对比被安装机器上rpm软件库归根到底，yum也是基于rpm的。Linux下软件安装方式详解：[Linux安装软件](https://www.cnblogs.com/gmlkl/p/9354254.html#_label4_7)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不求甚解]]></title>
    <url>%2F2018%2F10%2F21%2FMind10_21%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;谨以为向自由世界奋斗的勇士们致敬！ &emsp;&emsp;我是一个追着自己兴趣走的人，虽然家境一般，但是父母在我成长的过程中很大程度上给了我一定的自由，现在的我很感激我过去18年的遇到的人、事、物，他们让我拥有了一个健全的人格和时间观，谢谢。 &emsp;&emsp;几年了，一路兜兜转转又回到了学校，有很多事发生，有很多人错过，心底里压了很多事没办法说出来，这就是成长的代价了吧。我喜欢很多东西，画画，文学。要是没有接触计算机的话，我想我可能会作为一个小说家，或者公务员，然后接结束大学生涯，在开始那未知的生活。谁曾想，或许从一开始的接触就决定了这一辈子将离不开这个由0和1组成的世界了。现在的我每每回想起过去的自己就好像自己是个未开心智的混沌顽石一样，熬过了五百年的风雨，方才一朝破石而出。很幸运的是我不像那孙猴子一样无父无母，我也没有被压在五行山下然后才懂得自己这一生的使命是什么，少年有个美好的童年，青年有一场平平淡淡的爱情，中年能有毅力打拼一番事业，老年能有个陪你说话的老伴，这就是我的理想中的完美的一生。 &emsp;&emsp;说起来好奇计算机还是《黑客帝国》这部电影带我入“坑”呢，从此一发不可收拾，后来长大后，我就得我性格里有一种东西就是掌控自己的一切，我讨厌那种不受人掌控的无奈。所以我想通过我自己个人的努力让自己在这世界上能获得自由，所幸的是计算机的力量是无与伦比的，所以让我沉醉，享受。 &emsp;&emsp;不求甚解，我觉得是我为人处世，工作学习的总结了，该认真探索的我积极了解，不该我了解的我一听而过，当做长见识，所以在0和1中穿梭的我，却要做到求甚解。]]></content>
      <categories>
        <category>心录</category>
      </categories>
      <tags>
        <tag>我的学习之路</tag>
      </tags>
  </entry>
</search>
