<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[栈应用及迷宫问题]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%A0%88%E5%BA%94%E7%94%A8%E5%8F%8A%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一、栈 栈是一种重要的线性结构，在数据结构而言，其本质操作是线性表操作的子集。但在数据类型来说，是一种重要的抽象数据类型。在面向对象的程序设计中，栈是多数据类型。 栈只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底。不含任何元素的栈称为空栈，栈又称为后进先出的线性表，简称LIFO结构。栈可以将数据从一种序列变到另一种序列。 二、栈的分类 顺序栈，即栈的顺序存储结构是利用一组地址连续的存储单元依次存放自栈底到栈顶的元素，一般使用过程中所需的最大空间，故先给栈分配一个基本容量，在使用过程中然后增容。 链式栈，是一种不连续的存储结构，元素以Node的形式存储，包含数据域和指针域，指针域指向下一个节点，每个节点随机分布，为动态开辟节点。 三、栈的基本模块无论是链式栈还是顺序栈其基本操作都一样，包含栈的创建，初始化，销毁，插入，删除，取栈顶元素等，只是其实现方式不同。下面就是顺序栈的模块。- 栈代码：头文件”Stack.h”12345678910111213141516171819202122232425262728293031323334353637383940414243#pragma once#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;assert.h&gt;#include &lt;stdlib.h&gt;////typedef int DataType;////#define N 10//typedef struct Stack//&#123;// DataType _a[N];//规定数组空间大小// int _top; // 栈顶//&#125;Stack;//静态栈typedef struct Pos&#123; int _row; int _col;&#125;Pos;//迷宫位置点typedef Pos DataType;typedef struct Stack&#123; DataType* _a; //节点指针 int _top; // 栈顶 int _capacity; // 容量&#125;Stack;void StackInit(Stack* ps);//初始化void StackDestory(Stack* ps);//销毁void StackPush(Stack* ps, DataType x);//压栈void StackPop(Stack* ps);//出栈DataType StackTop(Stack* ps);//取栈顶元素int StackEmpty(Stack* ps);//判空int StackSize(Stack* ps);//栈的大小//void TestStack();函数文件”Stack.c”12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &quot;Stack.h&quot;void StackInit(Stack* ps)&#123; ps-&gt;_a = (DataType*)malloc(sizeof(DataType)* 3);//动态开辟空间 assert(ps);//防止开辟失败 ps-&gt;_capacity = 3; ps-&gt;_top = 0;&#125;void StackDestory(Stack* ps)&#123; assert(ps);//断言 if (ps-&gt;_a) &#123; free(ps-&gt;_a); ps-&gt;_a = NULL; ps-&gt;_capacity = ps-&gt;_top = 0; &#125; while (ps-&gt;_top--) &#123; free(ps-&gt;_top); &#125; ps-&gt;_capacity = 0;&#125;void StackPush(Stack* ps, DataType x)&#123; assert(ps); if (ps-&gt;_top == ps-&gt;_capacity)//越界 &#123; ps-&gt;_a = (DataType*)realloc(ps-&gt;_a, sizeof(DataType)*(ps-&gt;_capacity * 2));//增容 assert(ps-&gt;_a); ps-&gt;_capacity *= 2; &#125; ps-&gt;_a[ps-&gt;_top] = x; ps-&gt;_top++;&#125;void StackPop(Stack* ps)&#123; assert(ps-&gt;_a); assert(ps-&gt;_top &gt; 0); ps-&gt;_top--;&#125;DataType StackTop(Stack* ps)&#123; assert(ps-&gt;_a &amp;&amp; ps-&gt;_top &gt; 0); return ps-&gt;_a[ps-&gt;_top - 1];&#125;//空 0//非空 1int StackEmpty(Stack* ps)&#123; assert(ps); return ps-&gt;_top == 0 ? 0 : 1;&#125;int StackSize(Stack* ps)&#123; assert(ps); return ps-&gt;_top;&#125;//测试代码//void TestStack()//&#123;// Stack s;// StackInit(&amp;s);//// StackPush(&amp;s, 1);// StackPush(&amp;s, 2);// StackPush(&amp;s, 3);// StackPush(&amp;s, 4);//// while (StackEmpty(&amp;s))// &#123;// printf(&quot;%d &quot;,StackTop(&amp;s));// StackPop(&amp;s);// &#125;// printf(&quot;\n&quot;);////// StackDestory(&amp;s);//&#125; 四、迷宫 迷宫问题，望文生义就是在迷宫当中找到出口，出入口自定义，解决迷宫问题的过程中以回溯法为思想，应用栈的知识来解决这个问题。对于迷宫问题的思考是由解决简单的迷宫然后到环路迷宫这样一个过程的。 回溯法：对一个包括有很多个结点，每个结点有若干个搜索分支的问题，把原问题分解为若干个子问题进行求解的算法；当搜索到某个结点发现无法再继续搜索下去时，就让搜索过程回溯到该结点的前一个结点，继续搜索该结点外的其他尚未搜索的分支；如果发现该结点无法再搜索下去，就让搜索过程回溯到这个结点的前一个结点继续这样的搜索过程。 1.简单迷宫——–从出口处将开始进行压栈，判断其上，下，左，右方向是否可走，若某个方向可走将其坐标进行压栈，并将坐标上的值置为2，再探测该坐标的分支，直到出口，返回1即找到出口，若在某一个结点处四个方向均不可走则返回上一个坐标，并将该坐标从栈中释放，若栈为空时仍未到出口处则返回0即未找到出口。0 0 0 0 0 00 0 1 0 0 00 0 1 0 0 00 0 1 1 1 00 0 1 0 1 10 0 1 0 0 0 2.多路迷宫——–在简单迷宫的基础上当找到出口时并不返回值，当栈为空即回溯到出口时返回到主函数。0 0 0 0 0 00 0 1 0 0 00 0 1 1 1 10 0 1 0 0 00 0 1 1 1 10 0 1 0 0 0 3.环路迷宫——–在多路迷宫的基础上，在设置压入栈的坐标的值时换为前一个坐标的值加1,即递增的。在判断某个坐标是否可走时变换条件，进而达到目的。0 0 0 0 0 00 0 1 1 1 00 0 1 0 1 00 0 1 0 1 00 0 1 1 1 10 0 1 0 0 0 迷宫代码（环路迷宫代码）：头文件”maze.h” 12345678910111213141516171819202122232425262728293031323334#pragma once#include&quot;Stack.h&quot;#define N 6int size;static int maze[N][N] = &#123;//static,只在maze.c中可见 /*&#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;,*/ /*&#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 0 &#125;, &#123; 0, 0, 1, 0, 1, 0 &#125;, &#123; 0, 0, 1, 0, 1, 0 &#125;, &#123; 0, 0, 1, 1, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;,*/ &#123; 0, 0, 0, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;, &#123; 0, 0, 1, 1, 1, 0 &#125;, &#123; 0, 0, 1, 0, 1, 1 &#125;, &#123; 0, 0, 1, 0, 0, 0 &#125;,&#125;;int GetMazePath(Pos entry, Pos exit);//获取迷宫通路:找到通路/找不到通路int CheckAccess(Pos cur, Pos next);void PrintfMaze();void TestMaze(); 函数文件”maze.c” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&quot;Maze.h&quot;int CheckAccess(Pos cur, Pos next)&#123; if (next._row &gt;= 0 &amp;&amp; next._row &lt; N &amp;&amp;next._col &gt;= 0 &amp;&amp; next._col &lt; N &amp;&amp; (maze[next._row][next._col] == 1 || maze[next._row][next._col] &gt; maze[cur._row][cur._col] + 1))//当下一个坐标的值为1 或者比当前值加一还大就可以走 &#123; return 1; &#125; else &#123; return 0; &#125;&#125;int size = 0;int GetMazePath(Pos entry, Pos exit)&#123; Stack path; int flag = 0; StackInit(&amp;path); StackPush(&amp;path, entry); maze[entry._row][entry._col] = 2;//入口初始化为2 while (StackEmpty(&amp;path)) &#123; //Pos cur = entry;//当前位置 Pos cur = StackTop(&amp;path);//栈顶取出的当前位置 //if (cur._col == 5)//多条通路 if (cur._row == exit._row &amp;&amp;cur._col == exit._col)//当一条路径找到出口时，打印路径并且看路径长短 &#123; flag = 1; for (int i = 0; i &lt; path._top; i++) &#123; printf(&quot;[%d %d]-&gt;&quot;, path._a[i]._row, path._a[i]._col); &#125; printf(&quot; Exit\n\n&quot;); if (size == 0 || StackSize(&amp;path) &lt; size) &#123; size = StackSize(&amp;path);//路径的长短 &#125; &#125; Pos next; //上 next = cur;//当前位置 next._row -= 1;//下一个位置 if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //下 next = cur; next._row += 1; if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //左 next = cur; next._col -= 1; if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //右 next = cur; next._col += 1; if (CheckAccess(cur, next)) &#123; maze[next._row][next._col] = maze[cur._row][cur._col] + 1; StackPush(&amp;path, next);//下一个位置可以通，入栈 continue; &#125; //走到四个方向不通的位置 //回溯 StackPop(&amp;path); &#125; if (flag == 0)//判断是否找到出口 return 0; else return 1;&#125;void PrintfMaze()&#123; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; N; ++j) &#123; printf(&quot;%d &quot;, maze[i][j]); &#125; printf(&quot;\n&quot;); &#125; printf(&quot;\n&quot;);&#125; 主函数文件”main.c” 12345678910111213141516171819202122232425262728293031#include &quot;maze.h&quot;void TestMaze()&#123; Pos entry; entry._row = 5; entry._col = 2; Pos exit; exit._row = 4; exit._col = 5; printf(&quot;迷宫地图:\n&quot;); PrintfMaze(); if (GetMazePath(entry, exit)) &#123; printf(&quot;有出口，最短路径为：%d \n\n&quot;, size); &#125; else &#123; printf(&quot;无出口！\n\n&quot;); &#125; printf(&quot;走出后迷宫地图:\n&quot;); PrintfMaze();&#125;int main()&#123; TestMaze(); system(&quot;pause&quot;); return 0;&#125; 五、运行结果 1.简单迷宫 2.多路迷宫 3.环路迷宫 结合之前的栈的基本操作代码就可以解决迷宫问题了。-(￣▽￣)-*]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>迷宫</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux开发工具相关问题]]></title>
    <url>%2F2018%2F10%2F21%2FLinux%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在Linux的系统设置问题上，学会使用文本编辑器来编辑Linux参数配置文件是一项很重要的能力。Linux环境下的文本编辑器有很多，重点掌握VIM却是很有必要的。VIM是VI的升级版，很多软件的编辑接口会主动调用VI，而VIM已经不仅仅可以作为一个文本编辑器，也可以作为程序开发工具，供程序开发者使用。 一、 vim的配置 一些简单配置Linux的命令有： set nu // 在左侧行号set tabstop=4 //tab 长度设置为 4set nobackup //覆盖文件时不备份set cursorline //突出显示当前行set ruler //在右下角显示光标位置的状态行set autoindent //自动缩进set mouse=a //允许使用鼠标移动光标set showmode //显示左下角状态行set hlsearch //搜索时关键字高亮反白set showcmd 配置vim的文件在目录/etc下面，有个名为vimrc的文件，这就是系统中公共的vim配置文件，对所有用户都开放。而在每个用户的主目录下，都可以自己建立私有的配置文件，命名为：”.vimrc”。用vim打开.vimrc键入上述命令保存即可。 关于vim的简单配置详细的介绍：VIM简单配置如何获得良好的界面：vim配置界面要想获得更强大的功能可以点击：大牛：超级强大的VIM配置(vimplus) 二、常用的编辑器, 以及这些编辑器之间的区别和优缺点.Linux中强大的编辑器列表 VI 编辑器是一个基于命令行的、功能强大的文本编辑器，最早为 Unix 系统开发，后来也被移植到许多的 Unix 和 Linux 发行版上。 VIM（也被称作 VI IMproved）——VI 编辑器的高阶版本，在 VI 已经很强的功能上添加了更多的功能，这些功能有： 支持更多 Linux 发行版， 支持多种编程语言，包括 python、c++、perl 等语言的代码块折叠，语法高亮， 支持通过多种网络协议，包括 http、ssh 等编辑文件， 支持编辑压缩归档中的文件， Emacs：著名的集成开发环境和文本编辑器。Emacs和Vim对于 Linux 桌面上进行文本编辑是重量级的，Emacs演化出了众多分支，其中使用最广泛的两种是：1984年由Richard Stallman发起的GNU Emacs，以及1991年发起的XEmacs。XEmacs是GNU Emacs的分支，至今仍保持着相当的兼容性。最新的的GNU EMACS的功能包括: 内容感知编辑模式，包括许多文件类型的语法着色。 完整的内置文档，包括新用户教程。 几乎所有人类脚本都支持 完全Unicode。 高度可定制，使用Emacs Lisp代码或图形界面。 超越文本编辑，包括功能的整个生态系统的项目策划人，邮件和新闻阅读器，调试器接口， 日历，和更多。 用于下载和安装扩展的包装系统等等 详情点击：GNU Eclipse：Eclipse 是一个开放源代码的、基于Java的可扩展开发平台。就其本身而言，它只是一个框架和一组服务，用于通过插件组件构建开发环境。幸运的是，Eclipse 附带了一个标准的插件集，包括Java开发工具（Java Development Kit，JDK）。最初主要用来Java语言开发，但是目前亦有人通过插件使其作为其他计算机语言比如C++和Python的开发工具。 在Eclipse中，完全胜任以下编程语言的工作——Python, R, Ruby, JavaScript, Natural, Lasso, C, C++, COBOL, Scheme, Clojure, Groovy等等 Eclipse官网：ECLIPSEFOUNDATION Brackets：Adobe公司发布了Brackets 1.0，一款针对Web设计人员的免费开源文本编辑器，内置HTML，CSS和JavaScript，方便开发者进行HTML，CSS和JavaScript编程。Brackets 1.0适用于Windows，Mac和Linux操作系统，为Web设计人员和开发人员提供针对性的功能，如： 实时预览，在浏览器视图和源代码之间轻松切换， 在特定的代码位进行内联编辑工作，而无需弹出式窗口或其他选项卡。 下载和使用扩展，添加功能以帮助他们的工作流程，如Git整合和JSHint支持 摘要预览，自动从PSD获取设计信息， Brackets作为一个开源项目，对于想要自定义文本编辑器的用户，可以从Github上Brackets项目页面下载源代码并修改代码进行编译，来适合自己的需求。 官方网站：http://brackets.io/ Github代码托管：https://www.github.com/adobe/brackets LightTable是一个免费开放源代码的编辑器，该编辑器有一个非常干净的界面，并有大量扩展。它与Windows、Mac和Linux都兼容，是高度可定制的。使用Light Table，开发者只需打开一个浏览器窗口即可实时查看更改，并且支持不同的嵌入。 更改: 我们从 NW.js 切换到了 Electron 更改: Light Table 的发行与自更新进程完全地公开在github上 增加: Light Table 可以用提供的脚本在各个支持的平台上从源码构建 增加: Light Table 大部分的 node 代码库将通过 npm 依赖来安装，以取代以前采用分叉库的方式 增加: 有效文档。更多详情内容见下面 修复: 版本号 &gt;= OSX 10.10的系统下的主要的可用性问题 更改: 官方不再提供 32位 Linux 软件包下载，不过仍然支持从源码构建 修复: ClojureScript eval 支持 ClojureScript 的现代版本 参阅更多 github.com/LightTable/LightTable/releases Chocolat：Chocolat本身是Mac OS 的最佳代码编辑器。该编辑器旨在与OS无缝集成，Chocolat为JS、Python和HTML提供拖放功能、拆分编辑、代码折叠和代码完成，兼具原生的Cocoa及强大的文本编辑功能。Chocolat支持很多种编程语言的关键字高亮显示、窗口分割、标签页、色彩主题等功能。界面和MacVim非常相似。 Sublime Text：Sublime Text 是一个轻量、简洁、高效、跨平台的编辑器。 支持多光标操作：它能让你对文本中的多个地方同时做修改，你可以看到多个地方在你输入的时候同时发生变化， command palette能够让你轻松的做任何操作，勉去了记忆众多快捷键的痛苦。你只需要打开command palette ，输入几个字母，Sublime Text会用模糊查询给你提供建议和选项。跟直接使用快捷键几乎没区别 编辑文件的同时你可以启动编译，看到输出结果，这种交互能让你快速发现编译错误 扩展性很好，它使用了Python式的插件系统。 三、 常用的编译器(不限制编程语言, 不限制平台) MSVC:是指微软的VC编译器,随着微软发布基于Clang / C2,MSVC与Clang / C2并行，继 Google Chrome 宣布弃用微软 C++ 编译器（MSVC）Windows 版 Chrome 改用 Clang 之后，Mozilla 的 Firefox 浏览器也宣布开始使用 Clang 编译器编译其 Windows 版本。 Clang：Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的 C/C++/Objective C/Objective C++ 编译器，其目标（之一）就是超越 GCC。Clang 的特性有： 快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 是 Apple GCC 4.0 的 2.5x 快。 内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10x。 诊断信息可读性强：其中错误的语法不但有源码提示，还会在错误的调用和相关上下文的下方有提示。 GCC 兼容性。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 基于库的模块化设计，易于 IDE 集成及其他用途的重用。由于历史原因，GCC 是一个单一的可执行程序编译器，其内部完成了从预处理到最后代码生成的全部过程，中间诸多信息都无法被其他程序重用。Clang 将编译过程分成彼此分离的几个阶段，AST 信息可序列化。通过库的支持，程序能够获取到 AST 级别的信息，将大大增强对于代码的操控能力。对于 IDE 而言，代码补全、重构是重要的功能，然而如果没有底层的支持，只使用 tags 分析或是正则表达式匹配是很难达成的。 GCC/G++：gcc和g++都是GNU(组织)的一个编译器。gcc 是c的编译器，g++是c++的编译器。(常见GCC和G++的误区：[GCC和G++的区别])(https://my.oschina.net/Failure/blog/114283) ICC：全称Intel C++ Compiler，是Intel开发的C/C++/Fortran编译器套装，适用于Linux、Microsoft和Mac OS X操作系统，没有非IA指令集版本(就是说仅供x86架构CPU使用)。ICC广泛应用于高性能计算、分布式计算等商业计算领域，其向量化和并行化性能是业界的标杆，能够充分发挥现代处理器的特性。(ICC官方网：)ICC IBM XL C++：IBM® XL C/C++ 是一种编译器，有助于为 IBM Power Systems™ 创建和维护使用 C/C++ 编写的应用，能最大限度地提高硬件利用率。缺点则是在编译时间上往往过长。对C++标准的支持、开源软件的支持、错误信息的提示上都不够友好，但随着13.2开始结合Clang正在进行优化。(官方网站：[IBM XL C++](https://www.ibm.com/cn-zh/marketplace/xl-cpp-aix-compiler-power)) 四、为什么调试的时候需要编译选项中添加 -g. 介绍readelf命令.1 .调试的时候加上 -g 是为了生成调试信息，以便于GNU调试器利用该信息，2.readelf命令用来显示一个或者多个elf格式的目标文件的信息，可以通过它的选项来控制显示哪些信息。这里的elf-file(s)就表示那些被检查的文件。可以支持32位，64位的elf格式文件，也支持包含elf文件的文档（这里一般指的是使用ar命令将一些elf文件打包之后生成的例如lib*.a之类的“静态库”文件）。(ELF文件， 其实就是Executable &amp; Linkable Format, 是一种文件格式， 我们常见的目标文件、动态库和可执行文件， 都属于这个类型。)五、 在Linux下实现进度条程序. 通过makefile进行编译. 以及实现全彩色的进度条.1.缓冲区概念缓冲区(buffer)这个中文译意源自当计算机的高速部件与低速部件通讯时,必须将高速部件的输出暂存到某处,以保证高速部件与低速部件相吻合. 后来这个意思被扩展了,成为”临时存贮区”的意思。 缓冲区分为：无缓冲、行缓冲、全缓冲。 无缓冲：表示的是没有缓冲，可以将信息立马显现出来，典型代表是标准错误流stderr。 行缓冲：表示的是输入输出遇到换行才执行真正的I/O操作。典型的代表是键盘的操作。 全缓冲：表示的是输入输出写满缓冲区才执行I/O操作。典型的代表是磁盘的读写。 fflush: fflush，函数名， 清除读写缓冲区，需要立即把输出缓冲区的数据进行物理写入时。 fflush(stdin)刷新标准输入缓冲区，把输入缓冲区里的东西丢弃[非标准] fflush(stdout)刷新标准输出缓冲区，把输出缓冲区里的东西打印到标准输出设备上本文来自 Important_ 的CSDN 博客 ，全文地址请点击：[Linux下实现进度条](https://blog.csdn.net/Important_/article/details/78632500)2.进度条代码prograss_bar.c12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main()&#123; int i = 0; char bar[102] = &#123; 0 &#125;; const char* lable = &quot;|/-\\&quot;; while(i &lt;= 100) &#123; printf(&quot;[%-100s][%d%%][%c]\r&quot;,bar, i, lable[i%4]);//缓冲区未刷新 fflush(stdout);//刷新缓冲区 bar[i++] = &apos;#&apos;; usleep(100000);//沉睡100ms &#125; printf(&quot;\n&quot;); return 0;&#125;Makefile12345678910111213prograss_bar:prograss_bar.o gcc prograss_bar.c -o prograss_barprograss_bar.o:prograss_bar.s gcc -c prograss_bar.s -o prograss_bar.oprograss_bar.s:prograss_bar.i gcc -S prograss_bar.i -o prograss_bar.sprograss_bar.i:prograss_bar.c gcc -E prograss_bar.c -o prograss_bar.i.PHONE:cleanclean: rm -f prograss_bar.i prograss_bar.s prograss_bar.o prograss_bar3.彩色进度条prograss_bar.c12345678910111213141516171819#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main()&#123; int i = 0; char bar[102] = &#123; 0 &#125;; const char* lable = &quot;|/-\\&quot;; while(i &lt;= 100) &#123; printf(&quot;\e[34m[%-100s][%d%%][%c]\r\e[0m&quot;,bar, i, lable[i%4]); fflush(stdout); bar[i++] = &apos;#&apos;; usleep(100000); &#125; printf(&quot;\n&quot;); return 0;&#125;4.当出现下面的情况时可以试下调整字体大小（Ctrl + ‘-‘ 和 Ctrl + Shift+ ‘+’）或者是分辨率。六、 Linux下软件安装的几种方式(源码安装, rpm安装, yum安装)1.源码安装：编译源码，然后安装&emsp;1.1安装准备&emsp;&emsp;a..首先用yum安装gcc，用于编译源码&emsp;&emsp;b.管网下载源码包&emsp;&emsp;c、winSCP windows与Linux传输文件（若直接用安装软件的linux电脑下载就不用传输了）&emsp;1.2 安装过程&emsp;&emsp;a、解压&emsp;&emsp;b、进入解压后的目录配置文件 ./configure # 大多数情况下源码包都会带configure这样一个配置工具，具体使用方法可以vim查看其内容&emsp;&emsp;c、make #编译源码包 如果报错了 make clean 清除缓存重新make&emsp;&emsp;d、make install # 安装然后删除源码包软件和安装目录2.rpm安装：&emsp;rpm安装：安装别人编译好的软件包&emsp;rpm即Redhat Package Manager，Redhat的软件包管方式，适用rpm install 命令&emsp;rpm不仅已经把软件源代码编译成二进制文件，而且对软件包依赖的文件，系统环境等做了统计文件扩展名：rpm 还有一种SRPM：没有编译成二进制文件，但是也包含rpm的特性3.yum安装&emsp;用rpm方式安装软件，如果依赖的软件没有事先安装，软件无法安装成功。&emsp;为了解决这个问题，推出yum方式。既然依赖的软件没有安装在机器上，那么就先安装依赖文件，再安装我需要安装的软件。因此yum在安装软件同时安装依赖文件。因此需要一个yum源来放依赖的软件源，对比被安装机器上rpm软件库归根到底，yum也是基于rpm的。Linux下软件安装方式详解：[Linux安装软件](https://www.cnblogs.com/gmlkl/p/9354254.html#_label4_7)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不求甚解]]></title>
    <url>%2F2018%2F10%2F21%2FMind10_21%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;谨以为向自由世界奋斗的勇士们致敬！ &emsp;&emsp;我是一个追着自己兴趣走的人，虽然家境一般，但是父母在我成长的过程中很大程度上给了我一定的自由，现在的我很感激我过去18年的遇到的人、事、物，他们让我拥有了一个健全的人格和时间观，谢谢。 &emsp;&emsp;几年了，一路兜兜转转又回到了学校，有很多事发生，有很多人错过，心底里压了很多事没办法说出来，这就是成长的代价了吧。我喜欢很多东西，画画，文学。要是没有接触计算机的话，我想我可能会作为一个小说家，或者公务员，然后接结束大学生涯，在开始那未知的生活。谁曾想，或许从一开始的接触就决定了这一辈子将离不开这个由0和1组成的世界了。现在的我每每回想起过去的自己就好像自己是个未开心智的混沌顽石一样，熬过了五百年的风雨，方才一朝破石而出。很幸运的是我不像那孙猴子一样无父无母，我也没有被压在五行山下然后才懂得自己这一生的使命是什么，少年有个美好的童年，青年有一场平平淡淡的爱情，中年能有毅力打拼一番事业，老年能有个陪你说话的老伴，这就是我的理想中的完美的一生。 &emsp;&emsp;说起来好奇计算机还是《黑客帝国》这部电影带我入“坑”呢，从此一发不可收拾，后来长大后，我就得我性格里有一种东西就是掌控自己的一切，我讨厌那种不受人掌控的无奈。所以我想通过我自己个人的努力让自己在这世界上能获得自由，所幸的是计算机的力量是无与伦比的，所以让我沉醉，享受。 &emsp;&emsp;不求甚解，我觉得是我为人处世，工作学习的总结了，该认真探索的我积极了解，不该我了解的我一听而过，当做长见识，所以在0和1中穿梭的我，却要做到求甚解。]]></content>
      <categories>
        <category>心录</category>
      </categories>
      <tags>
        <tag>我的学习之路</tag>
      </tags>
  </entry>
</search>
